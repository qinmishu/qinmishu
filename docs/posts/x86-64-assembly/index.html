<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.310">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="秦米书">
<meta name="dcterms.date" content="2023-10-21">

<title>亲密数 - x86-64汇编语言编程</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">亲密数</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html" rel="" target="">
 <span class="menu-text">关于</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/qinmishu" rel="" target=""><i class="bi bi-github" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://blog.csdn.net/xuhx" rel="" target=""><i class="bi bi-twitter" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">x86-64汇编语言编程</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">x86-64</div>
                <div class="quarto-category">assembly</div>
                <div class="quarto-category">linux</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>秦米书 </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">October 21, 2023</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#references" id="toc-references" class="nav-link active" data-scroll-target="#references">References</a></li>
  <li><a href="#general-notes" id="toc-general-notes" class="nav-link" data-scroll-target="#general-notes">General Notes</a>
  <ul>
  <li><a href="#misc" id="toc-misc" class="nav-link" data-scroll-target="#misc">misc</a></li>
  <li><a href="#hello-world-program-x86-64-position-indepent-code" id="toc-hello-world-program-x86-64-position-indepent-code" class="nav-link" data-scroll-target="#hello-world-program-x86-64-position-indepent-code">Hello world program x86-64, position indepent code</a></li>
  <li><a href="#hello-world-program-x86-64" id="toc-hello-world-program-x86-64" class="nav-link" data-scroll-target="#hello-world-program-x86-64">Hello world program x86-64</a></li>
  <li><a href="#hello-world-program-x86-32-bit" id="toc-hello-world-program-x86-32-bit" class="nav-link" data-scroll-target="#hello-world-program-x86-32-bit">Hello world program X86 32 bit</a></li>
  <li><a href="#call-instruction-to-call-a-function" id="toc-call-instruction-to-call-a-function" class="nav-link" data-scroll-target="#call-instruction-to-call-a-function">call instruction to call a function</a></li>
  <li><a href="#the-64-bit-x86-c-calling-convention" id="toc-the-64-bit-x86-c-calling-convention" class="nav-link" data-scroll-target="#the-64-bit-x86-c-calling-convention">The 64 bit x86 C Calling Convention</a></li>
  <li><a href="#the-32-bit-x86-c-calling-convention" id="toc-the-32-bit-x86-c-calling-convention" class="nav-link" data-scroll-target="#the-32-bit-x86-c-calling-convention">The 32 bit x86 C calling Convention</a></li>
  <li><a href="#general-purpose-registers-in-x86-64" id="toc-general-purpose-registers-in-x86-64" class="nav-link" data-scroll-target="#general-purpose-registers-in-x86-64">General purpose registers in X86-64</a></li>
  <li><a href="#att-syntax" id="toc-att-syntax" class="nav-link" data-scroll-target="#att-syntax">AT&amp;T Syntax</a></li>
  <li><a href="#add-sub-inc-dec" id="toc-add-sub-inc-dec" class="nav-link" data-scroll-target="#add-sub-inc-dec">add, sub, inc, dec</a></li>
  <li><a href="#a-comparison-of-gas-and-nasm" id="toc-a-comparison-of-gas-and-nasm" class="nav-link" data-scroll-target="#a-comparison-of-gas-and-nasm">A comparison of GAS and NASM</a></li>
  </ul></li>
  <li><a href="#book-programming-from-the-ground-up-by-jonathan-bartlett-author" id="toc-book-programming-from-the-ground-up-by-jonathan-bartlett-author" class="nav-link" data-scroll-target="#book-programming-from-the-ground-up-by-jonathan-bartlett-author">Book Programming from the Ground Up by Jonathan Bartlett (Author)</a></li>
  <li><a href="#book-professional-assembly-language-by-richard-blum-good" id="toc-book-professional-assembly-language-by-richard-blum-good" class="nav-link" data-scroll-target="#book-professional-assembly-language-by-richard-blum-good">Book Professional Assembly Language by Richard Blum (Good)</a>
  <ul>
  <li><a href="#chap5-moving-data" id="toc-chap5-moving-data" class="nav-link" data-scroll-target="#chap5-moving-data">Chap5 Moving data</a>
  <ul>
  <li><a href="#moving-data-values-from-memory-to-a-register" id="toc-moving-data-values-from-memory-to-a-register" class="nav-link" data-scroll-target="#moving-data-values-from-memory-to-a-register">moving data values from memory to a register</a></li>
  <li><a href="#moving-data-values-from-a-register-to-memory" id="toc-moving-data-values-from-a-register-to-memory" class="nav-link" data-scroll-target="#moving-data-values-from-a-register-to-memory">moving data values from a register to memory</a></li>
  <li><a href="#using-indexed-memory-locations" id="toc-using-indexed-memory-locations" class="nav-link" data-scroll-target="#using-indexed-memory-locations">Using indexed memory locations</a></li>
  <li><a href="#using-indirect-addressing-with-registers" id="toc-using-indirect-addressing-with-registers" class="nav-link" data-scroll-target="#using-indirect-addressing-with-registers">Using indirect addressing with registers</a></li>
  <li><a href="#conditional-move-instructions" id="toc-conditional-move-instructions" class="nav-link" data-scroll-target="#conditional-move-instructions">Conditional Move Instructions</a></li>
  <li><a href="#exchanging-data" id="toc-exchanging-data" class="nav-link" data-scroll-target="#exchanging-data">Exchanging Data</a></li>
  <li><a href="#stack" id="toc-stack" class="nav-link" data-scroll-target="#stack">Stack</a></li>
  </ul></li>
  <li><a href="#chap6-controlling-execution-flow" id="toc-chap6-controlling-execution-flow" class="nav-link" data-scroll-target="#chap6-controlling-execution-flow">Chap6 Controlling Execution Flow</a></li>
  </ul></li>
  <li><a href="#book-beginning-x64-assembly-programming-by-jo-van-hoey" id="toc-book-beginning-x64-assembly-programming-by-jo-van-hoey" class="nav-link" data-scroll-target="#book-beginning-x64-assembly-programming-by-jo-van-hoey">Book Beginning x64 Assembly Programming by Jo Van Hoey</a></li>
  <li><a href="#book-x64-assembly-language-step-by-step" id="toc-book-x64-assembly-language-step-by-step" class="nav-link" data-scroll-target="#book-x64-assembly-language-step-by-step">Book X64 Assembly Language Step by Step</a>
  <ul>
  <li><a href="#chap1-its-all-in-the-plan-understanding-what-computers-really-do" id="toc-chap1-its-all-in-the-plan-understanding-what-computers-really-do" class="nav-link" data-scroll-target="#chap1-its-all-in-the-plan-understanding-what-computers-really-do">Chap1 It’s all in the Plan: Understanding What Computers Really Do</a></li>
  <li><a href="#chap2-allien-bases-getting-your-arms-around-binary-and-hexadecimal" id="toc-chap2-allien-bases-getting-your-arms-around-binary-and-hexadecimal" class="nav-link" data-scroll-target="#chap2-allien-bases-getting-your-arms-around-binary-and-hexadecimal">Chap2 Allien Bases: Getting Your Arms Around Binary and Hexadecimal</a></li>
  <li><a href="#chap3-lifting-the-hood-discovering-what-computers-actually-are" id="toc-chap3-lifting-the-hood-discovering-what-computers-actually-are" class="nav-link" data-scroll-target="#chap3-lifting-the-hood-discovering-what-computers-actually-are">Chap3 Lifting the Hood: Discovering What Computers Actually Are</a></li>
  <li><a href="#chap4-location-registers-memory-addressing-and-knowing-where-things-are" id="toc-chap4-location-registers-memory-addressing-and-knowing-where-things-are" class="nav-link" data-scroll-target="#chap4-location-registers-memory-addressing-and-knowing-where-things-are">Chap4 Location: Registers, Memory Addressing, and Knowing Where Things Are</a></li>
  <li><a href="#chap5-the-right-to-assemble-the-process-of-creating-assembly-language-programs" id="toc-chap5-the-right-to-assemble-the-process-of-creating-assembly-language-programs" class="nav-link" data-scroll-target="#chap5-the-right-to-assemble-the-process-of-creating-assembly-language-programs">Chap5 The Right to Assemble: The Process of Creating Assembly Language Programs</a></li>
  <li><a href="#chap6-linux-and-the-tools-that-shape-the-way-you-work" id="toc-chap6-linux-and-the-tools-that-shape-the-way-you-work" class="nav-link" data-scroll-target="#chap6-linux-and-the-tools-that-shape-the-way-you-work">Chap6 Linux and the Tools That Shape the Way You Work</a></li>
  <li><a href="#chap7-following-your-instructions-meeting-machine-instructions-up-close-and-personal" id="toc-chap7-following-your-instructions-meeting-machine-instructions-up-close-and-personal" class="nav-link" data-scroll-target="#chap7-following-your-instructions-meeting-machine-instructions-up-close-and-personal">Chap7 Following your instructions: Meeting Machine Instructions Up Close and Personal</a></li>
  <li><a href="#chap8-creating-programs-that-work" id="toc-chap8-creating-programs-that-work" class="nav-link" data-scroll-target="#chap8-creating-programs-that-work">Chap8 Creating programs that work</a></li>
  <li><a href="#chap9-bits-flags-branches-and-tables-easing-into-mainstream-assembly-coding" id="toc-chap9-bits-flags-branches-and-tables-easing-into-mainstream-assembly-coding" class="nav-link" data-scroll-target="#chap9-bits-flags-branches-and-tables-easing-into-mainstream-assembly-coding">Chap9 Bits, Flags, Branches, and Tables, Easing Into Mainstream Assembly Coding</a></li>
  <li><a href="#chap10-dividing-and-conquering-using-procedures-and-macros-to-battle-program-complexity" id="toc-chap10-dividing-and-conquering-using-procedures-and-macros-to-battle-program-complexity" class="nav-link" data-scroll-target="#chap10-dividing-and-conquering-using-procedures-and-macros-to-battle-program-complexity">Chap10 Dividing and Conquering: Using procedures and macros to battle program complexity</a></li>
  <li><a href="#chap11-strings-and-things" id="toc-chap11-strings-and-things" class="nav-link" data-scroll-target="#chap11-strings-and-things">Chap11, Strings and Things</a></li>
  <li><a href="#chap12-calling-external-functions-written-in-the-c-language" id="toc-chap12-calling-external-functions-written-in-the-c-language" class="nav-link" data-scroll-target="#chap12-calling-external-functions-written-in-the-c-language">Chap12, Calling external functions written in the C language</a></li>
  </ul></li>
  <li><a href="#end" id="toc-end" class="nav-link" data-scroll-target="#end">end</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<p>This is a note while studying x86-64 assembler.</p>
<section id="references" class="level1">
<h1>References</h1>
<p><a href="https://filippo.io/linux-syscall-table/">linux syscall table</a></p>
<p><a href="https://www.asciitable.com/">ascii table</a></p>
<p><a href="https://ftp.gnu.org/old-gnu/Manuals/gas-2.9.1/html_chapter/as_7.html">gnu assembler, or gas, or as</a></p>
</section>
<section id="general-notes" class="level1">
<h1>General Notes</h1>
<section id="misc" class="level2">
<h2 class="anchored" data-anchor-id="misc">misc</h2>
<p>GCC(Gnu Compiler Collection) is a front end. It will call <code>as</code> and <code>ld</code>. The process can be viewed if we use <code>-v</code> argument of gcc.</p>
<p>Using <code>-g</code> argument will embed debug info in the object file. E.g. <code>gcc -c first.s -o first.o -g</code>. After that, we are able to use <code>list</code> in GDB to view the source code.</p>
<p>Below table lists the size of x86-64 memory/registers. Some is different from ARM. For example, in ARM, A <code>.word</code> means 32 bits.</p>
<table class="table">
<thead>
<tr class="header">
<th>term</th>
<th>size (bits)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>byte</td>
<td>8</td>
</tr>
<tr class="even">
<td>word</td>
<td>16</td>
</tr>
<tr class="odd">
<td>dword</td>
<td>32</td>
</tr>
<tr class="even">
<td>qword</td>
<td>64</td>
</tr>
</tbody>
</table>
<p>In x86-64, use <code>.long</code> or <code>.int</code> to specify 64 bits integer. In ARM, use <code>.word</code> to specify 32 bits integer. Note, <code>.word</code> or <code>.short</code> may have different lengths in different machine. They are machine dependent.</p>
<p>STDIN file descriptor is 0. STDOUT file descriptor is 1. STDERR file descriptor is 2.</p>
<p>The labels in the assembly program begins with <code>_</code>, e.g.&nbsp;<code>_start</code>, is due to the convention of C compiler. It is the simple name mangaling. <code>C++</code> has more complex name mangling.</p>
</section>
<section id="hello-world-program-x86-64-position-indepent-code" class="level2">
<h2 class="anchored" data-anchor-id="hello-world-program-x86-64-position-indepent-code">Hello world program x86-64, position indepent code</h2>
<div class="sourceCode" id="cb1"><pre class="sourceCode numberSource asm number-lines code-with-copy"><code class="sourceCode fasm"><span id="cb1-1"><a href="#cb1-1"></a>//first<span class="op">.</span>s </span>
<span id="cb1-2"><a href="#cb1-2"></a>//pay attention to the <span class="op">`</span>lea msg<span class="op">(%</span>rip<span class="op">)`</span> instruction </span>
<span id="cb1-3"><a href="#cb1-3"></a>.<span class="bu">data</span></span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="fu">msg:</span></span>
<span id="cb1-5"><a href="#cb1-5"></a>    .asciz <span class="st">"Hello, world!\n"</span></span>
<span id="cb1-6"><a href="#cb1-6"></a> </span>
<span id="cb1-7"><a href="#cb1-7"></a>.extern printf</span>
<span id="cb1-8"><a href="#cb1-8"></a>.extern flush</span>
<span id="cb1-9"><a href="#cb1-9"></a>.text</span>
<span id="cb1-10"><a href="#cb1-10"></a>    .global main <span class="op">#</span> entry point</span>
<span id="cb1-11"><a href="#cb1-11"></a><span class="fu">main:</span></span>
<span id="cb1-12"><a href="#cb1-12"></a>    <span class="bu">movq</span> <span class="op">%</span><span class="kw">rsp</span><span class="op">,</span> <span class="op">%</span><span class="kw">rbp</span> <span class="co">;#for correct debugging</span></span>
<span id="cb1-13"><a href="#cb1-13"></a>    andq <span class="op">$-</span><span class="dv">16</span><span class="op">,</span> <span class="op">%</span><span class="kw">rsp</span></span>
<span id="cb1-14"><a href="#cb1-14"></a>    <span class="bu">lea</span> msg<span class="op">(%</span>rip<span class="op">),</span> <span class="op">%</span><span class="kw">rdi</span> <span class="co">;position independent code </span></span>
<span id="cb1-15"><a href="#cb1-15"></a>    <span class="cf">call</span> printf</span>
<span id="cb1-16"><a href="#cb1-16"></a>    <span class="bu">movq</span> <span class="op">%</span><span class="kw">rbp</span><span class="op">,</span> <span class="op">%</span><span class="kw">rsp</span></span>
<span id="cb1-17"><a href="#cb1-17"></a>    xorq <span class="op">%</span><span class="kw">rax</span><span class="op">,</span> <span class="op">%</span><span class="kw">rax</span></span>
<span id="cb1-18"><a href="#cb1-18"></a>    <span class="cf">ret</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>to build it.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode numberSource bash number-lines code-with-copy"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1"></a><span class="fu">gcc</span> <span class="at">-c</span> <span class="at">-g</span> <span class="at">-o</span> first.o first.s </span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="fu">gcc</span> <span class="at">-o</span> first first.o </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Refer to https://reverseengineering.stackexchange.com/questions/18007/disassembly-shows-lea-with-rip</p>
<p>Unlike 32bits modes instructions that were taken as absolute addresses (use 32-bit immediate offset addressing), the 64bits modes (a.k.a long-mode) are usually using 32-bit offset from the current RIP, not from 0x00000000 like before. That means that you don’t have to know the absolute address of something you want to reference, you only need to know how far away it is from the currently executing instruction.</p>
<p>There are very few addressing modes which use a full 64bit absolute address. Most addressing modes are 32bit offsets relative to one of the 64bit registers (usually RIP).</p>
</section>
<section id="hello-world-program-x86-64" class="level2">
<h2 class="anchored" data-anchor-id="hello-world-program-x86-64">Hello world program x86-64</h2>
<p>The program is copied from <a href="https://www.youtube.com/watch?v=3nYHV5zIQGA&amp;list=PLvv0ScY6vfd9BSBznpARlKGziF1xrlU54&amp;index=1">x86-64 Assembly on youtube, from Mike Shah</a></p>
<p>It refers to the <a href="https://filippo.io/linux-syscall-table/">linux syscall table</a></p>
<p><a href="https://hackeradam.com/x86-64-linux-syscalls/">another linux syscall table</a></p>
<p>In intel format.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode numberSource asm number-lines code-with-copy"><code class="sourceCode fasm"><span id="cb3-1"><a href="#cb3-1"></a>/*first<span class="op">.</span>s<span class="op">*/</span></span>
<span id="cb3-2"><a href="#cb3-2"></a>.intel_syntax noprefix</span>
<span id="cb3-3"><a href="#cb3-3"></a>.global _start </span>
<span id="cb3-4"><a href="#cb3-4"></a><span class="fu">.hello.str:</span> </span>
<span id="cb3-5"><a href="#cb3-5"></a>    .ascii <span class="st">"12345678\n"</span> </span>
<span id="cb3-6"><a href="#cb3-6"></a><span class="fu">str_len:</span> <span class="pp">equ</span> <span class="op">$-.</span>hello<span class="op">.</span>str <span class="co">;didn't test if it works in GNU AS </span></span>
<span id="cb3-7"><a href="#cb3-7"></a></span>
<span id="cb3-8"><a href="#cb3-8"></a>.text </span>
<span id="cb3-9"><a href="#cb3-9"></a></span>
<span id="cb3-10"><a href="#cb3-10"></a><span class="fu">_start:</span> </span>
<span id="cb3-11"><a href="#cb3-11"></a>    <span class="bu">push</span> <span class="kw">rbp</span></span>
<span id="cb3-12"><a href="#cb3-12"></a>    <span class="bu">movq</span> <span class="kw">rbp</span><span class="op">,</span> <span class="kw">rsp</span> </span>
<span id="cb3-13"><a href="#cb3-13"></a>    </span>
<span id="cb3-14"><a href="#cb3-14"></a>    <span class="bu">movq</span> <span class="kw">rax</span><span class="op">,</span> <span class="dv">1</span>  </span>
<span id="cb3-15"><a href="#cb3-15"></a>    <span class="bu">movq</span> <span class="kw">rdi</span><span class="op">,</span> <span class="dv">1</span>  </span>
<span id="cb3-16"><a href="#cb3-16"></a>    leaq <span class="kw">rsi</span><span class="op">,</span> <span class="op">.</span>hello<span class="op">.</span>str  </span>
<span id="cb3-17"><a href="#cb3-17"></a>    <span class="bu">movq</span> <span class="kw">rdx</span><span class="op">,</span> str_len <span class="co">;didn't test if it works in GNU AS </span></span>
<span id="cb3-18"><a href="#cb3-18"></a>    <span class="cf">syscall</span> </span>
<span id="cb3-19"><a href="#cb3-19"></a>    </span>
<span id="cb3-20"><a href="#cb3-20"></a>    <span class="bu">movq</span> <span class="kw">rax</span><span class="op">,</span> <span class="dv">60</span>  </span>
<span id="cb3-21"><a href="#cb3-21"></a>    <span class="bu">movq</span> <span class="kw">rdi</span><span class="op">,</span> <span class="dv">0</span>  </span>
<span id="cb3-22"><a href="#cb3-22"></a>    <span class="cf">syscall</span> </span>
<span id="cb3-23"><a href="#cb3-23"></a>    </span>
<span id="cb3-24"><a href="#cb3-24"></a>    <span class="bu">pop</span> <span class="kw">rbp</span> </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>To build it.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode numberSource bash number-lines code-with-copy"><code class="sourceCode bash"><span id="cb4-1"><a href="#cb4-1"></a><span class="fu">as</span> <span class="at">-o</span> first.o first.s </span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="fu">ld</span> <span class="at">-o</span> first first.o </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>In AT&amp;T format.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode numberSource asm number-lines code-with-copy"><code class="sourceCode fasm"><span id="cb5-1"><a href="#cb5-1"></a>/*first<span class="op">.</span>s<span class="op">*/</span></span>
<span id="cb5-2"><a href="#cb5-2"></a></span>
<span id="cb5-3"><a href="#cb5-3"></a>.global _start </span>
<span id="cb5-4"><a href="#cb5-4"></a><span class="fu">.hello.str:</span> </span>
<span id="cb5-5"><a href="#cb5-5"></a>    .ascii <span class="st">"12345678\n"</span> </span>
<span id="cb5-6"><a href="#cb5-6"></a></span>
<span id="cb5-7"><a href="#cb5-7"></a>.text </span>
<span id="cb5-8"><a href="#cb5-8"></a></span>
<span id="cb5-9"><a href="#cb5-9"></a><span class="fu">_start:</span> </span>
<span id="cb5-10"><a href="#cb5-10"></a>    <span class="bu">push</span> <span class="op">%</span><span class="kw">rbp</span> </span>
<span id="cb5-11"><a href="#cb5-11"></a>    <span class="bu">movq</span> <span class="op">%</span><span class="kw">rsp</span><span class="op">,</span> <span class="op">%</span><span class="kw">rbp</span> </span>
<span id="cb5-12"><a href="#cb5-12"></a>    <span class="bu">movq</span> <span class="op">$</span><span class="bn">1</span><span class="op">,</span> <span class="op">%</span><span class="kw">rax</span>    </span>
<span id="cb5-13"><a href="#cb5-13"></a>    <span class="bu">movq</span> <span class="op">$</span><span class="bn">1</span><span class="op">,</span> <span class="op">%</span><span class="kw">rdi</span>   </span>
<span id="cb5-14"><a href="#cb5-14"></a>    leaq <span class="op">.</span>hello<span class="op">.</span>str<span class="op">,</span> <span class="op">%</span><span class="kw">rsi</span>    </span>
<span id="cb5-15"><a href="#cb5-15"></a>    <span class="bu">movq</span> <span class="op">$</span><span class="bn">9</span><span class="op">,</span> <span class="op">%</span><span class="kw">rdx</span>  </span>
<span id="cb5-16"><a href="#cb5-16"></a>    <span class="cf">syscall</span> </span>
<span id="cb5-17"><a href="#cb5-17"></a>    </span>
<span id="cb5-18"><a href="#cb5-18"></a>    <span class="bu">movq</span> <span class="op">$</span><span class="bn">60</span><span class="op">,</span> <span class="op">%</span><span class="kw">rax</span>  </span>
<span id="cb5-19"><a href="#cb5-19"></a>    <span class="bu">movq</span> <span class="op">$</span><span class="bn">0</span><span class="op">,</span> <span class="op">%</span><span class="kw">rdi</span>   </span>
<span id="cb5-20"><a href="#cb5-20"></a>    <span class="cf">syscall</span> </span>
<span id="cb5-21"><a href="#cb5-21"></a>    </span>
<span id="cb5-22"><a href="#cb5-22"></a>    <span class="bu">pop</span> <span class="op">%</span><span class="kw">rbp</span> </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>To build it. The below 2 ways are both OK.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode numberSource bash number-lines code-with-copy"><code class="sourceCode bash"><span id="cb6-1"><a href="#cb6-1"></a><span class="fu">as</span> <span class="at">-o</span> first.o first.s </span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="fu">ld</span> <span class="at">-o</span> first first.o </span>
<span id="cb6-3"><a href="#cb6-3"></a></span>
<span id="cb6-4"><a href="#cb6-4"></a><span class="fu">gcc</span> <span class="at">-c</span> first.s <span class="at">-o</span> first.o </span>
<span id="cb6-5"><a href="#cb6-5"></a><span class="fu">ld</span> <span class="at">-o</span> first first.o </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="hello-world-program-x86-32-bit" class="level2">
<h2 class="anchored" data-anchor-id="hello-world-program-x86-32-bit">Hello world program X86 32 bit</h2>
<p>The 32 bit hello world program and the 64 bit counterpart both use syscall to write to the screen and exit the program. But the 32 bit and 64 bit have different call conventions, and the syscall table are different in 32 bit and 64 bit too.</p>
<p>Refer to <a href="https://syscalls32.paolostivanin.com/">32 bit syscall table</a>.</p>
<p>Refer to <a href="https://hackeradam.com/x86-64-linux-syscalls/">64 bit syscall table</a></p>
<p>In 32 bit, the EXIT syscall is 1, while in 64 bit it is 60.</p>
<p>In 32 bit, the WRITE syscall is 4, while in 64 bit it is 1.</p>
<p>In 32 bit, the EAX, EBX, ECX, EDX, ESI, EDI in sequence are used to specify the SYSCALL code and arguments.</p>
<p>In 64 bit, the RAX, RDI, RSI, RDX, R10, R8, R9 in sequence are used to specify the SYSCALL code and arguments. <a href="https://stackoverflow.com/questions/2535989/what-are-the-calling-conventions-for-unix-linux-system-calls-and-user-space-f">call convention</a></p>
<p>In 32 bit, the <code>syscall</code> instruction is not available. It will report illegal instruction if we use it.</p>
<p>Refer to <a href="https://stackoverflow.com/questions/12806584/what-is-better-int-0x80-or-syscall-in-32-bit-code-on-linux">stackoverflow on syscall and sysenter</a>.</p>
<ul>
<li>syscall is the default way of entering kernel mode on x86-64. This instruction is not available in 32 bit modes of operation on Intel processors.</li>
<li>sysenter is an instruction most frequently used to invoke system calls in 32 bit modes of operation. It is similar to syscall, a bit more difficult to use though, but that is the kernel’s concern. int 0x80 is a legacy way to invoke a system call and should be avoided.</li>
<li>The preferred way to invoke a system call is to use vDSO(virtual dynamic shared object), a part of memory mapped in each process address space that allows to use system calls more efficiently (for example, by not entering kernel mode in some cases at all). vDSO also takes care of more difficult, in comparison to the legacy int 0x80 way, handling of syscall or sysenter instructions.</li>
</ul>
<p>Note: In 32 bit, it uses STACK to specify arguments when calling a function. In 64 bit, it uses the 6 registers to specify the first 6 arguments, and the stack to specify the remaining arguments.</p>
<p>Note: <code>int $0x80</code> and <code>sysenter</code> does not mean the same thing in 32 bit. Refer to <a href="https://blog.packagecloud.io/the-definitive-guide-to-linux-system-calls/">the definitive guide to linux system calls</a>.</p>
<p>The below program is proved OK in my 32 bit Ubuntu.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode numberSource asm number-lines code-with-copy"><code class="sourceCode fasm"><span id="cb7-1"><a href="#cb7-1"></a>.<span class="bu">data</span></span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="fu">hello:</span> .ascii <span class="st">"hello world\n"</span></span>
<span id="cb7-3"><a href="#cb7-3"></a>.bss</span>
<span id="cb7-4"><a href="#cb7-4"></a>.text</span>
<span id="cb7-5"><a href="#cb7-5"></a></span>
<span id="cb7-6"><a href="#cb7-6"></a>.global _start</span>
<span id="cb7-7"><a href="#cb7-7"></a>    // output hello world to screen</span>
<span id="cb7-8"><a href="#cb7-8"></a><span class="fu">_start:</span></span>
<span id="cb7-9"><a href="#cb7-9"></a>    <span class="bu">push</span> <span class="op">%</span><span class="kw">ebp</span>  <span class="co">;//preserve ebp</span></span>
<span id="cb7-10"><a href="#cb7-10"></a>    movl <span class="op">%</span><span class="kw">esp</span><span class="op">,</span> <span class="op">%</span><span class="kw">ebp</span> <span class="co">;//put the current esp to ebp</span></span>
<span id="cb7-11"><a href="#cb7-11"></a>    movl <span class="op">$</span><span class="bn">1</span><span class="op">,</span> <span class="op">%</span><span class="kw">ebx</span> <span class="co">;//put STDOUT file descriptor to %ebx</span></span>
<span id="cb7-12"><a href="#cb7-12"></a>    leal hello<span class="op">,</span> <span class="op">%</span><span class="kw">ecx</span>  <span class="co">;//put address of the str to %ecx</span></span>
<span id="cb7-13"><a href="#cb7-13"></a>    movl <span class="op">$</span><span class="bn">12</span><span class="op">,</span> <span class="op">%</span><span class="kw">edx</span> <span class="co">;//put the length of the str to %edx</span></span>
<span id="cb7-14"><a href="#cb7-14"></a>    movl <span class="op">$</span><span class="bn">4</span><span class="op">,</span> <span class="op">%</span><span class="kw">eax</span>  <span class="co">;//put the WRITE syscall number to eax</span></span>
<span id="cb7-15"><a href="#cb7-15"></a>    <span class="bu">int</span> <span class="op">$</span><span class="bn">0</span>x80</span>
<span id="cb7-16"><a href="#cb7-16"></a></span>
<span id="cb7-17"><a href="#cb7-17"></a>    // exit the program</span>
<span id="cb7-18"><a href="#cb7-18"></a>    movl <span class="op">$</span><span class="bn">0</span><span class="op">,</span> <span class="op">%</span><span class="kw">ebx</span> <span class="co">;//put the exit code to ebx</span></span>
<span id="cb7-19"><a href="#cb7-19"></a>    movl <span class="op">$</span><span class="bn">1</span><span class="op">,</span> <span class="op">%</span><span class="kw">eax</span> <span class="co">;//put the EXIT syscall number to eax</span></span>
<span id="cb7-20"><a href="#cb7-20"></a>    <span class="bu">int</span> <span class="op">$</span><span class="bn">0</span>x80</span>
<span id="cb7-21"><a href="#cb7-21"></a>    <span class="bu">pop</span> <span class="op">%</span><span class="kw">ebp</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="call-instruction-to-call-a-function" class="level2">
<h2 class="anchored" data-anchor-id="call-instruction-to-call-a-function">call instruction to call a function</h2>
<div class="sourceCode" id="cb8"><pre class="sourceCode numberSource asm number-lines code-with-copy"><code class="sourceCode fasm"><span id="cb8-1"><a href="#cb8-1"></a>/*first<span class="op">.</span>s<span class="op">*/</span></span>
<span id="cb8-2"><a href="#cb8-2"></a># there is also <span class="op">.</span>bss segment for <span class="op">not</span> initialized global data </span>
<span id="cb8-3"><a href="#cb8-3"></a>.<span class="bu">data</span> </span>
<span id="cb8-4"><a href="#cb8-4"></a><span class="fu">.hello.str:</span> </span>
<span id="cb8-5"><a href="#cb8-5"></a>    .ascii <span class="st">"12345678\n"</span> </span>
<span id="cb8-6"><a href="#cb8-6"></a></span>
<span id="cb8-7"><a href="#cb8-7"></a>.text </span>
<span id="cb8-8"><a href="#cb8-8"></a></span>
<span id="cb8-9"><a href="#cb8-9"></a><span class="fu">_write_str:</span> </span>
<span id="cb8-10"><a href="#cb8-10"></a>    <span class="bu">movq</span> <span class="op">%</span><span class="kw">rsp</span><span class="op">,</span> <span class="op">%</span><span class="kw">rbp</span> </span>
<span id="cb8-11"><a href="#cb8-11"></a>    <span class="bu">movq</span> <span class="op">$</span><span class="bn">1</span><span class="op">,</span> <span class="op">%</span><span class="kw">rax</span>    </span>
<span id="cb8-12"><a href="#cb8-12"></a>    <span class="bu">movq</span> <span class="op">$</span><span class="bn">1</span><span class="op">,</span> <span class="op">%</span><span class="kw">rdi</span>   </span>
<span id="cb8-13"><a href="#cb8-13"></a>    leaq <span class="op">.</span>hello<span class="op">.</span>str<span class="op">,</span> <span class="op">%</span><span class="kw">rsi</span>    </span>
<span id="cb8-14"><a href="#cb8-14"></a>    <span class="bu">movq</span> <span class="op">$</span><span class="bn">9</span><span class="op">,</span> <span class="op">%</span><span class="kw">rdx</span>  </span>
<span id="cb8-15"><a href="#cb8-15"></a>    <span class="cf">syscall</span> </span>
<span id="cb8-16"><a href="#cb8-16"></a>    <span class="cf">ret</span> </span>
<span id="cb8-17"><a href="#cb8-17"></a><span class="fu">_exit:</span></span>
<span id="cb8-18"><a href="#cb8-18"></a>    <span class="bu">movq</span> <span class="op">$</span><span class="bn">60</span><span class="op">,</span> <span class="op">%</span><span class="kw">rax</span>  </span>
<span id="cb8-19"><a href="#cb8-19"></a>    <span class="bu">movq</span> <span class="op">$</span><span class="bn">0</span><span class="op">,</span> <span class="op">%</span><span class="kw">rdi</span>   </span>
<span id="cb8-20"><a href="#cb8-20"></a>    <span class="cf">syscall</span> </span>
<span id="cb8-21"><a href="#cb8-21"></a>    <span class="cf">ret</span> </span>
<span id="cb8-22"><a href="#cb8-22"></a></span>
<span id="cb8-23"><a href="#cb8-23"></a>.global _start </span>
<span id="cb8-24"><a href="#cb8-24"></a><span class="fu">_start:</span> </span>
<span id="cb8-25"><a href="#cb8-25"></a>    <span class="cf">call</span> _write_str </span>
<span id="cb8-26"><a href="#cb8-26"></a>    <span class="cf">call</span> _exit </span>
<span id="cb8-27"><a href="#cb8-27"></a>    <span class="bu">pop</span> <span class="op">%</span><span class="kw">rbp</span> </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="the-64-bit-x86-c-calling-convention" class="level2">
<h2 class="anchored" data-anchor-id="the-64-bit-x86-c-calling-convention">The 64 bit x86 C Calling Convention</h2>
<p>The section is copied from <a href="https://aaronbloomfield.github.io/pdr/book/x86-64bit-ccc-chapter.pdf">x86-64 call convention</a>. It is for Linux. Microsoft windows does not follow the same convention. Refer to <a href="https://learn.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-170">x64 calling convention, Microsoft</a>.</p>
<p>pop, push, call, ret instructions.</p>
<p>The caller’s rules:</p>
<ol type="1">
<li><p>Before calling a subroutine, the caller should save the contents of certain registers that are designated caller-saved. The caller-saved registers are r10, r11, and any registers that parameters are put into. If you want the contents of these registers to be preserved across the subroutine call, push them onto the stack.</p></li>
<li><p>To pass parameters to the subroutine, we put up to six of them into registers (in order: rdi, rsi, rdx, rcx, r8, r9). If there are more than six parameters to the subroutine, then push the rest onto the stack in reverse order (i.e.&nbsp;last parameter first) – since the stack grows down, the first of the extra parameters (really the seventh parameter) parameter will be stored at the lowest address (this inversion of parameters was historically used to allow functions to be passed a variable number of parameters).</p></li>
<li><p>To call the subroutine, use the <code>call</code> instruction. This instruction places the return address on top of the parameters on the stack, and branches to the subroutine code.</p></li>
<li><p>After the subroutine returns, (i.e.&nbsp;immediately following the call instruction) the caller must remove any additional parameters (beyond the six stored in registers) from stack. This restores the stack to its state before the call was performed.</p></li>
<li><p>The caller can expect to find the return value of the subroutine in the register RAX.</p></li>
<li><p>The caller restores the contents of caller-saved registers (r10, r11, and any in the parameter passing registers) by popping them off of the stack. The caller can assume that no other registers were modified by the subroutine.</p></li>
</ol>
<p>The Callee’s Rules:</p>
<ol type="1">
<li><p>Allocate local variables by using registers or making space on the stack. Recall, the stack grows down, so to make space on the top of the stack, the stack pointer should be decremented. The amount by which the stack pointer is decremented depends on the number of local variables needed. For example, if a local float and a local long (12 bytes total) were required, the stack pointer would need to be decremented by 12 to make space for these local variables: <code>sub rsp, 12</code>. As with parameters, local variables will be located at known offsets from the stack pointer.</p></li>
<li><p>Next, the values of any registers that are designated callee-saved that will be used by the function must be saved. To save registers, push them onto the stack. The callee-saved registers are RBX, RBP, and R12 through R15 (RSP will also be preserved by the call convention, but need not be pushed on the stack during this step). After these three actions are performed, the actual operation of the subroutine may proceed. When the subroutine is ready to return, the call convention rules continue.</p></li>
<li><p>When the function is done, the return value for the function should be placed in RAX if it is not already there.</p></li>
<li><p>The function must restore the old values of any callee-saved registers (RBX, RBP, and R12 through R15) that were modified. The register contents are restored by popping them from the stack. Note, the registers should be popped in the inverse order that they were pushed.</p></li>
<li><p>Next, we deallocate local variables. The easiest way to do this is to add to RSP the same amount that was subtracted from it in step 1.</p></li>
<li><p>Finally, we return to the caller by executing a ret instruction. This instruction will find and remove the appropriate return address from the stack.</p></li>
</ol>
<p>If you look at the assembly generated by some compilers, you will see a few extra commands in there in the callee’s prologue:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode numberSource asm number-lines code-with-copy"><code class="sourceCode fasm"><span id="cb9-1"><a href="#cb9-1"></a><span class="bu">push</span> <span class="kw">rbp</span> <span class="co">; at the start of the callee </span></span>
<span id="cb9-2"><a href="#cb9-2"></a><span class="bu">mov</span> <span class="kw">rbp</span><span class="op">,</span> <span class="kw">rsp</span></span>
<span id="cb9-3"><a href="#cb9-3"></a>... </span>
<span id="cb9-4"><a href="#cb9-4"></a><span class="bu">pop</span> <span class="kw">rbp</span> <span class="co">; just before the ending `ret` </span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This code is unnecessary, and is a hold-over from the 32-bit calling convention. You can tell the compiler to not include this code by invoking it with the <code>-fomit-frame-pointer</code> flag.</p>
<p>It might be noted that the callee’s rules fall cleanly into two halves that are basically mirror images of one another. The first half of the rules apply to the beginning of the function, and are therefor commonly said to define the prologue to the function. The latter half of the rules apply to the end of the function, and are thus commonly said to define the epilogue of the function.</p>
</section>
<section id="the-32-bit-x86-c-calling-convention" class="level2">
<h2 class="anchored" data-anchor-id="the-32-bit-x86-c-calling-convention">The 32 bit x86 C calling Convention</h2>
<p>The section is copied from <a href="https://aaronbloomfield.github.io/pdr/book/x86-32bit-ccc-chapter.pdf">x86 32 bit call convention</a>.</p>
<p>The Caller’s Rules</p>
<ol type="1">
<li><p>Bfore calling a subroutine, the caller should save the contents of certain registers that are designated caller-saved. The caller-saved registers are EAX, ECX, EDX. If you want the contents of these registers to be preserved across the subroutine call, push them onto the stack</p></li>
<li><p>To pass parameters to the subroutine, push them onto the stack before the call. The parameters should be pushed in inverted order (i.e.&nbsp;last parameter first) – since the stack grows down, the first parameter will be stored at the lowest address (this inversion of parameters was historically used to allow functions to be passed a variable number of parameters).</p></li>
<li><p>To call the subroutine, use the call instruction. This instruction places the return address on top of the parameters on the stack, and branches to the subroutine code.</p></li>
<li><p>After the subroutine returns, (i.e.&nbsp;immediately following the call instruction) the caller must remove the parameters from stack. This restores the stack to its state before the call was performed.</p></li>
<li><p>The caller can expect to find the return value of the subroutine in the register EAX.</p></li>
<li><p>The caller restores the contents of caller-saved registers (EAX, ECX, EDX) by popping them off of the stack. The caller can assume that no other registers were modified by the subroutine.</p></li>
</ol>
<p>The Callee’s Rules</p>
<ol type="1">
<li>At the beginning of the subroutine, the function should push the value of EBP onto the stack, and then copy the value of ESP into EBP using the following instructions:</li>
</ol>
<div class="sourceCode" id="cb10"><pre class="sourceCode numberSource asm number-lines code-with-copy"><code class="sourceCode fasm"><span id="cb10-1"><a href="#cb10-1"></a><span class="bu">push</span> <span class="kw">ebp</span> </span>
<span id="cb10-2"><a href="#cb10-2"></a><span class="bu">mov</span> <span class="kw">ebp</span><span class="op">,</span> <span class="kw">esp</span> <span class="co">;Intel style instead of AT&amp;T style </span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The reason for this initial action is the maintenance of the base pointer, EBP. The base pointer is used by convention as a point of reference for finding parameters and local variables on the stack. Essentially, when any subroutine is executing, the base pointer is a “snapshot” of the stack pointer value from when the subroutine started executing. Parameters and local variables will always be located at known, constant offsets away from the base pointer value. We push the old base pointer value at the beginning of the subroutine so that we can later restore the appropriate base pointer value for the caller when the subroutine returns. Remember, the caller isn’t expecting the subroutine to change the value of the base pointer. We then move the stack pointer into EBP to obtain our point of reference for accessing parameters and local variables.</p>
<ol start="2" type="1">
<li>Next, allocate local variables by making space on the stack. Recall, the stack grows down, so to make space on the top of the stack, the stack pointer should be decremented. The amount by which the stack pointer is decremented depends on the number of local variables needed. For example, if 3 local integers (4 bytes each) were required, the stack pointer would need to be decremented by 12 to make space for these local variables. I.e.:</li>
</ol>
<div class="sourceCode" id="cb11"><pre class="sourceCode numberSource asm number-lines code-with-copy"><code class="sourceCode fasm"><span id="cb11-1"><a href="#cb11-1"></a><span class="bu">sub</span> <span class="kw">esp</span><span class="op">,</span> <span class="dv">12</span> </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>As with parameters, local variables will be located at known offsets from the base pointer.</p>
<ol start="3" type="1">
<li><p>Next, the values of any registers that are designated callee-saved that will be used by the function must be saved. To save registers, push them onto the stack. The callee-saved registers are EBX, EDI and ESI (ESP and EBP will also be preserved by the call convention, but need not be pushed on the stack during this step). After these three actions are performed, the actual operation of the subroutine may proceed. When the subroutine is ready to return, the call convention rules continue:</p></li>
<li><p>When the function is done, the return value for the function should be placed in EAX if it is not already there.</p></li>
<li><p>The function must restore the old values of any callee-saved registers (EBX, EDI and ESI) that were modified. The register contents are restored by popping them from the stack. Note, the registers should be popped in the inverse order that they were pushed.</p></li>
<li><p>Next, we deallocate local variables. The obvious way to do this might be to add the appropriate value to the stack pointer (since the space was allocated by subtracting the needed amount from the stack pointer). In practice, a less error-prone way to deallocate the variables is to move the value in the base pointer into the stack pointer, i.e.:</p></li>
</ol>
<div class="sourceCode" id="cb12"><pre class="sourceCode numberSource asm number-lines code-with-copy"><code class="sourceCode fasm"><span id="cb12-1"><a href="#cb12-1"></a><span class="bu">mov</span> <span class="kw">esp</span><span class="op">,</span> <span class="kw">ebp</span> </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This trick works because the base pointer always contains the value that the stack pointer contained immediately prior to the allocation of the local variables.</p>
<ol start="7" type="1">
<li><p>Immediately before returning, we must restore the caller’s base pointer value by popping EBP off the stack. Remember, the first thing we did on entry to the subroutine was to push the base pointer to save its old value.</p></li>
<li><p>Finally, we return to the caller by executing a ret instruction. This instruction will find and remove the appropriate return address from the stack.</p></li>
</ol>
</section>
<section id="general-purpose-registers-in-x86-64" class="level2">
<h2 class="anchored" data-anchor-id="general-purpose-registers-in-x86-64">General purpose registers in X86-64</h2>
<div class="sourceCode" id="cb13"><pre class="sourceCode numberSource default number-lines code-with-copy"><code class="sourceCode default"><span id="cb13-1"><a href="#cb13-1"></a>rax eax ax al</span>
<span id="cb13-2"><a href="#cb13-2"></a>rbx ebx bx bl</span>
<span id="cb13-3"><a href="#cb13-3"></a>rcx ecx cx cl</span>
<span id="cb13-4"><a href="#cb13-4"></a>rdx edx dx dl</span>
<span id="cb13-5"><a href="#cb13-5"></a>rsi esi si sil</span>
<span id="cb13-6"><a href="#cb13-6"></a>rdi edi di dil</span>
<span id="cb13-7"><a href="#cb13-7"></a>rbp ebp bp bpl</span>
<span id="cb13-8"><a href="#cb13-8"></a>rsp esp sp spl</span>
<span id="cb13-9"><a href="#cb13-9"></a>r8 r8d r8w r8b</span>
<span id="cb13-10"><a href="#cb13-10"></a>r9 r9d r9w r9b</span>
<span id="cb13-11"><a href="#cb13-11"></a>r10 r10d r10w r10b</span>
<span id="cb13-12"><a href="#cb13-12"></a>r11 r11d r11w r11b</span>
<span id="cb13-13"><a href="#cb13-13"></a>r12 r12d r12w r12b</span>
<span id="cb13-14"><a href="#cb13-14"></a>r13 r13d r13w r13b</span>
<span id="cb13-15"><a href="#cb13-15"></a>r14 r14d r14w r14b</span>
<span id="cb13-16"><a href="#cb13-16"></a>r15 r15d r15w r15b</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="att-syntax" class="level2">
<h2 class="anchored" data-anchor-id="att-syntax">AT&amp;T Syntax</h2>
<p>Refer to <a href="https://stackoverflow.com/questions/9223756/what-does-an-asterisk-before-an-address-mean-in-x86-64-att-assembly">AT&amp;T assembly syntax</a></p>
<p>It’s AT&amp;T assembly syntax:</p>
<ul>
<li>source comes before destination</li>
<li>mnemonic suffixes indicate the size of the operands (q for quad, etc.)</li>
<li>registers are prefixed with % and immediate values with $</li>
<li>effective addresses are in the form DISP(BASE, INDEX SCALE) (DISP + BASE + INDEX * SCALE)</li>
<li>Indirect jump/call operands indicated with * (as opposed to direct).</li>
</ul>
</section>
<section id="add-sub-inc-dec" class="level2">
<h2 class="anchored" data-anchor-id="add-sub-inc-dec">add, sub, inc, dec</h2>
<p><code>inc</code> and <code>add 1</code> are different.</p>
<p><code>dec</code> and <code>sub 1</code> are different.</p>
<p><code>inc</code> and <code>dec</code> won’t affect the carry flag, while <code>add</code> and <code>sub</code> will.</p>
<p>Refer to <a href="http://www.c-jump.com/CIS77/ASM/Flags/lecture.html#F77_0070_inc_dec">inc, dec instructions</a></p>
</section>
<section id="a-comparison-of-gas-and-nasm" class="level2">
<h2 class="anchored" data-anchor-id="a-comparison-of-gas-and-nasm">A comparison of GAS and NASM</h2>
<p>Refer to <a href="http://web.archive.org/web/20090215122116/http://www.ibm.com/developerworks/library/l-gas-nasm.html">Linux assemblers: A comparison of GAS and NASM</a></p>
</section>
</section>
<section id="book-programming-from-the-ground-up-by-jonathan-bartlett-author" class="level1">
<h1>Book Programming from the Ground Up by Jonathan Bartlett (Author)</h1>
<p>Programming from the Ground Up uses Linux assembly language to teach new programmers the most important concepts in programming.</p>
</section>
<section id="book-professional-assembly-language-by-richard-blum-good" class="level1">
<h1>Book Professional Assembly Language by Richard Blum (Good)</h1>
<p>It is said that it uses the AT&amp;T syntax. And uses the GNU AS assembler. But seems it is for 32 bit X86. After knowing the differences of call conventions between x86-64 and x86-32, it does not matter. Refer to <a href="https://askubuntu.com/questions/344976/can-i-install-32-bit-ubuntu-in-a-64-bit-host-using-virtualbox">install a 32-bit ubuntu in a 64-bit host via virtual box</a></p>
<p>Use vagrant to install a 32 bit of ubuntu in virtul box.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode numberSource default number-lines code-with-copy"><code class="sourceCode default"><span id="cb14-1"><a href="#cb14-1"></a>//put the Vagrantfile in a folder and 'run vagrant up'. </span>
<span id="cb14-2"><a href="#cb14-2"></a>//run 'vagrant ssh' to login to the VM. It is a terminal interface without GUI. </span>
<span id="cb14-3"><a href="#cb14-3"></a>//default user and passwd is vagrant/vagrant. </span>
<span id="cb14-4"><a href="#cb14-4"></a>//A folder /vagrant is mounted to refer to the folder in the host machine where the Vagrantfile locates. </span>
<span id="cb14-5"><a href="#cb14-5"></a>// run `sudo apt install gdb` to install gdb for debugging   </span>
<span id="cb14-6"><a href="#cb14-6"></a>Vagrant.configure("2") do |config|</span>
<span id="cb14-7"><a href="#cb14-7"></a>  config.vm.box = "reelio/trusty32"</span>
<span id="cb14-8"><a href="#cb14-8"></a>  config.vm.box_version = "0.0.1"</span>
<span id="cb14-9"><a href="#cb14-9"></a>end</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<section id="chap5-moving-data" class="level2">
<h2 class="anchored" data-anchor-id="chap5-moving-data">Chap5 Moving data</h2>
<p>The data section is declared using the .data directive.</p>
<p>There is another type of data section called .rodata. Any data elements defined in this section can only be accessed in readonly mode(thus the ro prefix).</p>
<p>Two statements are required to define a data element in the data section: a label and a directive. The label has no meaning to the processor; it is just a place for the assembler to reserve a specified amount of memory for the data element to be referenced by the label.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode numberSource default number-lines code-with-copy"><code class="sourceCode default"><span id="cb15-1"><a href="#cb15-1"></a>directive, data type </span>
<span id="cb15-2"><a href="#cb15-2"></a></span>
<span id="cb15-3"><a href="#cb15-3"></a>.ascii, Text string </span>
<span id="cb15-4"><a href="#cb15-4"></a>.asciz, Null terminated text string </span>
<span id="cb15-5"><a href="#cb15-5"></a>.byte, Byte value </span>
<span id="cb15-6"><a href="#cb15-6"></a>.double, Double precision floating-point number </span>
<span id="cb15-7"><a href="#cb15-7"></a>.float, Single precision floating-point nuber </span>
<span id="cb15-8"><a href="#cb15-8"></a>.int, 32-bit integer number </span>
<span id="cb15-9"><a href="#cb15-9"></a>.long, 32-bit integer number </span>
<span id="cb15-10"><a href="#cb15-10"></a>.octa, 16-byte integer number </span>
<span id="cb15-11"><a href="#cb15-11"></a>.quad, 8-byte integer number </span>
<span id="cb15-12"><a href="#cb15-12"></a>.short, 16-bit integer number </span>
<span id="cb15-13"><a href="#cb15-13"></a>.single, single-precision floating pointer number(same as .float)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>You are not limited to defining just one value on the directive statement line. You can define multiple values on the line, with each value being placed in memory in the order it appears in the directive.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode numberSource asm number-lines code-with-copy"><code class="sourceCode fasm"><span id="cb16-1"><a href="#cb16-1"></a><span class="fu">sizes:</span> .long <span class="dv">100</span><span class="op">,</span><span class="dv">150</span><span class="op">,</span><span class="dv">200</span><span class="op">,</span><span class="dv">250</span><span class="op">,</span><span class="dv">300</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>You can also declare static data symbols in the data section. The .equ directive is used to set a constant value to a symbol that can be used in the text section, as shown in the following examples:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode numberSource asm number-lines code-with-copy"><code class="sourceCode fasm"><span id="cb17-1"><a href="#cb17-1"></a>.<span class="pp">equ</span> factor<span class="op">,</span> <span class="dv">3</span> </span>
<span id="cb17-2"><a href="#cb17-2"></a>.<span class="pp">equ</span> LINUX_SYS_CALL<span class="op">,</span> <span class="bn">0X60</span> </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>To reference the static data element, you must use a dollar sign before the label name.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode numberSource asm number-lines code-with-copy"><code class="sourceCode fasm"><span id="cb18-1"><a href="#cb18-1"></a>movl <span class="op">$</span>LINUX_SYS_CALL<span class="op">,</span> <span class="op">%</span><span class="kw">eax</span> </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>In BSS section, defining data elements is somewhat different from defining them in the data section. Instead of declaring specific data types, you just declare raw segments of memory that are reserved for whatever purpose you need them for.</p>
<p>The GNU assembler uses two directives to declare buffers, as shown in the following table.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode numberSource default number-lines code-with-copy"><code class="sourceCode default"><span id="cb19-1"><a href="#cb19-1"></a>.comm, Declares a common memory area for data that is not initialized </span>
<span id="cb19-2"><a href="#cb19-2"></a>.lcomm, Declares a local common memory area for data that is not initialized </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The local common memory area is reserved for data that will not be accessed outside of the local assembly code.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode numberSource asm number-lines code-with-copy"><code class="sourceCode fasm"><span id="cb20-1"><a href="#cb20-1"></a>.comm symbol<span class="op">,</span> length </span>
<span id="cb20-2"><a href="#cb20-2"></a>.lcomm buffer<span class="op">,</span> <span class="dv">10000</span> </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Local common memory areas cannot be accessed by functions outside of where they were declared(They can’t be used in .globl directives).</p>
<p>One benefit to declaring data in the bss section is that the data is not included in the executable program.</p>
<p>The .fill directive enables the assembler to automatically create the 10000 elements for you. The default is to create one byte per field, and fill it with zeros.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode numberSource asm number-lines code-with-copy"><code class="sourceCode fasm"><span id="cb21-1"><a href="#cb21-1"></a>.<span class="bu">section</span> <span class="op">.</span>data </span>
<span id="cb21-2"><a href="#cb21-2"></a><span class="fu">buffer:</span> </span>
<span id="cb21-3"><a href="#cb21-3"></a>    .fill <span class="dv">10000</span> </span>
<span id="cb21-4"><a href="#cb21-4"></a>.<span class="bu">section</span> <span class="op">.</span>text </span>
<span id="cb21-5"><a href="#cb21-5"></a>.globl _start </span>
<span id="cb21-6"><a href="#cb21-6"></a><span class="fu">_start:</span> </span>
<span id="cb21-7"><a href="#cb21-7"></a>    movl <span class="op">$</span><span class="bn">1</span><span class="op">,</span> <span class="op">%</span><span class="kw">eax</span> </span>
<span id="cb21-8"><a href="#cb21-8"></a>    movl <span class="op">$</span><span class="bn">0</span><span class="op">,</span> <span class="op">$</span>ebx </span>
<span id="cb21-9"><a href="#cb21-9"></a>    <span class="bu">int</span> <span class="op">$</span><span class="bn">0</span>x80 </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The GNU assembler adds another dimension to the MOV instruction, in that the size of the data element moved must be declared. The size is declared by adding an additional character to the MOV mnemonic. Thus the instruction becomes movx, where x can be l for a 32-bit long word value, w for a 16-bit word value, b for an 8-bit byte value, q for an 8-byte value.</p>
<section id="moving-data-values-from-memory-to-a-register" class="level3">
<h3 class="anchored" data-anchor-id="moving-data-values-from-memory-to-a-register">moving data values from memory to a register</h3>
<p>By my test in both 32 bit and 64 bit OS, <code>.int</code> and <code>.long</code> both have size 4 bytes.</p>
<p>By my test in both 32 bit and 64 bit OS(take 64 bits as an example), <code>movq (value), %rcx</code> and <code>movq value, %rcx</code> mean the same thing. After executation of the below 2 programs, the value of %rcx is 3, instead of the address of <code>value</code> in the .data section.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode numberSource asm number-lines code-with-copy"><code class="sourceCode fasm"><span id="cb22-1"><a href="#cb22-1"></a># movtest1<span class="op">.</span>s </span>
<span id="cb22-2"><a href="#cb22-2"></a>.<span class="bu">section</span> <span class="op">.</span>data<span class="op">,</span> first way </span>
<span id="cb22-3"><a href="#cb22-3"></a># define value with <span class="dv">8</span> bytes <span class="op">and</span> value <span class="dv">3</span> </span>
<span id="cb22-4"><a href="#cb22-4"></a><span class="fu">value:</span> .quad <span class="dv">3</span>  </span>
<span id="cb22-5"><a href="#cb22-5"></a></span>
<span id="cb22-6"><a href="#cb22-6"></a>.<span class="bu">section</span> <span class="op">.</span>text </span>
<span id="cb22-7"><a href="#cb22-7"></a>.globl _start </span>
<span id="cb22-8"><a href="#cb22-8"></a><span class="fu">_start:</span> </span>
<span id="cb22-9"><a href="#cb22-9"></a>    <span class="bu">nop</span> </span>
<span id="cb22-10"><a href="#cb22-10"></a>    <span class="bu">movq</span> value<span class="op">,%</span><span class="kw">rcx</span> </span>
<span id="cb22-11"><a href="#cb22-11"></a>    <span class="bu">movq</span> <span class="op">$</span><span class="bn">60</span><span class="op">,</span> <span class="op">%</span><span class="kw">rax</span> </span>
<span id="cb22-12"><a href="#cb22-12"></a>    <span class="bu">movq</span> <span class="op">$</span><span class="bn">42</span><span class="op">,</span> <span class="op">%</span><span class="kw">rdi</span> </span>
<span id="cb22-13"><a href="#cb22-13"></a>    <span class="cf">syscall</span> </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb23"><pre class="sourceCode numberSource asm number-lines code-with-copy"><code class="sourceCode fasm"><span id="cb23-1"><a href="#cb23-1"></a># movtest1<span class="op">.</span>s </span>
<span id="cb23-2"><a href="#cb23-2"></a>.<span class="bu">section</span> <span class="op">.</span>data<span class="op">,</span> <span class="dv">2</span><span class="er">nd</span> way </span>
<span id="cb23-3"><a href="#cb23-3"></a># define value with <span class="dv">8</span> bytes <span class="op">and</span> value <span class="dv">3</span> </span>
<span id="cb23-4"><a href="#cb23-4"></a><span class="fu">value:</span> .quad <span class="dv">3</span>  </span>
<span id="cb23-5"><a href="#cb23-5"></a></span>
<span id="cb23-6"><a href="#cb23-6"></a>.<span class="bu">section</span> <span class="op">.</span>text </span>
<span id="cb23-7"><a href="#cb23-7"></a>.globl _start </span>
<span id="cb23-8"><a href="#cb23-8"></a><span class="fu">_start:</span> </span>
<span id="cb23-9"><a href="#cb23-9"></a>    <span class="bu">nop</span> </span>
<span id="cb23-10"><a href="#cb23-10"></a>    <span class="bu">movq</span> value<span class="op">,%</span><span class="kw">rcx</span> </span>
<span id="cb23-11"><a href="#cb23-11"></a>    <span class="bu">movq</span> <span class="op">$</span><span class="bn">60</span><span class="op">,</span> <span class="op">%</span><span class="kw">rax</span> </span>
<span id="cb23-12"><a href="#cb23-12"></a>    <span class="bu">movq</span> <span class="op">$</span><span class="bn">42</span><span class="op">,</span> <span class="op">%</span><span class="kw">rdi</span> </span>
<span id="cb23-13"><a href="#cb23-13"></a>    <span class="cf">syscall</span> </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Followed the steps to build and debug the program.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode numberSource bash number-lines code-with-copy"><code class="sourceCode bash"><span id="cb24-1"><a href="#cb24-1"></a><span class="ex">[root@centos8</span> asm]# as <span class="at">-gstabs</span> <span class="at">-o</span> movtest1.o movtest1.s </span>
<span id="cb24-2"><a href="#cb24-2"></a><span class="ex">[root@centos8</span> asm]# ld <span class="at">-o</span> movtest1 movtest1.o </span>
<span id="cb24-3"><a href="#cb24-3"></a><span class="ex">[root@centos8</span> asm]# gdb ./movtest1 </span>
<span id="cb24-4"><a href="#cb24-4"></a><span class="kw">(</span><span class="fu">gdb</span><span class="kw">)</span> <span class="ex">b</span> <span class="pp">*</span>_start </span>
<span id="cb24-5"><a href="#cb24-5"></a><span class="ex">Breakpoint</span> 1 at 0x4000b0: file movtest1.s, line 8.</span>
<span id="cb24-6"><a href="#cb24-6"></a><span class="kw">(</span><span class="fu">gdb</span><span class="kw">)</span> <span class="ex">r</span></span>
<span id="cb24-7"><a href="#cb24-7"></a><span class="ex">Starting</span> program: /root/tmp/asm/movtest1 </span>
<span id="cb24-8"><a href="#cb24-8"></a></span>
<span id="cb24-9"><a href="#cb24-9"></a><span class="ex">Breakpoint</span> 1, _start <span class="er">(</span><span class="kw">)</span> <span class="ex">at</span> movtest1.s:8</span>
<span id="cb24-10"><a href="#cb24-10"></a><span class="ex">8</span>       nop </span>
<span id="cb24-11"><a href="#cb24-11"></a><span class="kw">(</span><span class="fu">gdb</span><span class="kw">)</span> <span class="ex">n</span></span>
<span id="cb24-12"><a href="#cb24-12"></a><span class="ex">9</span>       movq <span class="er">(</span><span class="ex">value</span><span class="kw">)</span><span class="ex">,%rcx</span> </span>
<span id="cb24-13"><a href="#cb24-13"></a><span class="kw">(</span><span class="fu">gdb</span><span class="kw">)</span> <span class="ex">print/x</span> <span class="va">$rcx</span> </span>
<span id="cb24-14"><a href="#cb24-14"></a><span class="va">$1</span> = 0x0</span>
<span id="cb24-15"><a href="#cb24-15"></a><span class="kw">(</span><span class="fu">gdb</span><span class="kw">)</span> <span class="ex">n</span></span>
<span id="cb24-16"><a href="#cb24-16"></a><span class="ex">10</span>      movq <span class="va">$6</span>0, %rax </span>
<span id="cb24-17"><a href="#cb24-17"></a><span class="kw">(</span><span class="fu">gdb</span><span class="kw">)</span> <span class="ex">print/x</span> <span class="va">$rcx</span> </span>
<span id="cb24-18"><a href="#cb24-18"></a><span class="va">$2</span> = 0x3</span>
<span id="cb24-19"><a href="#cb24-19"></a><span class="kw">(</span><span class="fu">gdb</span><span class="kw">)</span> </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>But if we put the <code>$</code> prefix in mov instruction before <code>value</code>, it will mov the address instead of value as shown in the below program.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode numberSource asm number-lines code-with-copy"><code class="sourceCode fasm"><span id="cb25-1"><a href="#cb25-1"></a># movtest1<span class="op">,</span> it will move the address instead of the value </span>
<span id="cb25-2"><a href="#cb25-2"></a>.<span class="bu">section</span> <span class="op">.</span>data </span>
<span id="cb25-3"><a href="#cb25-3"></a># define value with <span class="dv">8</span> bytes <span class="op">and</span> value <span class="dv">3</span> </span>
<span id="cb25-4"><a href="#cb25-4"></a><span class="fu">value:</span> .quad <span class="dv">3</span>  </span>
<span id="cb25-5"><a href="#cb25-5"></a></span>
<span id="cb25-6"><a href="#cb25-6"></a>.<span class="bu">section</span> <span class="op">.</span>text </span>
<span id="cb25-7"><a href="#cb25-7"></a>.globl _start </span>
<span id="cb25-8"><a href="#cb25-8"></a><span class="fu">_start:</span> </span>
<span id="cb25-9"><a href="#cb25-9"></a>    <span class="bu">nop</span> </span>
<span id="cb25-10"><a href="#cb25-10"></a>    <span class="bu">movq</span> <span class="op">$</span>value<span class="op">,%</span><span class="kw">rcx</span> </span>
<span id="cb25-11"><a href="#cb25-11"></a>    <span class="bu">movq</span> <span class="op">$</span><span class="bn">60</span><span class="op">,</span> <span class="op">%</span><span class="kw">rax</span> </span>
<span id="cb25-12"><a href="#cb25-12"></a>    <span class="bu">movq</span> <span class="op">$</span><span class="bn">42</span><span class="op">,</span> <span class="op">%</span><span class="kw">rdi</span> </span>
<span id="cb25-13"><a href="#cb25-13"></a>    <span class="cf">syscall</span> </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Followed the debug steps to demonstrate.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode numberSource bash number-lines code-with-copy"><code class="sourceCode bash"><span id="cb26-1"><a href="#cb26-1"></a><span class="fu">gdb</span> ./movtest1 </span>
<span id="cb26-2"><a href="#cb26-2"></a></span>
<span id="cb26-3"><a href="#cb26-3"></a><span class="kw">(</span><span class="fu">gdb</span><span class="kw">)</span> <span class="ex">b</span> <span class="pp">*</span>_start </span>
<span id="cb26-4"><a href="#cb26-4"></a><span class="ex">Breakpoint</span> 1 at 0x4000b0: file movtest1.s, line 8.</span>
<span id="cb26-5"><a href="#cb26-5"></a><span class="kw">(</span><span class="fu">gdb</span><span class="kw">)</span> <span class="ex">r</span></span>
<span id="cb26-6"><a href="#cb26-6"></a><span class="ex">Starting</span> program: /root/tmp/asm/movtest1 </span>
<span id="cb26-7"><a href="#cb26-7"></a></span>
<span id="cb26-8"><a href="#cb26-8"></a><span class="ex">Breakpoint</span> 1, _start <span class="er">(</span><span class="kw">)</span> <span class="ex">at</span> movtest1.s:8</span>
<span id="cb26-9"><a href="#cb26-9"></a><span class="ex">8</span>       nop </span>
<span id="cb26-10"><a href="#cb26-10"></a><span class="kw">(</span><span class="fu">gdb</span><span class="kw">)</span> <span class="ex">n</span></span>
<span id="cb26-11"><a href="#cb26-11"></a><span class="ex">9</span>       movq <span class="va">$value</span>,%rcx </span>
<span id="cb26-12"><a href="#cb26-12"></a><span class="kw">(</span><span class="fu">gdb</span><span class="kw">)</span> <span class="ex">print/x</span> <span class="va">$rcx</span> </span>
<span id="cb26-13"><a href="#cb26-13"></a><span class="va">$1</span> = 0x0</span>
<span id="cb26-14"><a href="#cb26-14"></a><span class="kw">(</span><span class="fu">gdb</span><span class="kw">)</span> <span class="ex">n</span></span>
<span id="cb26-15"><a href="#cb26-15"></a><span class="ex">10</span>      movq <span class="va">$6</span>0, %rax </span>
<span id="cb26-16"><a href="#cb26-16"></a><span class="kw">(</span><span class="fu">gdb</span><span class="kw">)</span> <span class="ex">print/x</span> <span class="va">$rcx</span> </span>
<span id="cb26-17"><a href="#cb26-17"></a><span class="va">$2</span> = 0x6000c8</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="moving-data-values-from-a-register-to-memory" class="level3">
<h3 class="anchored" data-anchor-id="moving-data-values-from-a-register-to-memory">moving data values from a register to memory</h3>
<div class="sourceCode" id="cb27"><pre class="sourceCode numberSource asm number-lines code-with-copy"><code class="sourceCode fasm"><span id="cb27-1"><a href="#cb27-1"></a>.<span class="bu">section</span> <span class="op">.</span>data </span>
<span id="cb27-2"><a href="#cb27-2"></a># define value with <span class="dv">8</span> bytes <span class="op">and</span> value <span class="dv">3</span></span>
<span id="cb27-3"><a href="#cb27-3"></a><span class="fu">value:</span> .quad <span class="dv">3</span>  </span>
<span id="cb27-4"><a href="#cb27-4"></a></span>
<span id="cb27-5"><a href="#cb27-5"></a>.<span class="bu">section</span> <span class="op">.</span>text </span>
<span id="cb27-6"><a href="#cb27-6"></a>.globl _start </span>
<span id="cb27-7"><a href="#cb27-7"></a><span class="fu">_start:</span> </span>
<span id="cb27-8"><a href="#cb27-8"></a>    <span class="bu">nop</span> </span>
<span id="cb27-9"><a href="#cb27-9"></a>    <span class="bu">movq</span> <span class="op">$</span><span class="bn">100</span><span class="op">,</span> <span class="op">%</span><span class="kw">rcx</span> </span>
<span id="cb27-10"><a href="#cb27-10"></a>    <span class="bu">movq</span> <span class="op">%</span><span class="kw">rcx</span><span class="op">,</span> value </span>
<span id="cb27-11"><a href="#cb27-11"></a>    </span>
<span id="cb27-12"><a href="#cb27-12"></a>    # exit the program with error code <span class="dv">42</span> </span>
<span id="cb27-13"><a href="#cb27-13"></a>    <span class="bu">movq</span> <span class="op">$</span><span class="bn">60</span><span class="op">,</span> <span class="op">%</span><span class="kw">rax</span> </span>
<span id="cb27-14"><a href="#cb27-14"></a>    <span class="bu">movq</span> <span class="op">$</span><span class="bn">42</span><span class="op">,</span> <span class="op">%</span><span class="kw">rdi</span> </span>
<span id="cb27-15"><a href="#cb27-15"></a>    <span class="cf">syscall</span> </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb28"><pre class="sourceCode numberSource bash number-lines code-with-copy"><code class="sourceCode bash"><span id="cb28-1"><a href="#cb28-1"></a><span class="ex">[root@centos8</span> asm]# as <span class="at">-gstabs</span> <span class="at">-o</span> movtest1.o movtest1.s </span>
<span id="cb28-2"><a href="#cb28-2"></a><span class="ex">[root@centos8</span> asm]# ld <span class="at">-o</span> movtest1 movtest1.o </span>
<span id="cb28-3"><a href="#cb28-3"></a><span class="ex">[root@centos8</span> asm]# gdb <span class="at">-q</span> ./movtest1</span>
<span id="cb28-4"><a href="#cb28-4"></a><span class="ex">Reading</span> symbols from ./movtest1...done.</span>
<span id="cb28-5"><a href="#cb28-5"></a><span class="kw">(</span><span class="fu">gdb</span><span class="kw">)</span> <span class="ex">b</span> <span class="pp">*</span>_start</span>
<span id="cb28-6"><a href="#cb28-6"></a><span class="ex">Breakpoint</span> 1 at 0x4000b0: file movtest1.s, line 8.</span>
<span id="cb28-7"><a href="#cb28-7"></a><span class="kw">(</span><span class="fu">gdb</span><span class="kw">)</span> <span class="ex">r</span></span>
<span id="cb28-8"><a href="#cb28-8"></a><span class="ex">Starting</span> program: /root/tmp/asm/movtest1 </span>
<span id="cb28-9"><a href="#cb28-9"></a></span>
<span id="cb28-10"><a href="#cb28-10"></a><span class="ex">Breakpoint</span> 1, _start <span class="er">(</span><span class="kw">)</span> <span class="ex">at</span> movtest1.s:8</span>
<span id="cb28-11"><a href="#cb28-11"></a><span class="ex">8</span>       nop </span>
<span id="cb28-12"><a href="#cb28-12"></a><span class="kw">(</span><span class="fu">gdb</span><span class="kw">)</span> <span class="ex">x/d</span> <span class="kw">&amp;</span><span class="ex">value</span> </span>
<span id="cb28-13"><a href="#cb28-13"></a><span class="ex">0x6000d0:</span>   3</span>
<span id="cb28-14"><a href="#cb28-14"></a><span class="kw">(</span><span class="fu">gdb</span><span class="kw">)</span> <span class="ex">n</span></span>
<span id="cb28-15"><a href="#cb28-15"></a><span class="ex">9</span>       movq <span class="va">$1</span>00, %rcx </span>
<span id="cb28-16"><a href="#cb28-16"></a><span class="kw">(</span><span class="fu">gdb</span><span class="kw">)</span> <span class="ex">n</span></span>
<span id="cb28-17"><a href="#cb28-17"></a><span class="ex">10</span>      movq %rcx, value </span>
<span id="cb28-18"><a href="#cb28-18"></a><span class="kw">(</span><span class="fu">gdb</span><span class="kw">)</span> <span class="ex">n</span></span>
<span id="cb28-19"><a href="#cb28-19"></a><span class="ex">13</span>      movq <span class="va">$6</span>0, %rax </span>
<span id="cb28-20"><a href="#cb28-20"></a><span class="kw">(</span><span class="fu">gdb</span><span class="kw">)</span> <span class="ex">x/d</span> <span class="kw">&amp;</span><span class="ex">value</span> </span>
<span id="cb28-21"><a href="#cb28-21"></a><span class="ex">0x6000d0:</span>   100</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="using-indexed-memory-locations" class="level3">
<h3 class="anchored" data-anchor-id="using-indexed-memory-locations">Using indexed memory locations</h3>
<p>You can specify more than one value on a directive to place in memory:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode numberSource asm number-lines code-with-copy"><code class="sourceCode fasm"><span id="cb29-1"><a href="#cb29-1"></a><span class="fu">values:</span> .<span class="bu">int</span> <span class="dv">10</span><span class="op">,</span> <span class="dv">15</span><span class="op">,</span> <span class="dv">20</span><span class="op">,</span> <span class="dv">25</span><span class="op">,</span> <span class="dv">30</span> </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>When referencing data in the array, you must use an index system to determine which value you are accessing. The way this id done is called “indexed memory mode”. The memory location is determined by the following:</p>
<ul>
<li>A base address</li>
<li>A offset address to add to the base address</li>
<li>The size of the data element</li>
<li>An index to determine which data element to select</li>
</ul>
<p>The format of the expression is</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode numberSource asm number-lines code-with-copy"><code class="sourceCode fasm"><span id="cb30-1"><a href="#cb30-1"></a>base_address<span class="op">(</span>offset_address<span class="op">,</span> index<span class="op">,</span> size<span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The data value retrieved is located at <code>base_address + offset_address + index * size</code>. If any of the values are zero, they can be omitted(but the commas are still required as placeholders). The offset_address and index value must be registers, but the size value can be a numerical value. For ex, to reference the value 20 from the values array shown, you would use the following instructions:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode numberSource asm number-lines code-with-copy"><code class="sourceCode fasm"><span id="cb31-1"><a href="#cb31-1"></a>movl <span class="op">$</span><span class="bn">2</span><span class="op">,</span> <span class="op">%</span><span class="kw">edi</span> </span>
<span id="cb31-2"><a href="#cb31-2"></a>movl values<span class="op">(,%</span><span class="kw">edi</span><span class="op">,</span><span class="dv">4</span><span class="op">),</span> <span class="op">%</span><span class="kw">eax</span> </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="using-indirect-addressing-with-registers" class="level3">
<h3 class="anchored" data-anchor-id="using-indirect-addressing-with-registers">Using indirect addressing with registers</h3>
<p>Besides holding data, registers can also be used to hold memory addresses. When a register holds a memory address, it is referred to as a pointer. Accessing the data stored in the memory location using the pointer is called indirect addressing.</p>
<p>While using a label references the data value contained in the memory location, you can get the memory location address of the data value by placing a dollar sign <code>$</code> in front of the label in the instruction.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode numberSource asm number-lines code-with-copy"><code class="sourceCode fasm"><span id="cb32-1"><a href="#cb32-1"></a>// move the memory address the <span class="op">`</span>values<span class="op">`</span> label references to the <span class="kw">EDI</span> register </span>
<span id="cb32-2"><a href="#cb32-2"></a>movl <span class="op">$</span>values<span class="op">,</span> <span class="op">%</span><span class="kw">edi</span> </span>
<span id="cb32-3"><a href="#cb32-3"></a></span>
<span id="cb32-4"><a href="#cb32-4"></a>movl <span class="op">%</span><span class="kw">edx</span><span class="op">,</span> <span class="dv">4</span><span class="op">(%</span><span class="kw">edi</span><span class="op">)</span></span>
<span id="cb32-5"><a href="#cb32-5"></a></span>
<span id="cb32-6"><a href="#cb32-6"></a>movl <span class="op">%</span><span class="kw">edx</span><span class="op">,</span> <span class="op">-</span><span class="dv">4</span><span class="op">(%</span><span class="kw">edi</span><span class="op">)</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="conditional-move-instructions" class="level3">
<h3 class="anchored" data-anchor-id="conditional-move-instructions">Conditional Move Instructions</h3>
<p>The conditional move instruction can prevent the processor from implementing JMP instructions, which helps out the prefetch cache condition of the processor, usually speeding up the application.</p>
<p><code>cmovx source, destimation</code> where x is a one or two letter code denoting the condition that will trigger the move action. The conditions are based on the current values in the RFLAGS register.</p>
<p>CF, Carry flag</p>
<p>OF, Overflow flag</p>
<p>PF, Parity flag</p>
<p>SF, Sign flag</p>
<p>ZF, Zero flag</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode numberSource asm number-lines code-with-copy"><code class="sourceCode fasm"><span id="cb33-1"><a href="#cb33-1"></a>//conditional move instructions for unsigned values </span>
<span id="cb33-2"><a href="#cb33-2"></a><span class="bu">cmova</span><span class="op">/</span>cmovnbe<span class="op">,</span> above<span class="op">/not</span> below <span class="op">or</span> equal </span>
<span id="cb33-3"><a href="#cb33-3"></a><span class="bu">cmovae</span><span class="op">/</span>cmovnb<span class="op">,</span> above <span class="op">or</span> equal<span class="op">/not</span> below </span>
<span id="cb33-4"><a href="#cb33-4"></a><span class="bu">cmovnc</span><span class="op">,</span> <span class="op">not</span> carry </span>
<span id="cb33-5"><a href="#cb33-5"></a><span class="bu">cmovb</span><span class="op">/</span>cmovnae<span class="op">,</span> below<span class="op">/not</span> above <span class="op">or</span> equal </span>
<span id="cb33-6"><a href="#cb33-6"></a><span class="bu">cmovc</span><span class="op">,</span> carry </span>
<span id="cb33-7"><a href="#cb33-7"></a><span class="bu">cmovbe</span><span class="op">/</span>cmovna<span class="op">,</span> below <span class="op">or</span> equal<span class="op">/not</span> above </span>
<span id="cb33-8"><a href="#cb33-8"></a><span class="bu">cmove</span><span class="op">/</span>cmovz<span class="op">,</span> equal<span class="op">/</span>zero </span>
<span id="cb33-9"><a href="#cb33-9"></a><span class="bu">cmovne</span><span class="op">/</span>cmovnz<span class="op">,</span> <span class="op">not</span> equal<span class="op">/not</span> zero </span>
<span id="cb33-10"><a href="#cb33-10"></a><span class="bu">cmovp</span><span class="op">/</span>cmovpe<span class="op">,</span> PF <span class="op">=</span> <span class="dv">1</span><span class="op">,</span> parity even </span>
<span id="cb33-11"><a href="#cb33-11"></a><span class="bu">cmovnp</span><span class="op">/</span>cmovpo<span class="op">,</span> <span class="op">not</span> parity<span class="op">/</span>parity odd<span class="op">,</span> PF<span class="op">=</span><span class="dv">0</span> </span>
<span id="cb33-12"><a href="#cb33-12"></a></span>
<span id="cb33-13"><a href="#cb33-13"></a>//conditional move instructions for signed values </span>
<span id="cb33-14"><a href="#cb33-14"></a><span class="bu">cmovge</span><span class="op">/</span>cmovnl<span class="op">,</span> greater <span class="op">or</span> equal<span class="op">/not</span> less  </span>
<span id="cb33-15"><a href="#cb33-15"></a><span class="bu">cmovl</span><span class="op">/</span>cmovnge<span class="op">,</span> less<span class="op">/not</span> greater <span class="op">or</span> equal </span>
<span id="cb33-16"><a href="#cb33-16"></a><span class="bu">cmovle</span><span class="op">/</span>cmovng<span class="op">,</span> less <span class="op">or</span> equal<span class="op">/not</span> greater </span>
<span id="cb33-17"><a href="#cb33-17"></a><span class="bu">cmovo</span><span class="op">,</span> overflow</span>
<span id="cb33-18"><a href="#cb33-18"></a><span class="bu">cmovno</span><span class="op">,</span> <span class="op">not</span> overflow  </span>
<span id="cb33-19"><a href="#cb33-19"></a><span class="bu">cmovs</span><span class="op">,</span> sign </span>
<span id="cb33-20"><a href="#cb33-20"></a><span class="bu">cmovns</span><span class="op">,</span> <span class="op">not</span> sign </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="exchanging-data" class="level3">
<h3 class="anchored" data-anchor-id="exchanging-data">Exchanging Data</h3>
<p>One drawback to the MOV instructions is that it is difficult to switch the values of two registers without using a temporary intermediate register.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode numberSource asm number-lines code-with-copy"><code class="sourceCode fasm"><span id="cb34-1"><a href="#cb34-1"></a><span class="bu">xchg</span><span class="op">,</span> exchanges the values of two registers<span class="op">,</span> <span class="op">or</span> a register <span class="op">and</span> a memory location </span>
<span id="cb34-2"><a href="#cb34-2"></a><span class="bu">BSWAP</span><span class="op">,</span> reverses the <span class="dt">byte</span> order in a <span class="dv">32</span><span class="op">-</span>bit register </span>
<span id="cb34-3"><a href="#cb34-3"></a><span class="bu">xadd</span><span class="op">,</span> exchanges two values <span class="op">and</span> stores the sum in the destination operand </span>
<span id="cb34-4"><a href="#cb34-4"></a><span class="bu">cmpxchg</span><span class="op">,</span> compares a value with an external value <span class="op">and</span> exchanges it with another<span class="op">.</span> </span>
<span id="cb34-5"><a href="#cb34-5"></a><span class="bu">cmpxchg8b</span><span class="op">,</span> compares two <span class="dv">64</span><span class="op">-</span>bit values <span class="op">and</span> exchanges it with another </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="stack" class="level3">
<h3 class="anchored" data-anchor-id="stack">Stack</h3>
<div class="sourceCode" id="cb35"><pre class="sourceCode numberSource asm number-lines code-with-copy"><code class="sourceCode fasm"><span id="cb35-1"><a href="#cb35-1"></a>pushl </span>
<span id="cb35-2"><a href="#cb35-2"></a><span class="bu">pushw</span> </span>
<span id="cb35-3"><a href="#cb35-3"></a>pushq</span>
<span id="cb35-4"><a href="#cb35-4"></a></span>
<span id="cb35-5"><a href="#cb35-5"></a>popl</span>
<span id="cb35-6"><a href="#cb35-6"></a><span class="bu">popw</span></span>
<span id="cb35-7"><a href="#cb35-7"></a>popq</span>
<span id="cb35-8"><a href="#cb35-8"></a></span>
<span id="cb35-9"><a href="#cb35-9"></a><span class="bu">PUSHA</span><span class="op">/</span>POPA    <span class="op">//not</span> available in <span class="dv">64</span><span class="op">-</span>bit </span>
<span id="cb35-10"><a href="#cb35-10"></a><span class="bu">PUSHAD</span><span class="op">/</span>POPAD  <span class="op">//not</span> available in <span class="dv">64</span><span class="op">-</span>bit </span>
<span id="cb35-11"><a href="#cb35-11"></a><span class="bu">PUSHF</span><span class="op">/</span>POPF</span>
<span id="cb35-12"><a href="#cb35-12"></a><span class="bu">PUSHFD</span><span class="op">/</span>POPFD </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
</section>
<section id="chap6-controlling-execution-flow" class="level2">
<h2 class="anchored" data-anchor-id="chap6-controlling-execution-flow">Chap6 Controlling Execution Flow</h2>
<p>Read to page 158</p>
</section>
</section>
<section id="book-beginning-x64-assembly-programming-by-jo-van-hoey" class="level1">
<h1>Book Beginning x64 Assembly Programming by Jo Van Hoey</h1>
<p>It includes introductions on asm on both Linux and Windows. It also include some advanced instructions for example AVX, SSE, etc.</p>
</section>
<section id="book-x64-assembly-language-step-by-step" class="level1">
<h1>Book X64 Assembly Language Step by Step</h1>
<p>Notes while I read the book.</p>
<section id="chap1-its-all-in-the-plan-understanding-what-computers-really-do" class="level2">
<h2 class="anchored" data-anchor-id="chap1-its-all-in-the-plan-understanding-what-computers-really-do">Chap1 It’s all in the Plan: Understanding What Computers Really Do</h2>
<p>A computer program is a list of steps and tests, nothing more.</p>
<p>A test is the sort of either/or decision we make. - First, you take a look at sth that can go one of two way. - Then you do one of two things, depending on what you saw when you took a look.</p>
</section>
<section id="chap2-allien-bases-getting-your-arms-around-binary-and-hexadecimal" class="level2">
<h2 class="anchored" data-anchor-id="chap2-allien-bases-getting-your-arms-around-binary-and-hexadecimal">Chap2 Allien Bases: Getting Your Arms Around Binary and Hexadecimal</h2>
<p>octal</p>
<p>hexadecimal</p>
<p>binary</p>
</section>
<section id="chap3-lifting-the-hood-discovering-what-computers-actually-are" class="level2">
<h2 class="anchored" data-anchor-id="chap3-lifting-the-hood-discovering-what-computers-actually-are">Chap3 Lifting the Hood: Discovering What Computers Actually Are</h2>
<p>A bit is a single binary digit, either 1 or 0.</p>
<p>A byte is eight bits.</p>
<p>Two bytes side by side are called a word.</p>
<p>Two words side by side are called a double word.</p>
<p>A quad word consists of two double words.</p>
<p>A group of four bits is called a nybble.</p>
</section>
<section id="chap4-location-registers-memory-addressing-and-knowing-where-things-are" class="level2">
<h2 class="anchored" data-anchor-id="chap4-location-registers-memory-addressing-and-knowing-where-things-are">Chap4 Location: Registers, Memory Addressing, and Knowing Where Things Are</h2>
<p>The skill of assembly language consists of a deep comprehension of memory addressing. Everything else is details – and easy details, at that.</p>
<p>There are a fair number of different ways to address memory in the Intel/AMD CPU family. Each of these ways is called a Memory Model. There are 3 major memory models that you can use with the more recent members of the Intel family, and a number of minor variations on those three, especially the one in the middle.</p>
<p>Real mode flat model.</p>
<p>Real mode segmented model.</p>
<p>Protected-mode flat model(32-bit and 64-bit).</p>
<p>The 8080 was an 8-bit CPU(its general-purpose registers have 8-bits), meaning that it processed 8 bits of information at a time. However, it had 16 address lines coming out of it(it will address 64KB).</p>
<p>The 8080 memory-addressing scheme was very simple. You put a 16-bit address out on the address lines, and you got back the 8-bit value that was stored at that address.</p>
<p>The 8086 comes after 8080. It is 16-bit CPU. It has 20 address lines.</p>
<p>The 8080 is used a lot. Intel wanted to make it easy for people to translate older software from the 8080 to 8086. One way to do this was to make sure that a 16-bit addressing system such as that of the 8080 still worked. Even though the 8086 could address 16 times as much memory as the 8080(16x64KB=1MB), Intel setup the 8086 so that a program could take some 64 KB segment within that megabyte of memory and run entirely inside it, just as though it were the smaller 8080 memory system. This was done by the use of segment registers.</p>
<p>Speaking of the 8086 and 8088, there are 4 segment registers(CS, DS, …).</p>
<p>This was very wise short-term thinking and catastrophically bad long-term thinking. Programs that needed more than 64KB of memory at a time had to use memory in 64KB chunks, switching between chunks by switching values into and out of segment registers.</p>
<p>To maintain backward compatibility with the ancient 8086 and 8088, newer CPUs were given the power to limit themselves to what the older chips could address and execute. When a Pentium-class or better CPU needs to run software written for the real-mode segmented model, it pulls a neat trick that, temporarily, make it become an 8086. This was called virtual-86 mode, and it provided excellent backward compatibility for DOS software.</p>
<p>A segment may start every 16 bytes throughout the full megabyte of real memory.</p>
<p>CS, DS, SS, ES, FS, GS: Segment registers. All segment registers are 16 bits in size, irrespective of the CPU. FS and GS exist only in the 386 and later Intel x86 32-bit CPUs.</p>
<p>CS: Code Segment</p>
<p>DS: Data Segment</p>
<p>SS: Stack Segment</p>
<p>ES: Extra segment</p>
<p>FS, GS: Clones of ES</p>
<p>Segment registers become useless in application programming in X86-64. Operating systems use two of them for special purposes.</p>
<p>Do Intel’s x86-64 CPUs have 64 address lines? No (48 or 52).</p>
<p>In the x86-64 world, CPUs have 14 general purpose 64-bit registers, plus SP and BP.</p>
<p>There are eight 16-bit general-purpose registers: AX, BX, CX, DX, BP, SI, DI, SP (8086, 8088, 80186 and 80286).</p>
<p>EAX, EBX, ECX, EDX, EBP, ESI, EDI, ESP. (32 bitS)</p>
<p>RAX, RBX, RCX, RDX, RBP, RSI, RDI, RSP. R8 to R15. (64 BITS)</p>
<p>RAX(EAX(AX(AH,AL)))</p>
<p>RBX(EBX(BX(BH,BL)))</p>
<p>RCX(ECX(CX(CH,CL)))</p>
<p>RDX(EDX(DX(DH,DL)))</p>
<p>RSI(ESI(SI(SIL))) and so on for RDI, RSP.</p>
<p>RIP, EIP, IP</p>
<p>The new x64 registers R8-R15 can be addressed as 64 bits, 32 bits, 16 bits, and 8 bits. However, the AH/AL scheme for the low 16 bits is a trick reserved for only RAX-RDX. The naming scheme for the R registers provides a mnemonic: D for double word, W for word, and B for byte. For example, if you want to deal with the lowest 8 bits of R8, you use the name R8B. Don’t make the beginner’s mistake of assuming that R8, R8D, R8W, and R8B are four separate and independent registers! A better metaphor is to think of the register names as country/state/county/city.</p>
<p>IP register.</p>
<p>While executing a program, the CPU uses IP to keep track of where it is in the current code segment. Instructions come in different sizes, ranging typically from 1 to 15 bytes. The CPU knows the size of each instruction it executes.</p>
<p>IP is notable in being the only register that can neither be read nor written to directly.</p>
<p>Flags register.</p>
<p>RFLAGS, EFLAGS, FLAGS. When the flag’s value is 1, we say that the flag is set. When the flag’s value is 0, we say that the flag is cleared.</p>
<p>Math Coprocessors and Their Registers (may be 128 bits or 256 bits)</p>
<p>Real-Mode Flat Model</p>
<p>Real-Mode Segmented Model</p>
<p>32-bit Protected Mode Flat Model</p>
<p>64-bit Long Mode</p>
</section>
<section id="chap5-the-right-to-assemble-the-process-of-creating-assembly-language-programs" class="level2">
<h2 class="anchored" data-anchor-id="chap5-the-right-to-assemble-the-process-of-creating-assembly-language-programs">Chap5 The Right to Assemble: The Process of Creating Assembly Language Programs</h2>
<p>Text files: are files that can be opened and examined meaningfully in a text editor, like notepad.</p>
<p>Binary files: are files containing values that do not display meaningfully as text.</p>
<p>Assemblers: read your source code files and generate an object code file containing the machine instructions that the CPU understands plus any data you’ve defined in your source code.</p>
<p>Linker: Object code files cannot themselves be run as programs. An additional step, called linking, is necessary to turn object code files into executable program files.</p>
<p>Symbol table: To process several object modules into a single executable module, the linker must first build an index called a symbol table, with an entry for every named item in every object module it links, with information on what name (called a symbol) refers to what location within the module.</p>
<p>Exe: Once the symbol table is complete, the linker builds an image of how the executable program will be arranged in memory when the operating system loads it. This image is then to disk as the executable file. The most important thing about the image that the linker builds relates to addresses.</p>
<p>Holes: Object modules are allowed to refer to symbols in other object modules. During assembly, these external references are left as holes to be filled later—naturally enough, because the module in which these external symbolsexist may not have been assembled or even written yet. As the linker builds animage of the eventual executable program file, it learns where all of the symbols are located within the image and thus can drop real addresses into all of the external reference holes.</p>
<p>Debugging info: Debugging information is, in a sense, a step backward. Portions of the source code, which was all stripped out early in the assembly process, are put back into the object module by the assembler. These portions of the source code are mostly the names of data items and procedures, and they’re embedded in the object file to make it easier for the programmer (you!) to see the names of data items when you debug the program.</p>
<p>Relocatability: Primordial microcomputers like 8080 systems running CP/M-80 had a simple memory architecture. Programs were written to be loaded and run at a specific physical memory address. For CP/M, this was 0100H. The programmer could assume that any program would start at 0100H and go up from there. Memory addresses of data items and procedures were actual physical addresses, and every time the program ran, its data items were loaded and referenced at precisely the same place in memory. This all changed with the arrival of the 8086, and 8086-specific operating systems such as CP/M-86 and PC DOS. Improvements in the Intel architecture introduced with the 8086 made it unnecessary for the program to be assembled for running at any specific physical memory address. This feature is called relocatability and is a necessary part of any modern operating system, especially when multiple programs may be running at once.</p>
<p>The author uses <code>nasm</code>. To compile an ASM file. Also <code>SASM</code> IDE for editing, building and debugging. <code>SASM</code> means SimpleAssembler.</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode numberSource bash number-lines code-with-copy"><code class="sourceCode bash"><span id="cb36-1"><a href="#cb36-1"></a><span class="fu">nasm</span> <span class="at">-f</span> elf64 <span class="at">-g</span> <span class="at">-Fdwarf</span> first.asm </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="chap6-linux-and-the-tools-that-shape-the-way-you-work" class="level2">
<h2 class="anchored" data-anchor-id="chap6-linux-and-the-tools-that-shape-the-way-you-work">Chap6 Linux and the Tools That Shape the Way You Work</h2>
<p>SASM: Simple ASM</p>
<p>Make</p>
</section>
<section id="chap7-following-your-instructions-meeting-machine-instructions-up-close-and-personal" class="level2">
<h2 class="anchored" data-anchor-id="chap7-following-your-instructions-meeting-machine-instructions-up-close-and-personal">Chap7 Following your instructions: Meeting Machine Instructions Up Close and Personal</h2>
<p>instructions: xchg, inc, dec, jnz, jmp, neg, movsx, mul, div, imul, idiv</p>
<p>Immediate data is built right into its own machine instruction. Register data is stored in one of the CPU’s collection of internal registers. In contrast, memory data is stored somewhere in the silver of system memory “owned” by a program, at a 64-bit memory address.</p>
<p>Only one of an instruction’s two operands may specify a memory location. You can’t move a memory value directly to another memory value. This is an inherent limitation of Intel CPUs of all generations.</p>
<p>To specify that we want the data at the memory location contained in a register rather than the data in the register itself, we use square brackets around the name of the register.</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode numberSource asm number-lines code-with-copy"><code class="sourceCode fasm"><span id="cb37-1"><a href="#cb37-1"></a><span class="bu">mov</span> <span class="kw">rax</span><span class="op">,</span> <span class="op">[</span><span class="kw">rbx</span><span class="op">]</span></span>
<span id="cb37-2"><a href="#cb37-2"></a></span>
<span id="cb37-3"><a href="#cb37-3"></a><span class="bu">mov</span> <span class="kw">rax</span><span class="op">,</span> <span class="op">[</span><span class="kw">rbx</span> <span class="op">+</span> <span class="dv">16</span><span class="op">]</span></span>
<span id="cb37-4"><a href="#cb37-4"></a></span>
<span id="cb37-5"><a href="#cb37-5"></a><span class="bu">mov</span> <span class="kw">rax</span><span class="op">,</span> <span class="op">[</span><span class="kw">rbx</span> <span class="op">+</span> <span class="kw">rcx</span><span class="op">]</span></span>
<span id="cb37-6"><a href="#cb37-6"></a></span>
<span id="cb37-7"><a href="#cb37-7"></a><span class="bu">mov</span> <span class="kw">rax</span><span class="op">,</span> <span class="op">[</span><span class="kw">rbx</span> <span class="op">+</span> <span class="kw">rcx</span> <span class="op">+</span> <span class="dv">11</span><span class="op">]</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Whatever is inside the brackets is called the effective address of a data item in memory. At the current evolution of the Intel hardware, 2 registers may be added together to form the effective address, but not three or more.</p>
<p>Where the size issue gets tricky is when you write data in a register out to memory. NASM does not “remember” the size of variables, like higher-level languages do. It knows where EatMsg starts in memory, and that’s it. You have to tell NASM how many bytes of data to move. This is done by a size specifier.</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode numberSource asm number-lines code-with-copy"><code class="sourceCode fasm"><span id="cb38-1"><a href="#cb38-1"></a><span class="bu">mov</span> <span class="dt">byte</span> <span class="op">[</span>EatMsg<span class="op">],</span> <span class="st">'G'</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Here we tell NASM that we want to move only a single byte out to memory by using the BYTE size specifier. Other size specifiers include WORD, DWORD, QWORD.</p>
<p>Only 18 bits of the RFlags register are actually flags. The rest are reserved for later use in future generations of Intel CPUs. Even among the defined flags, only a few are commonplace, and fewer still are useful when you’re just learning your way around. Some are used only inside system software like operating systems and are not available at all in userspace programs.</p>
<p>OF: Overflow flag. is set when the result of an arithmetic operation on a signed integer quantity becomes too large to fit in the operand it originally occupied. OF is generally used as the “carry flag” in signed arithmetic.</p>
<p>DF: The Direction flag is an oddball among the flags in that it tells the CPU something that you want it to know, rather than the other way around. It dictates the direction that activity moves (up-memory or down-memory) during the execution of string instructions. When DF is set, string instructions proceed from high memory toward low memory. When DF is cleared, string instructions proceed from low memory toward high memory.</p>
<p>IF: The Interrupt Enable flag is a two-way flag. The CPU sets it under certain conditions, and you can set it yourself using the STI and CLI instructions—though you probably won’t; see below. When IF is set, interrupts are enabled and may occur when requested. When IF is cleared, interrupts are ignored by the CPU. Ordinary programs could set and clear this flag with impunity in Real Mode, back in the DOS era. Under Linux (whether 32-bit or 64-bit) IF is reserved for the use of the operating system and sometimes its drivers. If you try to use the STI and CLI instructions within one of your programs, Linux will hand you a general protection fault, and your program will be terminated. Consider IF off-limits for userspace programming like we’re discussing in this book.</p>
<p>TF: When set, the Trap flag allows debuggers to manage single-stepping, by forcing the CPU to execute only a single instruction before calling an interrupt routine. This is not an especially useful flag for ordinary programming, and I won’t have anything more to say about it in this book.</p>
<p>SF: The Sign flag becomes set when the result of an operation forces the operand to become negative. By negative, we mean only that the highest-order bit in the operand (the sign bit) becomes 1 during a signed arithmetic operation. Any operation that leaves the sign of the result positive will clear SF</p>
<p>ZF: The Zero flag becomes set when the results of an operation become zero. If the destination operand instead becomes some nonzero value, ZF is cleared. You’ll be using this one a lot for conditional jumps.</p>
<p>AF: The Auxiliary Carry flag. used only for BCD arithmetic. These instructions are considered obsolete and are not present in x64.</p>
<p>PF: The Parity flag PF indicates whether the number of set (1) bits in the low-order byte of a result is even or odd. For example, if the result is 0F2H, PF will be cleared because 0F2H (11110010) contains an odd number of 1 bits.</p>
<p>CF: The Carry flag is used in unsigned arithmetic operations. If the result of an arithmetic or shift operation “carries out” a bit from the operand, CF becomes set. Otherwise, if nothing is carried out, CF is cleared.</p>
<p>The highest bit in the most significant byte of a signed value is the sign bit. If the sign bit is a 1-bit, the number is negative.</p>
<p>movsx: move with sign extension</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode numberSource asm number-lines code-with-copy"><code class="sourceCode fasm"><span id="cb39-1"><a href="#cb39-1"></a><span class="bu">xor</span> <span class="kw">rax</span><span class="op">,</span> <span class="kw">rax</span> </span>
<span id="cb39-2"><a href="#cb39-2"></a><span class="bu">mov</span> <span class="kw">ax</span><span class="op">,</span> <span class="op">-</span><span class="dv">42</span> </span>
<span id="cb39-3"><a href="#cb39-3"></a><span class="bu">movsx</span> <span class="kw">rbx</span><span class="op">,</span> <span class="kw">ax</span> <span class="co">;rbx will become -42 in two's complement </span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p><code>mul</code> instruction has implicit operand. Immediate values cannot be used as operands for <code>mul</code>. MUL very helpfully sets the Carry flag CF when the value of the product overflows the low-order register.</p>
<table class="table">
<thead>
<tr class="header">
<th>explicit operand</th>
<th>implicit operand</th>
<th>implicit product</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>mul r/m8</td>
<td>AL</td>
<td>AX</td>
</tr>
<tr class="even">
<td>mul r/m16</td>
<td>AX</td>
<td>DX:AX</td>
</tr>
<tr class="odd">
<td>mul r/m32</td>
<td>EAX</td>
<td>EDX:EAX</td>
</tr>
<tr class="even">
<td>mul r/m64</td>
<td>RAX</td>
<td>RDX:RAX</td>
</tr>
</tbody>
</table>
<table class="table">
<thead>
<tr class="header">
<th>explicit operand</th>
<th>implicit operand</th>
<th>quotient</th>
<th>remainder</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>div r/m8</td>
<td>AX</td>
<td>AL</td>
<td>AH</td>
</tr>
<tr class="even">
<td>div r/m16</td>
<td>DX:AX</td>
<td>AX</td>
<td>DX</td>
</tr>
<tr class="odd">
<td>div r/m32</td>
<td>EDX:EAX</td>
<td>EAX</td>
<td>EDX</td>
</tr>
<tr class="even">
<td>div r/m64</td>
<td>RDX:RAX</td>
<td>RAX</td>
<td>RDX</td>
</tr>
</tbody>
</table>
<p>Note: r/m8 means 8bits register or memory</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode numberSource asm number-lines code-with-copy"><code class="sourceCode fasm"><span id="cb40-1"><a href="#cb40-1"></a><span class="bu">mov</span> <span class="kw">eax</span><span class="op">,</span><span class="dv">447</span></span>
<span id="cb40-2"><a href="#cb40-2"></a><span class="bu">mov</span> <span class="kw">ebx</span><span class="op">,</span><span class="dv">1739</span></span>
<span id="cb40-3"><a href="#cb40-3"></a><span class="bu">mul</span> <span class="kw">ebx</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="chap8-creating-programs-that-work" class="level2">
<h2 class="anchored" data-anchor-id="chap8-creating-programs-that-work">Chap8 Creating programs that work</h2>
<p>Ordinary user-space programs written in NASM for Linux are divided into 3 sections. The order in which these sections fall in your program really isn’t important, but by convention the .data section comes first, followed by the .bss section and then the .text section.</p>
<p>.data section contains data definitions of initialized data items.</p>
<p>.bss Block/Buffer Start Symbol. Contains data items not having values before the program begins running.</p>
<p>Data items in the .data section add to the size of your executable file. Data items in the .bss section do not. A buffer that takes up 16,1000 bytes can be defined in .bss and add almost nothing( about 50 bytes for the desctiption) to the executable file size. This is possible because of the way the Linux loader brings the programs into memory. When you build your executable file, the Linux linker adds info to the file describing all the symbols you’ve defined, including symbols naming data items. The loader knows which data items do not have initial values, and it allocates space in momory for them when it brings the executable in from disk. Data items with initial values are read in along with their values.</p>
<p>The actual machine instructions that make up your program go into the .text section. The .text section contains symbols called labels that identify locations in the program code for jumps and calls. All global labels must be declared in the .text section, or the labels cannot be “seen” outside your program.</p>
<p>Refer to <a href="https://www.baeldung.com/cs/compiler-linker-assembler-loader">compiler,linker,assembler,loader</a></p>
<p>Linux Compiler: A compiler is a specialized system tool that translates a program written in a specific programming language into the assembly language code.</p>
<p>Linux Assembler: The assembler translates our assembly code to the machine code and then stores the result in an object file. Moving further, the assembler gives a memory location to each object and instruction in our code. The memory location can be physical as well as virtual. A virtual location is an offset that is relative to the base address of the first instruction.</p>
<p>Linux Linker: The linker combines all external programs (such as libraries and other shared components) with our program to create a final executable.</p>
<p>Linux Loader: The loader is a specialized operating system module. It loads the final executable code into memory.</p>
<p>Labels must begin with a letter or else with an underscore, period, or question mark. Theese last three have special meanings to the assembler, so don’t use them until you know how NASM interprets them.</p>
<p>Labels must be followed by a colon when they are defined.</p>
<p>Labels are case sensitive.</p>
<p>PUSH: pushes a 16-bit or 64-bit register or memory value that is specified by you in your source code. Note that you can’t push an 8-bit nor a 32-bit value onto the stack! You’ll get an error if you try.</p>
<p>PUSHFQ: pushes the full 64-bit RFlags register onto the stack. The Q means quadword.</p>
<p>Any of the 16-bit and 64-bit general-purpose registers may be pushed individually onto the stack. You can’t push AL or BH or any other of the 8-bit registers. 16bit and 64bit immediate data can be pushed onto the stack. User-space Linux programs cannot push the segment registers onto the stack under any circumstance. With x64, segment registers belong to the OS and are unavailable to user-space programs. As odd as it might seem, 32-bit values (including all 32-bit registers) may not be pushed onto the stack.</p>
<p>POP</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode numberSource asm number-lines code-with-copy"><code class="sourceCode fasm"><span id="cb41-1"><a href="#cb41-1"></a><span class="bu">popfq</span> <span class="co">; pop 8bytes from the stack into RFlags </span></span>
<span id="cb41-2"><a href="#cb41-2"></a><span class="bu">pop</span> <span class="kw">rcx</span> </span>
<span id="cb41-3"><a href="#cb41-3"></a><span class="bu">pop</span> <span class="kw">bx</span> </span>
<span id="cb41-4"><a href="#cb41-4"></a><span class="bu">pop</span> <span class="op">[</span><span class="kw">rbx</span><span class="op">]</span> </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>PUSHA, PUSHAD, POPA, POPAD are gone in x64, though they are available in x86-32. These instructions were used to push or pop all of the general-purpose registers at once. They are removed likely due to that there are a lot more general-purpose registers in x64.</p>
<p>ABI: Application Binary Interface. It defines a collection of fundamental callable functions, generally supplied by the operating system, as is done in Linux. This definition describes how to pass parameters to the many kernel service functions. An ABI also defines how linkers link compiled or assembled modules into a single executable binary program.</p>
<p>RDI, RSI, RDX, R10,R8,R9 specifies a system call’s parameters. RAX is dedicated to the numeric code specifying the system call to be made.</p>
<p>The SYSCALL instruction itself makes use of RAX, RCX, and R11 internally. After the SYSCALL returns, you can’t assume that RAX, RCX or R11 will have the same values they did before the SYSCALL.</p>
<p>How to reserve bytes in .bss section in NASM. How to do it in gas?</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode numberSource asm number-lines code-with-copy"><code class="sourceCode fasm"><span id="cb42-1"><a href="#cb42-1"></a><span class="co">;nasm assembly </span></span>
<span id="cb42-2"><a href="#cb42-2"></a><span class="bu">section</span> <span class="op">.</span>bss</span>
<span id="cb42-3"><a href="#cb42-3"></a>Buff resb <span class="dv">1</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb43"><pre class="sourceCode numberSource asm number-lines code-with-copy"><code class="sourceCode fasm"><span id="cb43-1"><a href="#cb43-1"></a><span class="co">;gas assembly </span></span>
<span id="cb43-2"><a href="#cb43-2"></a>.bss </span>
<span id="cb43-3"><a href="#cb43-3"></a>.lcomm buff1<span class="op">,</span> <span class="dv">10</span> <span class="co">;reserve length bytes for a local common denoted by symbol. Symbol is not declared global, so normally it is not visible to ld. </span></span>
<span id="cb43-4"><a href="#cb43-4"></a>.comm buff2<span class="op">,</span> <span class="dv">10</span> <span class="co">;declares common symbol named symbol. </span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>jb and ja are for unsigned number, and jg and jl are for signed number</p>
<p>jb: jump if below</p>
<p>ja: jump if above</p>
<p>jg: jump if greater</p>
<p>jl: jump if lesser</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode numberSource asm number-lines code-with-copy"><code class="sourceCode fasm"><span id="cb44-1"><a href="#cb44-1"></a># upper<span class="op">.</span>s</span>
<span id="cb44-2"><a href="#cb44-2"></a># a program to convert user inputted char from lower case to upper case</span>
<span id="cb44-3"><a href="#cb44-3"></a>.<span class="bu">data</span></span>
<span id="cb44-4"><a href="#cb44-4"></a></span>
<span id="cb44-5"><a href="#cb44-5"></a>.bss</span>
<span id="cb44-6"><a href="#cb44-6"></a>.lcomm char<span class="op">,</span><span class="dv">1</span> <span class="op">#</span>local common buffer<span class="op">,</span> with the name <span class="op">`</span>char<span class="op">`,</span> <span class="dv">1</span> <span class="dt">byte</span> size</span>
<span id="cb44-7"><a href="#cb44-7"></a></span>
<span id="cb44-8"><a href="#cb44-8"></a>.text</span>
<span id="cb44-9"><a href="#cb44-9"></a>.global _start</span>
<span id="cb44-10"><a href="#cb44-10"></a></span>
<span id="cb44-11"><a href="#cb44-11"></a><span class="fu">_start:</span></span>
<span id="cb44-12"><a href="#cb44-12"></a>    <span class="bu">push</span> <span class="op">%</span><span class="kw">rbp</span></span>
<span id="cb44-13"><a href="#cb44-13"></a>    <span class="bu">mov</span> <span class="op">%</span><span class="kw">rsp</span><span class="op">,</span> <span class="op">%</span><span class="kw">rbp</span></span>
<span id="cb44-14"><a href="#cb44-14"></a></span>
<span id="cb44-15"><a href="#cb44-15"></a>    #read a char</span>
<span id="cb44-16"><a href="#cb44-16"></a>    <span class="bu">mov</span> <span class="op">$</span><span class="bn">0</span><span class="op">,</span> <span class="op">%</span><span class="kw">rax</span></span>
<span id="cb44-17"><a href="#cb44-17"></a>    <span class="bu">mov</span> <span class="op">$</span><span class="bn">0</span><span class="op">,</span> <span class="op">%</span><span class="kw">rdi</span></span>
<span id="cb44-18"><a href="#cb44-18"></a>    <span class="bu">lea</span> char<span class="op">,</span> <span class="op">%</span><span class="kw">rsi</span></span>
<span id="cb44-19"><a href="#cb44-19"></a>    <span class="bu">mov</span> <span class="op">$</span><span class="bn">1</span><span class="op">,</span> <span class="op">%</span><span class="kw">rdx</span></span>
<span id="cb44-20"><a href="#cb44-20"></a>    <span class="cf">syscall</span></span>
<span id="cb44-21"><a href="#cb44-21"></a></span>
<span id="cb44-22"><a href="#cb44-22"></a>    <span class="bu">lea</span> char<span class="op">,</span> <span class="op">%</span><span class="kw">rax</span> <span class="op">#</span>put the addr of char to <span class="op">%</span><span class="kw">rax</span></span>
<span id="cb44-23"><a href="#cb44-23"></a>    movb <span class="op">(%</span><span class="kw">rax</span><span class="op">),%</span><span class="kw">bl</span> <span class="op">#</span>put the <span class="dt">byte</span> value pointed by <span class="op">%</span><span class="kw">rax</span> to <span class="op">%</span><span class="kw">rbx</span></span>
<span id="cb44-24"><a href="#cb44-24"></a>    <span class="bu">cmp</span> <span class="op">$</span><span class="bn">0</span>x61<span class="op">,</span> <span class="op">%</span><span class="kw">bl</span> <span class="op">#</span>subtract <span class="bn">0x61</span> from <span class="op">%</span><span class="kw">bl</span> <span class="op">and</span> without changing <span class="op">%</span><span class="kw">rbx</span></span>
<span id="cb44-25"><a href="#cb44-25"></a>    <span class="cf">jb</span> do_not_change <span class="op">#</span>jump if below<span class="op">.</span> Note the diff between Intel <span class="op">and</span> AT<span class="op">&amp;</span>T syntax</span>
<span id="cb44-26"><a href="#cb44-26"></a>    <span class="bu">cmp</span> <span class="op">$</span><span class="bn">0</span>x7a<span class="op">,</span> <span class="op">%</span><span class="kw">bl</span></span>
<span id="cb44-27"><a href="#cb44-27"></a>    <span class="cf">ja</span> do_not_change</span>
<span id="cb44-28"><a href="#cb44-28"></a>    # convert the char to upper case</span>
<span id="cb44-29"><a href="#cb44-29"></a>    <span class="bu">sub</span> <span class="op">$</span><span class="bn">0</span>x20<span class="op">,</span> <span class="op">%</span><span class="kw">bl</span></span>
<span id="cb44-30"><a href="#cb44-30"></a>    movb <span class="op">%</span><span class="kw">bl</span><span class="op">,</span> <span class="op">(%</span><span class="kw">rax</span><span class="op">)</span> <span class="op">#</span>put the <span class="dt">byte</span> value in <span class="op">%</span><span class="kw">bl</span> to memory pointed by <span class="op">%</span><span class="kw">rax</span></span>
<span id="cb44-31"><a href="#cb44-31"></a><span class="fu">do_not_change:</span></span>
<span id="cb44-32"><a href="#cb44-32"></a></span>
<span id="cb44-33"><a href="#cb44-33"></a>    #write a char</span>
<span id="cb44-34"><a href="#cb44-34"></a>    <span class="bu">mov</span> <span class="op">$</span><span class="bn">1</span><span class="op">,</span> <span class="op">%</span><span class="kw">rax</span></span>
<span id="cb44-35"><a href="#cb44-35"></a>    <span class="bu">mov</span> <span class="op">$</span><span class="bn">1</span><span class="op">,</span> <span class="op">%</span><span class="kw">rdi</span></span>
<span id="cb44-36"><a href="#cb44-36"></a>    <span class="bu">lea</span> char<span class="op">,</span> <span class="op">%</span><span class="kw">rsi</span></span>
<span id="cb44-37"><a href="#cb44-37"></a>    <span class="bu">mov</span> <span class="op">$</span><span class="bn">1</span><span class="op">,</span> <span class="op">%</span><span class="kw">rdx</span></span>
<span id="cb44-38"><a href="#cb44-38"></a>    <span class="cf">syscall</span></span>
<span id="cb44-39"><a href="#cb44-39"></a></span>
<span id="cb44-40"><a href="#cb44-40"></a>    #exit the program</span>
<span id="cb44-41"><a href="#cb44-41"></a>    <span class="bu">mov</span> <span class="op">$</span><span class="bn">60</span><span class="op">,</span> <span class="op">%</span><span class="kw">rax</span> <span class="op">#</span>syscall number</span>
<span id="cb44-42"><a href="#cb44-42"></a>    <span class="bu">mov</span> <span class="op">$</span><span class="bn">42</span><span class="op">,</span> <span class="op">%</span><span class="kw">rdi</span> <span class="op">#</span>exit code</span>
<span id="cb44-43"><a href="#cb44-43"></a>    <span class="cf">syscall</span></span>
<span id="cb44-44"><a href="#cb44-44"></a></span>
<span id="cb44-45"><a href="#cb44-45"></a>    <span class="bu">pop</span> <span class="op">%</span><span class="kw">rbp</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Use the commands below to build the above program.</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode numberSource bash number-lines code-with-copy"><code class="sourceCode bash"><span id="cb45-1"><a href="#cb45-1"></a><span class="fu">as</span> <span class="at">-g</span> <span class="at">-o</span> upper.o upper.s</span>
<span id="cb45-2"><a href="#cb45-2"></a><span class="fu">ld</span> <span class="at">-o</span> upper upper.o</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>In the above program, we should pay attention to the below facts.</p>
<ul>
<li>The way to declare buffer in .bss segment via <code>.lcomm</code> or <code>.comm</code></li>
<li>When using the <code>lea</code>, there is not <code>$</code> prefix in front of the label. When using the <code>mov</code>, there is <code>$</code> prefix.</li>
<li>To refer to memory, put the memory address between parentheses <code>movl  0x20(%ebx),%eax</code> or <code>movl (%ebx),%eax</code></li>
<li>When using the sub and cmp instructions, pay attention to the differences between AT&amp;T syntax and Intel syntax.</li>
<li>The AT&amp;T syntax mnenomics have a suffix, movb, movw, movl, movq.</li>
</ul>
<div class="sourceCode" id="cb46"><pre class="sourceCode numberSource asm number-lines code-with-copy"><code class="sourceCode fasm"><span id="cb46-1"><a href="#cb46-1"></a>movb <span class="op">%</span><span class="kw">bl</span><span class="op">,</span> <span class="op">%</span><span class="kw">al</span> </span>
<span id="cb46-2"><a href="#cb46-2"></a>movw <span class="op">%</span><span class="kw">bx</span><span class="op">,</span> <span class="op">%</span><span class="kw">ax</span> </span>
<span id="cb46-3"><a href="#cb46-3"></a>movl <span class="op">%</span><span class="kw">ebx</span><span class="op">,</span> <span class="op">%</span><span class="kw">eax</span> </span>
<span id="cb46-4"><a href="#cb46-4"></a><span class="bu">movq</span> <span class="op">%</span><span class="kw">rbx</span><span class="op">,</span> <span class="op">%</span><span class="kw">rax</span> </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="chap9-bits-flags-branches-and-tables-easing-into-mainstream-assembly-coding" class="level2">
<h2 class="anchored" data-anchor-id="chap9-bits-flags-branches-and-tables-easing-into-mainstream-assembly-coding">Chap9 Bits, Flags, Branches, and Tables, Easing Into Mainstream Assembly Coding</h2>
<p>Instructions: SHL, SHR, ROL, ROR, RCL, RCR, AND, OR, XOR, NOT, JC, JNC, STC, CLC, JMP, JZ, JNZ, CMP, TEST, BT, JA, JAE, JB, JBE, JE, JNE, JG, JGE, JL, JLE, JNBE, JNLE, XLAT</p>
<p>Bits in assembly language are numbered, starting from 0. The least significant bit is the one with the least value in the binary number system. When you count bits, start with the bits on the right-hand end, and number them leftward from 0.</p>
<p>Note: CS, DS, SS, ES segment registers are not GP(general purpose) registers.</p>
<p>In x64, the shift instructions require ether a immediate value from 0-255 or CL(CL instead of CX, ECX, RCX).</p>
<p>Shifting by 0 is pointless but allowed.</p>
<p>You cannot shift more positions than the destination register has. In 64-bit long mode, you cannot shift more than 63 counts. Attempting to do so won’t trigger an error. It just won’t work. CPU masks the count value to the 6 lowest bits before the instruction is executed.</p>
<p>In 32-bit protected mode, CPU masks the count values to the 5 lowest bits.</p>
<p>Shifting a bit off the left end of a binary value doesn’t exactly send that bit into cosmic nothingness. A bit shifted out of the left end of a binary value is bumped into a temporary bucket for bits called the CF(Carry Flag). We can test the state of the CF with a branching instruction(JC, JNC).</p>
<p>JC: Jump if Carry</p>
<p>JNC: Jump if Not Carry</p>
<p>JZ: Jump if Zero</p>
<p>JNZ: Jump if not Zero</p>
<p>JMP: Jump</p>
<p>If you shift a bit into the CF, and then immediately execute another shift operation, the bit bumped into the CF earlier will be bumped off the end of the world into cosmic nothingness.</p>
<p>If a bit’s destiny is not to be lost in cosmic nothingness, you need to use the rotate instructions RCL(Rotate Carry Left), RCR(Rotate Carry Right), ROL(Rotate Left) and ROR(Rotate Right). A bit bumped off one end of the operand reappears at the opposite end of the operand.</p>
<p>STC: Set Carry bit</p>
<p>CLC: Clear Carry bit</p>
<p>CF, Carry Flag</p>
<p>ZF, Zero Flag</p>
<p>SF, Sign Flag</p>
<p>DF, Direction Flag</p>
<p>OF, Overflow Flag</p>
<p>BT, Bit Test, it copies the specific bit in the first operand into the CF.</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode numberSource asm number-lines code-with-copy"><code class="sourceCode fasm"><span id="cb47-1"><a href="#cb47-1"></a><span class="co">;intel syntax </span></span>
<span id="cb47-2"><a href="#cb47-2"></a><span class="co">;check the 4th bits of rax, counting from 0 </span></span>
<span id="cb47-3"><a href="#cb47-3"></a><span class="bu">bt</span> <span class="kw">rax</span><span class="op">,</span><span class="dv">4</span></span>
<span id="cb47-4"><a href="#cb47-4"></a><span class="cf">jnc</span> quit <span class="co">; jump if the 4th bit is not 1 </span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>X86-64 long mode memory addressing.</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode numberSource asm number-lines code-with-copy"><code class="sourceCode fasm"><span id="cb48-1"><a href="#cb48-1"></a><span class="co">;BASE can be any GP register </span></span>
<span id="cb48-2"><a href="#cb48-2"></a><span class="co">;INDEX can be any GP register </span></span>
<span id="cb48-3"><a href="#cb48-3"></a><span class="co">;SCALE can be 1,2,4,8</span></span>
<span id="cb48-4"><a href="#cb48-4"></a><span class="co">;DISP(displacement) can be any 32bit constant</span></span>
<span id="cb48-5"><a href="#cb48-5"></a>BASE <span class="op">+</span> <span class="op">(</span>INDEX <span class="op">*</span> SCALE<span class="op">)</span> <span class="op">+</span> DISP</span>
<span id="cb48-6"><a href="#cb48-6"></a><span class="co">;example in intel syntax </span></span>
<span id="cb48-7"><a href="#cb48-7"></a>[rsi <span class="op">+</span> <span class="kw">rbp</span><span class="op">*</span><span class="dv">4</span> <span class="op">+</span> <span class="dv">9</span><span class="op">]</span></span>
<span id="cb48-8"><a href="#cb48-8"></a><span class="co">;example in AT&amp;T syntax </span></span>
<span id="cb48-9"><a href="#cb48-9"></a>jmpq <span class="op">*</span><span class="bn">0x402680</span><span class="op">(%</span><span class="kw">rbp</span><span class="op">,%</span><span class="kw">rax</span><span class="op">,</span><span class="dv">8</span><span class="op">)</span> </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>LEA has a off-label purpose: doing fast math without shifts, adds or MUL.</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode numberSource asm number-lines code-with-copy"><code class="sourceCode fasm"><span id="cb49-1"><a href="#cb49-1"></a><span class="co">;intex syntax </span></span>
<span id="cb49-2"><a href="#cb49-2"></a><span class="co">;multiply rdx by 3 </span></span>
<span id="cb49-3"><a href="#cb49-3"></a><span class="bu">lea</span> <span class="kw">rdx</span><span class="op">,[</span><span class="kw">rdx</span><span class="op">*</span><span class="dv">2</span><span class="op">+</span><span class="kw">rdx</span><span class="op">]</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="chap10-dividing-and-conquering-using-procedures-and-macros-to-battle-program-complexity" class="level2">
<h2 class="anchored" data-anchor-id="chap10-dividing-and-conquering-using-procedures-and-macros-to-battle-program-complexity">Chap10 Dividing and Conquering: Using procedures and macros to battle program complexity</h2>
<p>A procedure must begin with a label.</p>
<p>Somewhere within the procedure, there must be at least one <code>ret</code> instruction.</p>
<p>A procedure may use <code>call</code> to call another procedure.</p>
<p>CALL first push the address of the next instruction after itself onto the stack. Then CALL transfers the execution to the address represented by the label that names the procedure. The instructions contained in the procedure execute. The RET instruction pops the return address off the top of the stack and transfers execution to that address. Execution continues as though CALL had not changed the flow of instruction execution at all.</p>
<p>There is a convention for which registers must be preserved within a procedure and which do not. This convention is part of the x86-64 System V ABI(Application Binary Interface). Some registers are considered volatile, meaning that they can be changed by a procedure, and others are nonvolatile, which means they must be preserved.</p>
<p>Linux uses registers, too. It is serious knowing what registers are changed during system calls via the SYSCALL instruction. There is no simple answer. It depends completely on which system call you make. But first and above all, the SYSCALL instruction itself makes use of 2 registers:</p>
<p>SYSCALL stores return address in the RCX register.</p>
<p>SYSCALL stores RFlags in the R11 register.</p>
<p>Everytime you execute SYSCALL, RCS and R11 will be clobbered.</p>
<p>The system call number (in other words, which system call you’re calling) is always in RAX. A system call will accept up to six parameters. The registers used to pass parameters are in this order: RDI, RSI, RDX, R10, R8, and R9. In other words, the first parameter is passed in RDI. The second parameter is passed in RSI, and so on. No system call requires any parameters be passed to it on the stack.</p>
<p>Note: Whether or not a register (like R9, say) is used to pass a parameter to a system call, that register is not preserved. Only seven registers are preserved by Linux across a system call: R12, R13, R14, R15, RBX, RSP, and RBP.</p>
<p>After a SYSCALL, RAX will contain a return value. If RAX is negative, it indicates an error occurred during the call. For most system calls, a 0 value indicates success.</p>
<p>Note: PUSHA, POPA, PUSHAD, POPAD are not available in x86-64.</p>
<p>Sooner or later, you are going to accidentally reuse a label.</p>
<p>This is a common enough problem that NASM’s authors created a feature to deal with it: local labels. Local labels are based on the fact that nearly all labels in assembly work (outside of names of subroutines and major sections) are “local” in nature, by which I mean that they are only referenced by jump instructions that are very close to them—perhaps only two or three instructions away.</p>
<p>Note: NASM and Gas may have different syntax for local labels. And it seems local labels and local symbols mean different things in GAS. Refer to <a href="https://sourceware.org/binutils/docs/as/Symbol-Names.html">as symbol-names</a></p>
<p>For NASM: Note that the label .modTest has a period in front of it. This period marks it as a local label. A local label is local to the first nonlocal label (that is, the first label not prefixed by a period; we call these global) that precedes it in the code.</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode numberSource asm number-lines code-with-copy"><code class="sourceCode fasm"><span id="cb50-1"><a href="#cb50-1"></a><span class="co">; Go through the buffer and convert binary byte values to hex digits:</span></span>
<span id="cb50-2"><a href="#cb50-2"></a><span class="fu">Scan:</span></span>
<span id="cb50-3"><a href="#cb50-3"></a><span class="bu">xor</span> <span class="kw">rax</span><span class="op">,</span><span class="kw">rax</span> <span class="co">; Clear RAX to 0</span></span>
<span id="cb50-4"><a href="#cb50-4"></a><span class="bu">mov</span> <span class="kw">al</span><span class="op">,[</span>Buff<span class="op">+</span><span class="kw">rcx</span><span class="op">]</span> <span class="co">; Get a byte from the buffer into AL</span></span>
<span id="cb50-5"><a href="#cb50-5"></a><span class="bu">mov</span> <span class="kw">rdx</span><span class="op">,</span><span class="kw">rsi</span> <span class="co">; Copy total counter into RDX</span></span>
<span id="cb50-6"><a href="#cb50-6"></a><span class="bu">and</span> <span class="kw">rdx</span><span class="op">,</span><span class="dv">000000000000000</span><span class="er">Fh</span> <span class="co">; Mask out lowest 4 bits of char counter</span></span>
<span id="cb50-7"><a href="#cb50-7"></a><span class="cf">call</span> DumpChar <span class="co">; Call the char poke procedure</span></span>
<span id="cb50-8"><a href="#cb50-8"></a><span class="co">; Bump the buffer pointer to the next char and see if buffer's done:</span></span>
<span id="cb50-9"><a href="#cb50-9"></a><span class="bu">inc</span> <span class="kw">rsi</span> <span class="co">; Increment total chars processed counter</span></span>
<span id="cb50-10"><a href="#cb50-10"></a><span class="bu">inc</span> <span class="kw">rcx</span> <span class="co">; Increment buffer pointer</span></span>
<span id="cb50-11"><a href="#cb50-11"></a><span class="bu">cmp</span> <span class="kw">rcx</span><span class="op">,</span><span class="kw">r15</span> <span class="co">; Compare with # of chars in buffer</span></span>
<span id="cb50-12"><a href="#cb50-12"></a><span class="cf">jb</span> <span class="op">.</span>modTest <span class="co">; If we've processed all chars in buffer...</span></span>
<span id="cb50-13"><a href="#cb50-13"></a><span class="cf">call</span> LoadBuff <span class="co">; ...go fill the buffer again</span></span>
<span id="cb50-14"><a href="#cb50-14"></a><span class="bu">cmp</span> <span class="kw">r15</span><span class="op">,</span><span class="dv">0</span> <span class="co">; If r15=0, sys_read reached EOF on stdin</span></span>
<span id="cb50-15"><a href="#cb50-15"></a><span class="cf">jbe</span> Done <span class="co">; If we get EOF, we're done</span></span>
<span id="cb50-16"><a href="#cb50-16"></a><span class="co">; See if we're at the end of a block of 16 and need to display a line:</span></span>
<span id="cb50-17"><a href="#cb50-17"></a><span class="fu">.modTest:</span></span>
<span id="cb50-18"><a href="#cb50-18"></a><span class="bu">test</span> <span class="kw">rsi</span><span class="op">,</span><span class="dv">000000000000000</span><span class="er">Fh</span> <span class="co">; Test 4 lowest bits in counter for 0</span></span>
<span id="cb50-19"><a href="#cb50-19"></a><span class="cf">jnz</span> Scan <span class="co">; If counter is *not* modulo 16, loop back</span></span>
<span id="cb50-20"><a href="#cb50-20"></a><span class="cf">call</span> PrintLine <span class="co">; ...otherwise print the line</span></span>
<span id="cb50-21"><a href="#cb50-21"></a><span class="cf">call</span> ClearLine <span class="co">; Clear hex dump line to 0's</span></span>
<span id="cb50-22"><a href="#cb50-22"></a><span class="cf">jmp</span> Scan <span class="co">; Continue scanning the buffer</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Local labels can also be called in the nested way as shown below in NASM. In a sense, under the covers, a local label is just the “tail” of a global label.</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode numberSource asm number-lines code-with-copy"><code class="sourceCode fasm"><span id="cb51-1"><a href="#cb51-1"></a><span class="cf">jne</span> Calc<span class="op">.</span>modTest</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>For GAS: Local labels are different from local symbols. Local labels help compilers and programmers use names temporarily. They create symbols which are guaranteed to be unique over the entire scope of the input source code and which can be referred to by a simple notation. To define a local label, write a label of the form ‘N:’ (where N represents any non-negative integer). To refer to the most recent previous definition of that label write ‘Nb’, using the same number as when you defined the label. To refer to the next definition of a local label, write ‘Nf’. The ‘b’ stands for “backwards” and the ‘f’ stands for “forwards”.</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode numberSource asm number-lines code-with-copy"><code class="sourceCode fasm"><span id="cb52-1"><a href="#cb52-1"></a>Here is an example<span class="op">:</span></span>
<span id="cb52-2"><a href="#cb52-2"></a></span>
<span id="cb52-3"><a href="#cb52-3"></a>1:        branch <span class="fl">1</span><span class="bn">f</span></span>
<span id="cb52-4"><a href="#cb52-4"></a>2:        branch <span class="bn">1b</span></span>
<span id="cb52-5"><a href="#cb52-5"></a>1:        branch <span class="fl">2</span><span class="bn">f</span></span>
<span id="cb52-6"><a href="#cb52-6"></a>2:        branch <span class="bn">1b</span></span>
<span id="cb52-7"><a href="#cb52-7"></a>Which is the equivalent of<span class="op">:</span></span>
<span id="cb52-8"><a href="#cb52-8"></a></span>
<span id="cb52-9"><a href="#cb52-9"></a><span class="fu">label_1:</span>  branch label_3</span>
<span id="cb52-10"><a href="#cb52-10"></a><span class="fu">label_2:</span>  branch label_1</span>
<span id="cb52-11"><a href="#cb52-11"></a><span class="fu">label_3:</span>  branch label_4</span>
<span id="cb52-12"><a href="#cb52-12"></a><span class="fu">label_4:</span>  branch label_3</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This is a real GAS example from <a href="https://stackoverflow.com/questions/63874455/how-to-translate-gas-1-in-nasm-assembly">stackoverflow</a>:</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode numberSource asm number-lines code-with-copy"><code class="sourceCode fasm"><span id="cb53-1"><a href="#cb53-1"></a><span class="fu">_pg_dir:</span></span>
<span id="cb53-2"><a href="#cb53-2"></a><span class="fu">startup_32:</span></span>
<span id="cb53-3"><a href="#cb53-3"></a>    movl <span class="op">$</span><span class="bn">0</span>x10<span class="op">,%</span><span class="kw">eax</span></span>
<span id="cb53-4"><a href="#cb53-4"></a>    <span class="bu">mov</span> <span class="op">%</span><span class="kw">ax</span><span class="op">,%</span><span class="kw">ds</span></span>
<span id="cb53-5"><a href="#cb53-5"></a>    <span class="bu">mov</span> <span class="op">%</span><span class="kw">ax</span><span class="op">,%</span><span class="kw">es</span></span>
<span id="cb53-6"><a href="#cb53-6"></a>    <span class="bu">mov</span> <span class="op">%</span><span class="kw">ax</span><span class="op">,%</span><span class="kw">fs</span></span>
<span id="cb53-7"><a href="#cb53-7"></a>    <span class="bu">mov</span> <span class="op">%</span><span class="kw">ax</span><span class="op">,%</span><span class="kw">gs</span></span>
<span id="cb53-8"><a href="#cb53-8"></a>    <span class="bu">lss</span> _stack_start<span class="op">,%</span><span class="kw">esp</span></span>
<span id="cb53-9"><a href="#cb53-9"></a>    <span class="cf">call</span> setup_idt</span>
<span id="cb53-10"><a href="#cb53-10"></a>    <span class="cf">call</span> setup_gdt</span>
<span id="cb53-11"><a href="#cb53-11"></a>    movl <span class="op">$</span><span class="bn">0</span>x10<span class="op">,%</span><span class="kw">eax</span>     <span class="op">#</span> reload all the segment registers</span>
<span id="cb53-12"><a href="#cb53-12"></a>    <span class="bu">mov</span> <span class="op">%</span><span class="kw">ax</span><span class="op">,%</span><span class="kw">ds</span>     <span class="op">#</span> after changing gdt<span class="op">.</span> <span class="kw">CS</span> was already</span>
<span id="cb53-13"><a href="#cb53-13"></a>    <span class="bu">mov</span> <span class="op">%</span><span class="kw">ax</span><span class="op">,%</span><span class="kw">es</span>     <span class="op">#</span> reloaded in <span class="st">'setup_gdt'</span></span>
<span id="cb53-14"><a href="#cb53-14"></a>    <span class="bu">mov</span> <span class="op">%</span><span class="kw">ax</span><span class="op">,%</span><span class="kw">fs</span></span>
<span id="cb53-15"><a href="#cb53-15"></a>    <span class="bu">mov</span> <span class="op">%</span><span class="kw">ax</span><span class="op">,%</span><span class="kw">gs</span></span>
<span id="cb53-16"><a href="#cb53-16"></a>    <span class="bu">lss</span> _stack_start<span class="op">,%</span><span class="kw">esp</span></span>
<span id="cb53-17"><a href="#cb53-17"></a>    xorl <span class="op">%</span><span class="kw">eax</span><span class="op">,%</span><span class="kw">eax</span></span>
<span id="cb53-18"><a href="#cb53-18"></a>1:  incl <span class="op">%</span><span class="kw">eax</span>       <span class="op">#</span> check that A20 really IS enabled  <span class="op">~~~</span></span>
<span id="cb53-19"><a href="#cb53-19"></a>    movl <span class="op">%</span><span class="kw">eax</span><span class="op">,</span><span class="bn">0x000000</span></span>
<span id="cb53-20"><a href="#cb53-20"></a>    cmpl <span class="op">%</span><span class="kw">eax</span><span class="op">,</span><span class="bn">0x100000</span></span>
<span id="cb53-21"><a href="#cb53-21"></a>    <span class="cf">je</span> <span class="bn">1b</span>                                             <span class="op">~~~</span></span>
<span id="cb53-22"><a href="#cb53-22"></a>    movl <span class="op">%</span><span class="kw">cr0</span><span class="op">,%</span><span class="kw">eax</span>      <span class="op">#</span> check math chip</span>
<span id="cb53-23"><a href="#cb53-23"></a>    andl <span class="op">$</span><span class="bn">0</span>x80000011<span class="op">,%</span><span class="kw">eax</span>   <span class="op">#</span> Save PG<span class="op">,</span>ET<span class="op">,</span>PE</span>
<span id="cb53-24"><a href="#cb53-24"></a>    testl <span class="op">$</span><span class="bn">0</span>x10<span class="op">,%</span><span class="kw">eax</span></span>
<span id="cb53-25"><a href="#cb53-25"></a>    <span class="cf">jne</span> <span class="fl">1</span><span class="bn">f</span>          <span class="op">#</span> ET is set <span class="op">-</span> <span class="dv">387</span> is present      <span class="op">~~~</span></span>
<span id="cb53-26"><a href="#cb53-26"></a>    orl <span class="op">$</span><span class="bn">4</span><span class="op">,%</span><span class="kw">eax</span>     <span class="op">#</span> else set emulate bit</span>
<span id="cb53-27"><a href="#cb53-27"></a>1:  movl <span class="op">%</span><span class="kw">eax</span><span class="op">,%</span><span class="kw">cr0</span>                                    <span class="op">~~~</span></span>
<span id="cb53-28"><a href="#cb53-28"></a><span class="cf">jmp</span> after_page_tables</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>short, near, far jumps:</p>
<p>A jump target that lies within 127 bytes of the conditional jump instruction is called a short jump. A jump target that is further away than 127 bytes but still within the current code segment is called a near jump.</p>
<p>There is a third kind of jump called a far jump, which involves leaving the current code segment entirely for whatever reason. In the old DOS real‐mode world, this meant specifying both a segment address and an offset address for the jump target. Far jumps were not used very often. In the 32‐bit protected mode and 64‐bit long mode, far jumps are extremely rare and involve all sorts of operating system complexity that I can’t go into in this book.</p>
<p>The problem really lies with the difference between short and near jumps. A short conditional jump instruction generates a short—and hence compact—binary opcode. Short jump opcodes are always two bytes in size, no more. Near jump opcodes are either four or six bytes in size, depending on various factors.</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode numberSource asm number-lines code-with-copy"><code class="sourceCode fasm"><span id="cb54-1"><a href="#cb54-1"></a><span class="cf">jne</span> Scan <span class="co">; Jump within 127 bytes in either direction</span></span>
<span id="cb54-2"><a href="#cb54-2"></a><span class="cf">jne</span> <span class="op">near</span> Scan <span class="co">; Jump anywhere in the current code segment</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Once you create library files containing procedures, there are two ways to use them: - A library file can be assembled separately to a .o file, which in turn can be linked by the Linux linker into other programs that you may write in the future. - A library file can be included in the source code file of the main program, using a directive called <code>%INCLUDE</code>. This is what you must do to use libraries from programs written within SASM.</p>
<p>The very heart of programming in modules is “putting off” resolution of addresses until link time.</p>
<p>Declare a procedure external.</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode numberSource asm number-lines code-with-copy"><code class="sourceCode fasm"><span id="cb55-1"><a href="#cb55-1"></a>EXTERN myProc </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Over in the other module where procedure MyProc is actually defined, it isn’t enough just to define the procedure. An eyelet needs a hook. You have to warn the assembler that MyProc will be referenced from outside the module. The assembler needs to forge the hook that will hook into the eyelet. You forge the hook by declaring the procedure <code>global</code>, meaning that other modules anywhere else in the program may freely reference the procedure.</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode numberSource asm number-lines code-with-copy"><code class="sourceCode fasm"><span id="cb56-1"><a href="#cb56-1"></a>GLOBAL myProc </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>In GAS:</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode numberSource asm number-lines code-with-copy"><code class="sourceCode fasm"><span id="cb57-1"><a href="#cb57-1"></a>.exern myProc </span>
<span id="cb57-2"><a href="#cb57-2"></a>.global myProc </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>A procedure that is declared as GLOBAL where it is defined may be referenced from anywhere its label is declared as EXTERN.</p>
<p>What works for procedures works for data as well, and it can work in either direction. Your program can declare any named variable as GLOBAL, and that variable may then be used by any module in which the same variable name is declared as external with the EXTERN directive.</p>
<p>defining Macro in NASM:</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode numberSource asm number-lines code-with-copy"><code class="sourceCode fasm"><span id="cb58-1"><a href="#cb58-1"></a>%<span class="pp">macro</span> ExitProg <span class="dv">0</span></span>
<span id="cb58-2"><a href="#cb58-2"></a><span class="bu">mov</span> <span class="kw">rsp</span><span class="op">,</span><span class="kw">rbp</span> <span class="co">; Stack alignment epilog</span></span>
<span id="cb58-3"><a href="#cb58-3"></a><span class="bu">pop</span> <span class="kw">rbp</span></span>
<span id="cb58-4"><a href="#cb58-4"></a><span class="bu">mov</span> <span class="kw">rax</span><span class="op">,</span><span class="dv">60</span> <span class="co">; 60 = exit the program</span></span>
<span id="cb58-5"><a href="#cb58-5"></a><span class="bu">mov</span> <span class="kw">rdi</span><span class="op">,</span><span class="dv">0</span> <span class="co">; Return value in rdi 0 = nothing to return</span></span>
<span id="cb58-6"><a href="#cb58-6"></a><span class="cf">syscall</span> <span class="co">; Call syscall sys_exit to return to Linux</span></span>
<span id="cb58-7"><a href="#cb58-7"></a>%endmacro</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Macros with parameters.</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode numberSource asm number-lines code-with-copy"><code class="sourceCode fasm"><span id="cb59-1"><a href="#cb59-1"></a>%<span class="pp">macro</span> WriteCtr <span class="dv">3</span> <span class="co">; %1 = row; %2 = String addr; %3 = String length</span></span>
<span id="cb59-2"><a href="#cb59-2"></a><span class="bu">push</span> <span class="kw">rbx</span> <span class="co">; Save caller's RBX</span></span>
<span id="cb59-3"><a href="#cb59-3"></a><span class="bu">push</span> <span class="kw">rdx</span> <span class="co">; Save caller's RDX</span></span>
<span id="cb59-4"><a href="#cb59-4"></a><span class="bu">mov</span> <span class="kw">rdx</span><span class="op">,%</span><span class="dv">3</span> <span class="co">; Load string length into RDX</span></span>
<span id="cb59-5"><a href="#cb59-5"></a><span class="bu">xor</span> <span class="kw">rbx</span><span class="op">,</span><span class="kw">rbx</span> <span class="co">; Zero RBX</span></span>
<span id="cb59-6"><a href="#cb59-6"></a><span class="bu">mov</span> <span class="kw">bl</span><span class="op">,</span>SCRWIDTH <span class="co">; Load the screen width value to BL</span></span>
<span id="cb59-7"><a href="#cb59-7"></a><span class="bu">sub</span> <span class="kw">bl</span><span class="op">,</span><span class="kw">dl</span> <span class="co">; Calc diff. of screen width and string length</span></span>
<span id="cb59-8"><a href="#cb59-8"></a><span class="bu">shr</span> <span class="kw">bl</span><span class="op">,</span><span class="dv">1</span> <span class="co">; Divide difference by two for X value</span></span>
<span id="cb59-9"><a href="#cb59-9"></a>GotoXY <span class="kw">bl</span><span class="op">,%</span><span class="dv">1</span> <span class="co">; Position the cursor for display</span></span>
<span id="cb59-10"><a href="#cb59-10"></a>WriteStr <span class="op">%</span><span class="dv">2</span><span class="op">,%</span><span class="dv">3</span> <span class="co">; Write the string to the console</span></span>
<span id="cb59-11"><a href="#cb59-11"></a><span class="bu">pop</span> <span class="kw">rdx</span> <span class="co">; Restore caller's RDX</span></span>
<span id="cb59-12"><a href="#cb59-12"></a><span class="bu">pop</span> <span class="kw">rbx</span> <span class="co">; Restore caller's RBX</span></span>
<span id="cb59-13"><a href="#cb59-13"></a>%endmacro</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Call a macro</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode numberSource asm number-lines code-with-copy"><code class="sourceCode fasm"><span id="cb60-1"><a href="#cb60-1"></a>WriteCtr <span class="kw">al</span><span class="op">,</span>AdMsg<span class="op">,</span>ADLEN</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>All labels defined within a macro are considered local to the macro and are handled specially by the assembler. A label in a macro is made local by beginning it with two percent symbols: %%.</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode numberSource asm number-lines code-with-copy"><code class="sourceCode fasm"><span id="cb61-1"><a href="#cb61-1"></a>%<span class="pp">macro</span> UpCase <span class="dv">2</span> <span class="co">; %1 = Address of buffer; %2 = Chars in buffer</span></span>
<span id="cb61-2"><a href="#cb61-2"></a><span class="bu">mov</span> <span class="kw">rdx</span><span class="op">,%</span><span class="dv">1</span> <span class="co">; Place the offset of the buffer into rdx</span></span>
<span id="cb61-3"><a href="#cb61-3"></a><span class="bu">mov</span> <span class="kw">rcx</span><span class="op">,%</span><span class="dv">2</span> <span class="co">; Place the number of bytes in the buffer into rcx</span></span>
<span id="cb61-4"><a href="#cb61-4"></a><span class="fu">%%IsLC:</span><span class="bu">cmp</span> <span class="dt">byte</span> <span class="op">[</span><span class="kw">rdx</span><span class="op">+</span>rcx‐<span class="dv">1</span><span class="op">],</span><span class="st">'</span></span>
<span id="cb61-5"><a href="#cb61-5"></a>a<span class="st">' ; Below '</span>a<span class="st">'?</span></span>
<span id="cb61-6"><a href="#cb61-6"></a><span class="cf">jb</span> <span class="op">%%</span>Bump <span class="co">; Not lowercase. Skip</span></span>
<span id="cb61-7"><a href="#cb61-7"></a><span class="bu">cmp</span> <span class="dt">byte</span> <span class="op">[</span><span class="kw">rdx</span><span class="op">+</span>rcx‐<span class="dv">1</span><span class="op">],</span><span class="st">'</span></span>
<span id="cb61-8"><a href="#cb61-8"></a>z<span class="st">' ; Above '</span>z<span class="st">'?</span></span>
<span id="cb61-9"><a href="#cb61-9"></a><span class="cf">ja</span> <span class="op">%%</span>Bump <span class="co">; Not lowercase. Skip</span></span>
<span id="cb61-10"><a href="#cb61-10"></a><span class="bu">sub</span> <span class="dt">byte</span> <span class="op">[</span><span class="kw">rdx</span><span class="op">+</span>rcx‐<span class="dv">1</span><span class="op">],</span></span>
<span id="cb61-11"><a href="#cb61-11"></a>20h <span class="co">; Force byte in buffer to uppercase</span></span>
<span id="cb61-12"><a href="#cb61-12"></a><span class="fu">%%Bump:</span><span class="bu">dec</span> <span class="kw">rcx</span> <span class="co">; Decrement character count</span></span>
<span id="cb61-13"><a href="#cb61-13"></a><span class="cf">jnz</span> <span class="op">%%</span>IsLC <span class="co">; If more chars in the buffer, repeat</span></span>
<span id="cb61-14"><a href="#cb61-14"></a>%endmacro</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>GAS define macros, refer to <a href="https://ftp.gnu.org/old-gnu/Manuals/gas-2.9.1/html_node/as_107.html">macros in GAS</a></p>
<div class="sourceCode" id="cb62"><pre class="sourceCode numberSource asm number-lines code-with-copy"><code class="sourceCode fasm"><span id="cb62-1"><a href="#cb62-1"></a>.<span class="bu">section</span> <span class="op">.</span>data</span>
<span id="cb62-2"><a href="#cb62-2"></a></span>
<span id="cb62-3"><a href="#cb62-3"></a>   <span class="fu">prompt_str:</span></span>
<span id="cb62-4"><a href="#cb62-4"></a>      .ascii <span class="st">"Enter Your Name: "</span></span>
<span id="cb62-5"><a href="#cb62-5"></a>   <span class="fu">pstr_end:</span></span>
<span id="cb62-6"><a href="#cb62-6"></a>      .<span class="bu">set</span> STR_SIZE<span class="op">,</span> pstr_end <span class="op">-</span> prompt_str</span>
<span id="cb62-7"><a href="#cb62-7"></a></span>
<span id="cb62-8"><a href="#cb62-8"></a>   <span class="fu">greet_str:</span></span>
<span id="cb62-9"><a href="#cb62-9"></a>      .ascii <span class="st">"Hello "</span></span>
<span id="cb62-10"><a href="#cb62-10"></a></span>
<span id="cb62-11"><a href="#cb62-11"></a>   <span class="fu">gstr_end:</span></span>
<span id="cb62-12"><a href="#cb62-12"></a>      .<span class="bu">set</span> GSTR_SIZE<span class="op">,</span> gstr_end <span class="op">-</span> greet_str</span>
<span id="cb62-13"><a href="#cb62-13"></a></span>
<span id="cb62-14"><a href="#cb62-14"></a>.<span class="bu">section</span> <span class="op">.</span>bss</span>
<span id="cb62-15"><a href="#cb62-15"></a></span>
<span id="cb62-16"><a href="#cb62-16"></a>// Reserve <span class="dv">32</span> bytes of memory</span>
<span id="cb62-17"><a href="#cb62-17"></a>   .lcomm  buff<span class="op">,</span> <span class="dv">32</span></span>
<span id="cb62-18"><a href="#cb62-18"></a></span>
<span id="cb62-19"><a href="#cb62-19"></a>// A macro with two parameters</span>
<span id="cb62-20"><a href="#cb62-20"></a>//  implements the write system call</span>
<span id="cb62-21"><a href="#cb62-21"></a>   .<span class="pp">macro</span> write str<span class="op">,</span> str_size </span>
<span id="cb62-22"><a href="#cb62-22"></a>      movl  <span class="op">$</span><span class="bn">4</span><span class="op">,</span> <span class="op">%</span><span class="kw">eax</span></span>
<span id="cb62-23"><a href="#cb62-23"></a>      movl  <span class="op">$</span><span class="bn">1</span><span class="op">,</span> <span class="op">%</span><span class="kw">ebx</span></span>
<span id="cb62-24"><a href="#cb62-24"></a>      movl  <span class="op">\</span>str<span class="op">,</span> <span class="op">%</span><span class="kw">ecx</span></span>
<span id="cb62-25"><a href="#cb62-25"></a>      movl  <span class="op">\</span>str_size<span class="op">,</span> <span class="op">%</span><span class="kw">edx</span></span>
<span id="cb62-26"><a href="#cb62-26"></a>      <span class="bu">int</span>   <span class="op">$</span><span class="bn">0</span>x80</span>
<span id="cb62-27"><a href="#cb62-27"></a>   .endm</span>
<span id="cb62-28"><a href="#cb62-28"></a></span>
<span id="cb62-29"><a href="#cb62-29"></a></span>
<span id="cb62-30"><a href="#cb62-30"></a>// Implements the read system call</span>
<span id="cb62-31"><a href="#cb62-31"></a>   .<span class="pp">macro</span> read buff<span class="op">,</span> buff_size</span>
<span id="cb62-32"><a href="#cb62-32"></a>      movl  <span class="op">$</span><span class="bn">3</span><span class="op">,</span> <span class="op">%</span><span class="kw">eax</span></span>
<span id="cb62-33"><a href="#cb62-33"></a>      movl  <span class="op">$</span><span class="bn">0</span><span class="op">,</span> <span class="op">%</span><span class="kw">ebx</span></span>
<span id="cb62-34"><a href="#cb62-34"></a>      movl  <span class="op">\</span>buff<span class="op">,</span> <span class="op">%</span><span class="kw">ecx</span></span>
<span id="cb62-35"><a href="#cb62-35"></a>      movl  <span class="op">\</span>buff_size<span class="op">,</span> <span class="op">%</span><span class="kw">edx</span></span>
<span id="cb62-36"><a href="#cb62-36"></a>      <span class="bu">int</span>   <span class="op">$</span><span class="bn">0</span>x80</span>
<span id="cb62-37"><a href="#cb62-37"></a>   .endm</span>
<span id="cb62-38"><a href="#cb62-38"></a></span>
<span id="cb62-39"><a href="#cb62-39"></a></span>
<span id="cb62-40"><a href="#cb62-40"></a>.<span class="bu">section</span> <span class="op">.</span>text</span>
<span id="cb62-41"><a href="#cb62-41"></a></span>
<span id="cb62-42"><a href="#cb62-42"></a>   .globl _start</span>
<span id="cb62-43"><a href="#cb62-43"></a></span>
<span id="cb62-44"><a href="#cb62-44"></a>   <span class="fu">_start:</span></span>
<span id="cb62-45"><a href="#cb62-45"></a>      write <span class="op">$</span>prompt_str<span class="op">,</span> <span class="op">$</span>STR_SIZE</span>
<span id="cb62-46"><a href="#cb62-46"></a>      read  <span class="op">$</span>buff<span class="op">,</span> <span class="op">$</span><span class="bn">32</span></span>
<span id="cb62-47"><a href="#cb62-47"></a></span>
<span id="cb62-48"><a href="#cb62-48"></a>// Read returns the length in <span class="kw">eax</span></span>
<span id="cb62-49"><a href="#cb62-49"></a>      pushl <span class="op">%</span><span class="kw">eax</span></span>
<span id="cb62-50"><a href="#cb62-50"></a></span>
<span id="cb62-51"><a href="#cb62-51"></a>// Print the hello text</span>
<span id="cb62-52"><a href="#cb62-52"></a>      write <span class="op">$</span>greet_str<span class="op">,</span> <span class="op">$</span>GSTR_SIZE</span>
<span id="cb62-53"><a href="#cb62-53"></a></span>
<span id="cb62-54"><a href="#cb62-54"></a>      popl  <span class="op">%</span><span class="kw">edx</span></span>
<span id="cb62-55"><a href="#cb62-55"></a></span>
<span id="cb62-56"><a href="#cb62-56"></a>// edx <span class="op">=</span> length returned by read</span>
<span id="cb62-57"><a href="#cb62-57"></a>   write <span class="op">$</span>buff<span class="op">,</span> <span class="op">%</span><span class="kw">edx</span></span>
<span id="cb62-58"><a href="#cb62-58"></a></span>
<span id="cb62-59"><a href="#cb62-59"></a>   <span class="fu">_exit:</span></span>
<span id="cb62-60"><a href="#cb62-60"></a>      movl  <span class="op">$</span><span class="bn">1</span><span class="op">,</span> <span class="op">%</span><span class="kw">eax</span></span>
<span id="cb62-61"><a href="#cb62-61"></a>      movl  <span class="op">$</span><span class="bn">0</span><span class="op">,</span> <span class="op">%</span><span class="kw">ebx</span></span>
<span id="cb62-62"><a href="#cb62-62"></a>      <span class="bu">int</span>   <span class="op">$</span><span class="bn">0</span>x80</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="chap11-strings-and-things" class="level2">
<h2 class="anchored" data-anchor-id="chap11-strings-and-things">Chap11, Strings and Things</h2>
<p>Any contiguous sequence of bytes or larger units in memory may be considered a string – not simply sequences of human-readable characters.</p>
<p>The string instructions deal with these large sequences of bytes or larger units in an extraordinarily compact way: by executing an instruction loop entirely inside the CPU.</p>
<p>Pascal treat strings as a separate data type, with a length counter at the start of the string to indicate how many bytes are in the string. In C, a string has no length byte in front of it. A C string is said to end when a byte with a binary value of 0 is encountered.</p>
<p>Assembly strings are just contiguous regions of memory. Assembly strings have no boundary values or length indicators. You should instead think of strings in terms of the register values that define them.</p>
<p>There are 2 kinds of strings in x64 assembly work. Source strings are strings that you read from. Destination strings are strings that you write to.</p>
<ul>
<li>A source string is pointed to by RSI. A destination string is pointed to by RDI.</li>
<li>The length of both kinds of strings is the value you place in RCX. How this length is acted upon by the CPU depends on the specific instruction and how it’s being used.</li>
<li>Data coming from a source string or going to a destination string must begin the trip from, end the trip at, or pass through register RAX.</li>
</ul>
<p>stosb instruction: STOre String by Byte - RDI must be loaded with the address of the destination string. - RCX must be loaded with the number of times the value in AL is to be stored into the string. - AL must be loaded with the 8-bit value to be stored into the string. - The direction flag DF must be set or cleared, depending on whether you want the search to be up-memory(cleared; use CLD) or down-memory(set; use STD).</p>
<p>Once you set up these three registers, you can safely execute a stosb instruction. This is what happens: - The byte value in AL is copied to the memory address stored in RDI. - RDI is incremented by 1, such that it now points to the next byte in memory following the one just written to.</p>
<p>RCX is not decremented by stosb. RCX is decremented automatically onlyif you put the REP prefix in front of stosb. Lacking the REP prefix, you have to do the decrementing yourself, either explicitly through DEC or through the LOOP instruction.</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode numberSource asm number-lines code-with-copy"><code class="sourceCode fasm"><span id="cb63-1"><a href="#cb63-1"></a><span class="co">;intel syntax </span></span>
<span id="cb63-2"><a href="#cb63-2"></a><span class="bu">cld</span> </span>
<span id="cb63-3"><a href="#cb63-3"></a><span class="bu">mov</span> <span class="kw">al</span><span class="op">,</span> FILLCHR </span>
<span id="cb63-4"><a href="#cb63-4"></a><span class="bu">mov</span> <span class="kw">rdi</span><span class="op">,</span> VidBuff </span>
<span id="cb63-5"><a href="#cb63-5"></a><span class="bu">mov</span> <span class="kw">rcx</span><span class="op">,</span> COLS<span class="op">*</span>ROWs </span>
<span id="cb63-6"><a href="#cb63-6"></a><span class="bu">rep</span> <span class="bu">stosb</span> </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>When DF is set, STOSB and its fellow string instructions work downhill, from higher to lower addresses. When DF is cleared, STOSB and its siblings work uphill, from lower to higher addresses. When DF is set, RDI is decremented during string instruction execution. When DF is cleared, RDI is incremented.</p>
<p>Loop instruction: combines the decrementing of RCX with a test and jump based on ZF. When executed, the loop instruction first decrements RCX by 1. It then checks the Zero flag o see if the decrement operation forced RCX to 0. If so, it falls through to the next instruction. If not, loop branches to the label specified as its operand.</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode numberSource asm number-lines code-with-copy"><code class="sourceCode fasm"><span id="cb64-1"><a href="#cb64-1"></a>  <span class="bu">mov</span> <span class="kw">al</span><span class="op">,</span><span class="bn">30h</span></span>
<span id="cb64-2"><a href="#cb64-2"></a><span class="fu">dochar:</span> </span>
<span id="cb64-3"><a href="#cb64-3"></a>  <span class="bu">stosb</span> </span>
<span id="cb64-4"><a href="#cb64-4"></a>  <span class="bu">inc</span> <span class="kw">al</span> </span>
<span id="cb64-5"><a href="#cb64-5"></a>  <span class="cf">loop</span> dochar </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>MUL, IMUL instructions: MUL treats its operand values as unsigned, where as IMUL treats them as signed.</p>
<p>STOSB, STOSW, STOSD, STOSQ instructions. RDI is changed according to the sizes of the quantity acted upon by the instruction.</p>
<p>X86-64 removed all BCD math instructions found in the x86 definition: AAA, DAA, DAS, AAS, AAM, AAD.</p>
<p>MOVSB,MOVSW,MOVSD,MOVSQ instructions. A block of memory data at the address stored in RSI is copied to the address stored in RDI.</p>
<p>JRCXZ instruction: Watches the RCX register. When it sees that RCX has just gone to zero, it jumps to the specified label. Note: there is not JRCXNZ instruction.</p>
<p>LOOP and LOOPNZ: LOOP watches the state of the RCX register, and closes the loop until RCX goes to 0. LOOPNZ watches both the state of the RCX register and the state of the zero flag ZF.</p>
<p>When one of your programs begins running, any command-line arguments that were entered when the program was launched are passed to the program on the Linux stack.</p>
<p>SCASB instruction: Scan String by Byte. - For up-memory searches, the CLD instruction is used to ensure that the DF is cleared. - The address of the first byte of the string to be searched is placed in RDI. - The value to be search for is placed in 8-bit register AL. - The maximum count is placed in RCX.</p>
<p>The prefix may be REPE or REPNE.</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode numberSource asm number-lines code-with-copy"><code class="sourceCode fasm"><span id="cb65-1"><a href="#cb65-1"></a><span class="bu">REPNE</span> SCANSB</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Use REPNE: Repeat SCASB as long as the content pointed by RDI does not equal AL.</p>
<p>Use REPE: Repeat SCASB as long as <code>[RDI]</code> equals AL.</p>
<p>Program Prologus and Epilogs.</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode numberSource asm number-lines code-with-copy"><code class="sourceCode fasm"><span id="cb66-1"><a href="#cb66-1"></a><span class="co">;intel syntax </span></span>
<span id="cb66-2"><a href="#cb66-2"></a><span class="co">;prologue </span></span>
<span id="cb66-3"><a href="#cb66-3"></a><span class="bu">push</span> <span class="kw">rbp</span> </span>
<span id="cb66-4"><a href="#cb66-4"></a><span class="bu">mov</span> <span class="kw">rbp</span><span class="op">,</span> <span class="kw">rsp</span> </span>
<span id="cb66-5"><a href="#cb66-5"></a><span class="bu">and</span> <span class="kw">rsp</span><span class="op">,</span> <span class="op">-</span><span class="dv">16</span> </span>
<span id="cb66-6"><a href="#cb66-6"></a></span>
<span id="cb66-7"><a href="#cb66-7"></a><span class="co">;epilogue </span></span>
<span id="cb66-8"><a href="#cb66-8"></a><span class="bu">mov</span> <span class="kw">rsp</span><span class="op">,</span> <span class="kw">rbp</span> </span>
<span id="cb66-9"><a href="#cb66-9"></a><span class="bu">pop</span> <span class="kw">rbp</span> </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="chap12-calling-external-functions-written-in-the-c-language" class="level2">
<h2 class="anchored" data-anchor-id="chap12-calling-external-functions-written-in-the-c-language">Chap12, Calling external functions written in the C language</h2>
</section>
</section>
<section id="end" class="level1">
<h1>end</h1>
<p>ideas:</p>
<p>how to use <code>.equ . - MSGBEGIN</code> to define the message length, to be used in sys call.</p>
<p>how to zero a register.</p>
<p>Recursive function call after loop.</p>
<p>Use MUL and SHIFT operations for multiplication.</p>
<p>conditional move instructions</p>
<p>how to inline assembly in Free PASCAL and GCC?</p>
<p>using macros?</p>
<p>local labels?</p>
<p>movsb,storsb,loop instructions?</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>