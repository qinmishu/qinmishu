[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "关于",
    "section": "",
    "text": "欢迎来到亲密数频道!\n个人简介：我从事通信行业的软件开发工作，已经超过10年，至今对信息技术仍充满热情。 我参与过GSM、WCDMA、IMS、LTE、5G等几代网络的网元和协议的开发。我有在Linux、Windows及云计算平台上的应用开发经验。我对几种编程范式如面向过程、面向对象及函数式编程等有一定的理解。我使用过多种编程语言进行开发，如C/C++、Java、Python、Go等。同时我对互联网相关技术如HTML、CSS、Javascript和游戏开发等方面也感兴趣。我也具有一定的用Python或Julia进行数据分析的技能。 业余时间我喜欢看数学、文学、历史等方面的书籍。总体而言我是个热爱技术、乐于学习的技术人员。"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "亲密数",
    "section": "",
    "text": "欢迎来到亲密数频道!\n\n\n\n\n\n\n\n\n  \n\n\n\n\nx86-64汇编语言编程\n\n\n\n\n\n\n\nx86-64\n\n\nassembly\n\n\nlinux\n\n\n\n\n\n\n\n\n\n\n\nOct 21, 2023\n\n\n秦米书\n\n\n\n\n\n\n  \n\n\n\n\nSignal and System a Primer\n\n\n\n\n\n\n\ntelecom\n\n\n\n\n\n\n\n\n\n\n\nSep 10, 2023\n\n\n秦米书\n\n\n\n\n\n\n  \n\n\n\n\nARM汇编语言编程\n\n\n\n\n\n\n\narm\n\n\nassembly\n\n\nraspberry-pi\n\n\n\n\n\n\n\n\n\n\n\nApr 6, 2023\n\n\n秦米书\n\n\n\n\n\n\n  \n\n\n\n\nPost With Code\n\n\n\n\n\n\n\nalgorithm\n\n\ncode\n\n\nanalysis\n\n\n\n\n\n\n\n\n\n\n\nApr 6, 2023\n\n\n秦米书\n\n\n\n\n\n\n  \n\n\n\n\n欢迎来到我的博客\n\n\n\n\n\n\n\nnews\n\n\n\n\n\n\n\n\n\n\n\nApr 3, 2023\n\n\n秦米书\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/post-with-code/index.html",
    "href": "posts/post-with-code/index.html",
    "title": "Post With Code",
    "section": "",
    "text": "这是一篇带有代码的博客.\n\n1 + 1\n\n2"
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "欢迎来到我的博客",
    "section": "",
    "text": "这是第一篇博客. 欢迎!"
  },
  {
    "objectID": "posts/arm-assembly/index.html",
    "href": "posts/arm-assembly/index.html",
    "title": "ARM汇编语言编程",
    "section": "",
    "text": "This is a note while studing ARM assembler in Raspberry Pi. Most contents are copied from there to remember where I read to. You should read the original copy from the author."
  },
  {
    "objectID": "posts/arm-assembly/index.html#chap7-数组和结构体",
    "href": "posts/arm-assembly/index.html#chap7-数组和结构体",
    "title": "ARM架构汇编语言编程",
    "section": "",
    "text": "1 + 1"
  },
  {
    "objectID": "posts/arm-assembly/index.html#索引模式的定义",
    "href": "posts/arm-assembly/index.html#索引模式的定义",
    "title": "ARM汇编语言编程-08-数组和结构体",
    "section": "索引模式的定义",
    "text": "索引模式的定义\nThese sets of allowed operands in instructions are collectively called indexing modes."
  },
  {
    "objectID": "posts/arm-assembly/index.html#数组和结构体",
    "href": "posts/arm-assembly/index.html#数组和结构体",
    "title": "ARM汇编语言编程",
    "section": "08-数组和结构体",
    "text": "08-数组和结构体\n以下内容为学习https://thinkingeek.com/2013/01/27/arm-assembler-raspberry-pi-chapter-8/的摘录.\n\n索引模式的定义\nThese sets of allowed operands in instructions are collectively called indexing modes.\n\n\n什么是数组\nAn array is a sequence of items of the same kind in memory.\nint a[100];\n\n\n什么是结构体\nA structure (or record or tuple) is a sequence of items of possibly diferent kind.\nstruct my_struct\n{\n  char f0;\n  int f1;\n} b;\n\n\nNaive approach without indexing modes\narray01.s, a program to set initial values 0..9 to a 10 elements array\n.data \n.balign 4 \na: .skip 40 \n\n.text \n.global main \nmain: \n    ldr r0, addr_a \n\n    mov r1, #0 \n\nloop: \n    cmp r1, #10 \n    beq loop_end \n    add r2, r0, r1, lsl #2  \n    str r1, [r2] \n    add r1, r1, #1 \n    b loop \nloop_end: \n    bx lr \naddr_a: .word a \n\n\nIndexing modes\n\nNon updating indexing modes\n\nimmediate value. The immediate cannot be larger than 12 bits(0..4096)\n\n[Rsource1, #+immediate] \n[Rsource1, #-immediate]\n\nmov r2, #3\nstr r2, [r1, #+12] \n\nregister\n\n[Rsource1, +Rsource2] \n[Rsource1, -Rsource2]\n\nmov r2, #3         /* r2 ← 3 */\nmov r3, #12        /* r3 ← 12 */\nstr r2, [r1,+r3]   /* *(r1 + r3) ← r2 */\n\nregister with shift operation\n\n[Rsource1, +Rsource2, shift_operation #immediate]\n[Rsource1, -Rsource2, shift_operation #immediate]\n\nstr r2, [r1, +r2, LSL #2]\n\n\nUpdating indexing modes\nIn these indexing modes the Rsource1 register is updated with the address synthesized by the load or store instruction.\n\nPost-indexing modes\n\nThe value of Rsource1 is used as the address for the load or store. Then Rsource1 is updated with the value of immediate after adding (or subtracting) it to Rsource1.\n\n[Rsource1], #+immediate\n[Rsource1], #-immediate\n\nstr r2, [r1], #4        /* *r1 ← r2 then r1 ← r1 + 4 */\n\nregister\n\n[Rsource1], +Rsource2\n[Rsource1], -Rsource2\n\nregister with shift operation\n\n[Rsource1], +Rsource2, shift_operation #immediate \n[Rsource1], -Rsource2, shift_operation #immediate\n\n\nPre-indexing modes\n\nimmediate\n\n[Rsource1, #+immediate]! \n[Rsource1, #-immediate]!\n\nldr r2, [r1, #+12]!  /* r1 ← r1 + 12 then r2 ← *r1 */\n\nregister\n\n[Rsource1, +Rsource2]! \n[Rsource1, +Rsource2]!\n\nregister with shift operation\n\n[Rsource1, +Rsource2, shift_operation #immediate]! \n[Rsource1, -Rsource2, shift_operation #immediate]!\n\n\n\n\napproach using indexing modes\narray02.s, a program to set initial values 0..9 to a 10 elements array, using indexing modes\n.data \n.balign 4 \na: .skip 40 \n\n.text \n.global main \nmain: \n    ldr r0, addr_a \n\n    mov r1, #0 \n\nloop: \n    cmp r1, #10 \n    beq loop_end \n    /*add r2, r0, r1, lsl #2 */\n    str r1, [r0, r1, lsl #2] \n    add r1, r1, #1 \n    b loop \nloop_end: \n    bx lr \naddr_a: .word a \n\n\n结构体\n略"
  },
  {
    "objectID": "posts/arm-assembly/index.html#函数",
    "href": "posts/arm-assembly/index.html#函数",
    "title": "ARM汇编语言编程",
    "section": "09-函数",
    "text": "09-函数\n以下内容为学习https://thinkingeek.com/2013/02/02/arm-assembler-raspberry-pi-chapter-9/的摘录.\nFunctions are a way to reuse code.\nAAPCS:Procedure Call Standard for ARM Architecture\n\n\n\nRegister\nRegister Alias\nDescription\nRemark\n\n\n\n\nr15\npc\nProgram Counter\n\n\n\nr14\nlr\nLink Register\n\n\n\nr13\nsp\nStack Pointer\n\n\n\n\ncpsr\nCurrent Program Status Register\n\n\n\n\nFunctions can receive parameters. The first 4 parameters must be stored, sequentially, in the registers r0, r1, r2 and r3.\n\nWell behaved functions\nA function must adhere, at least, to the following rules if we want it to be AAPCS compliant.\n\nA function should not make any assumption on the contents of the cpsr. So, at the entry of a function condition codes N, Z, C and V are unknown.\nA function can freely modify registers r0, r1, r2 and r3.\nA function cannot assume anything on the contents of r0, r1, r2 and r3 unless they are playing the role of a parameter.\nA function can freely modify lr but the value upon entering the function will be needed when leaving the function (so such value must be kept somewhere).\nA function can modify all the remaining registers as long as their values are restored upon leaving the function. This includes sp and registers r4 to r11.\nThis means that, after calling a function, we have to assume that (only) registers r0, r1, r2, r3 and lr have been overwritten.\n\n\n\nCalling a function\ndirect call:\nbl label\nindirect call(first storing the address of the function into a register):\nblx Rsource1 /* Rsource1 means register operand1 */\nIn both cases the behaviour is as follows: the address of the function (immediately encoded in the bl or using the value of the register in blx) is stored in pc. The address of the instruction following the bl or blx instruction is kept in lr.\n\n\nLeaving a function\nA well behaved function, as stated above, will have to keep the initial value of lr somewhere. When leaving the function, we will retrieve that value and put it in some register (it can be lr again but this is not mandatory). Then we will bx Rsource1 (we could use blx as well but the latter would update lr which is useless here).\n\n\nReturning data from functions\nFunctions must use r0 for data that fits in 32 bit (or less). This is, C types char, short, int, long (and float though we have not seen floating point yet) will be returned in r0. For basic types of 64 bit, like C types long long and double, they will be returned in r1 and r0. Any other data is returned through the stack unless it is 32 bit or less, where it will be returned in r0.\n\n\nHello world (puts)\n/* -- hello01.s */\n.data\n\ngreeting:\n .asciz \"Hello world\"\n\n.balign 4\nreturn: .word 0\n\n.text\n\n.global main\nmain:\n    ldr r1, address_of_return     /*   r1 ← &address_of_return */\n    str lr, [r1]                  /*   *r1 ← lr */\n\n    ldr r0, address_of_greeting   /* r0 ← &address_of_greeting */\n                                  /* First parameter of puts */\n\n    bl puts                       /* Call to puts */\n                                  /* lr ← address of next instruction */\n\n    ldr r1, address_of_return     /* r1 ← &address_of_return */\n    ldr lr, [r1]                  /* lr ← *r1 */\n    bx lr                         /* return from main */\naddress_of_greeting: .word greeting\naddress_of_return: .word return\n\n/* External */\n.global puts\n\n\nInteraction (scanf, printf)\n/* -- printf01.s */\n.data\n\n/* First message */\n.balign 4\nmessage1: .asciz \"Hey, type a number: \"\n\n/* Second message */\n.balign 4\nmessage2: .asciz \"I read the number %d\\n\"\n\n/* Format pattern for scanf */\n.balign 4\nscan_pattern : .asciz \"%d\"\n\n/* Where scanf will store the number read */\n.balign 4\nnumber_read: .word 0\n\n.balign 4\nreturn: .word 0\n\n.text\n\n.global main\nmain:\n    ldr r1, address_of_return        /* r1 ← &address_of_return */\n    str lr, [r1]                     /* *r1 ← lr */\n\n    ldr r0, address_of_message1      /* r0 ← &message1 */\n    bl printf                        /* call to printf */\n\n    ldr r0, address_of_scan_pattern  /* r0 ← &scan_pattern */\n    ldr r1, address_of_number_read   /* r1 ← &number_read */\n    bl scanf                         /* call to scanf */\n\n    ldr r0, address_of_message2      /* r0 ← &message2 */\n    ldr r1, address_of_number_read   /* r1 ← &number_read */\n    ldr r1, [r1]                     /* r1 ← *r1 */\n    bl printf                        /* call to printf */\n\n    ldr r0, address_of_number_read   /* r0 ← &number_read */\n    ldr r0, [r0]                     /* r0 ← *r0 */\n\n    ldr lr, address_of_return        /* lr ← &address_of_return */\n    ldr lr, [lr]                     /* lr ← *lr */\n    bx lr                            /* return from main using lr */\naddress_of_message1 : .word message1\naddress_of_message2 : .word message2\naddress_of_scan_pattern : .word scan_pattern\naddress_of_number_read : .word number_read\naddress_of_return : .word return\n\n/* External */\n.global printf\n.global scanf\n\n\nFirst function (multiply by 5)\n/* -- printf02.s */\n.data\n\n/* First message */\n.balign 4\nmessage1: .asciz \"Hey, type a number: \"\n\n/* Second message */\n.balign 4\nmessage2: .asciz \"%d times 5 is %d\\n\"\n\n/* Format pattern for scanf */\n.balign 4\nscan_pattern : .asciz \"%d\"\n\n/* Where scanf will store the number read */\n.balign 4\nnumber_read: .word 0\n\n.balign 4\nreturn: .word 0\n\n.balign 4\nreturn2: .word 0\n\n.text\n\n/*\nmult_by_5 function\n*/\nmult_by_5: \n    ldr r1, address_of_return2       /* r1 ← &address_of_return */\n    str lr, [r1]                     /* *r1 ← lr */\n\n    add r0, r0, r0, LSL #2           /* r0 ← r0 + 4*r0 */\n\n    ldr lr, address_of_return2       /* lr ← &address_of_return */\n    ldr lr, [lr]                     /* lr ← *lr */\n    bx lr                            /* return from main using lr */\naddress_of_return2 : .word return2\n\n.global main\nmain:\n    ldr r1, address_of_return        /* r1 ← &address_of_return */\n    str lr, [r1]                     /* *r1 ← lr */\n\n    ldr r0, address_of_message1      /* r0 ← &message1 */\n    bl printf                        /* call to printf */\n\n    ldr r0, address_of_scan_pattern  /* r0 ← &scan_pattern */\n    ldr r1, address_of_number_read   /* r1 ← &number_read */\n    bl scanf                         /* call to scanf */\n\n    ldr r0, address_of_number_read   /* r0 ← &number_read */\n    ldr r0, [r0]                     /* r0 ← *r0 */\n    bl mult_by_5\n\n    mov r2, r0                       /* r2 ← r0 */\n    ldr r1, address_of_number_read   /* r1 ← &number_read */\n    ldr r1, [r1]                     /* r1 ← *r1 */\n    ldr r0, address_of_message2      /* r0 ← &message2 */\n    bl printf                        /* call to printf */\n\n    ldr lr, address_of_return        /* lr ← &address_of_return */\n    ldr lr, [lr]                     /* lr ← *lr */\n    bx lr                            /* return from main using lr */\naddress_of_message1 : .word message1\naddress_of_message2 : .word message2\naddress_of_scan_pattern : .word scan_pattern\naddress_of_number_read : .word number_read\naddress_of_return : .word return\n\n/* External */\n.global printf\n.global scanf"
  },
  {
    "objectID": "posts/signal-and-system/index.html",
    "href": "posts/signal-and-system/index.html",
    "title": "Signal and System a Primer",
    "section": "",
    "text": "This is a note for Signal and System a Primer with Matlab. I don’t have Matlab, but I may use Scilab/Octave/Python/Julia/R/Haskell instead when necessary."
  },
  {
    "objectID": "posts/signal-and-system/index.html#basic-continuous-time-signals",
    "href": "posts/signal-and-system/index.html#basic-continuous-time-signals",
    "title": "Signal and System a Primer",
    "section": "1.4 basic continuous time signals",
    "text": "1.4 basic continuous time signals\nUnit step function u(t)\n\\[\nu(t) = \\begin{cases}\n   1 &\\text{t &gt; 0} \\\\\n   0 &\\text{t &lt; 0}   \n\\end{cases}\n\\]\nUnit impulse function \\(\\delta(t)\\)\n\\[\n\\delta(t) = \\frac{d}{dt}u(t) = \\begin{cases}\n   0 & t \\ne 0 \\\\\n   \\text{undefined} & t = 0\n\\end{cases}\n\\]\nThe impulse function has the property(called sampling or sifting property)\n\\[\n\\int_{a}^{b} f(t) \\delta(t-t_0)  dt = \\int_{a}^{b} f(t_0) \\delta(t-t_0) dt = f(t_0) \\int_{a}^{b} \\delta(t-t_0) dt = f(t_0)\n\\]\nUnit ramp function\n\\[\nr(t) = t \\times u(t)\n\\]\nUnit rectangle pulse function\nUnit triangular pulse function\nsinusoidal signal\nexponential signal"
  },
  {
    "objectID": "posts/signal-and-system/index.html#basic-discrete-time-signals",
    "href": "posts/signal-and-system/index.html#basic-discrete-time-signals",
    "title": "Signal and System a Primer",
    "section": "1.5 basic discrete time signals",
    "text": "1.5 basic discrete time signals\nUnit step sequence\n\\[\nu(n) = \\begin{cases}\n   0 &\\text{n &lt; 0} \\\\\n   1 & n \\ge 0\n\\end{cases}\n\\]\nUnit impulse sequence\n\\[\n\\delta(n) = \\begin{cases}\n   0 & n \\ne 0 \\\\\n   1 & n = 0\n\\end{cases}\n\\]\nUnit ramp sequence\n\\[\nr(n) = \\begin{cases}\n   0 & n &lt; 0 \\\\\n   n & n \\ge 0\n\\end{cases}\n\\]\nSinusoidal sequence\nExponential sequence"
  },
  {
    "objectID": "posts/signal-and-system/index.html#basic-operations-on-signals",
    "href": "posts/signal-and-system/index.html#basic-operations-on-signals",
    "title": "Signal and System a Primer",
    "section": "1.6 Basic operations on signals",
    "text": "1.6 Basic operations on signals\nTime reversal\nTime scaling\nTime shifting\nAmplitude transformation"
  },
  {
    "objectID": "posts/signal-and-system/index.html#classifications-of-systems",
    "href": "posts/signal-and-system/index.html#classifications-of-systems",
    "title": "Signal and System a Primer",
    "section": "1.7 Classifications of systems",
    "text": "1.7 Classifications of systems\ncontinuous time vs discrete time systems\ncausal vs noncausal systems: A causal system is one whose output y(t) at present time depends only on the present and past values(not future) of the input x(t).\nlinear and nonlinear systems: Linearity is the property of the system describing a linear relationship between input (cause) and output (effect). The property is a combination of both homogeneity(scaling) property and the additivity property. The homogeneity property requires that if the input is multiplied by any constant k, then the output is multiplied by the same constant. The additivity property requires that the response to a sum of inputs is the sum of the responses to each input applied separately.\n\\[\nT \\lbrace k_1 x_1 + k_2 x_2 \\rbrace = k_1 y_1 + k_2 y_2\n\\]\ntime varying and time invariant systems: A time-varying system is one whose parameters vary with time. In a time-invariant system, a time shift (advance or delay) in the input signal leads to the time shift in the output signal.\nsystems with and without memory: When the output of a system depends on the past and/or future input, the system is said to have a memory. A memoryless system is one in which the current output depends only on the current input; it does not depend on the past or future inputs.A system with a memory is also called a dynamic system. A memoryless system is called a static system."
  },
  {
    "objectID": "posts/signal-and-system/index.html#impulse-response",
    "href": "posts/signal-and-system/index.html#impulse-response",
    "title": "Signal and System a Primer",
    "section": "2.2 Impulse response",
    "text": "2.2 Impulse response\nThe impulse response h(t) is the response of the system when the input is the unit impulse function \\(\\delta(t)\\), that is,\n\\[\nh(t) = T \\delta(t)\n\\]\nThe input signal x(t) can be expressed as (\\(\\tau\\) is a dummy variable) the below equation. It is the sifting property of the unit impulse.\n\\[\nx(t) = \\int_{-\\infty}^{+\\infty} x(\\tau) \\delta(t-\\tau)d\\tau   \n\\]\nThe response y(t) to the input x(t) is obtained by:\n\\[\n\\begin{align}\ny(t) &= Tx(t)=T \\lbrace \\int_{-\\infty}^{+\\infty} x(\\tau) \\delta(t-\\tau)d\\tau \\rbrace \\\\\n&= \\int_{-\\infty}^{+\\infty} x(\\tau) T \\lbrace \\delta(t-\\tau) \\rbrace d\\tau \\\\\n&= \\int_{-\\infty}^{+\\infty} x(\\tau)  h(t-\\tau)  d\\tau\n\\end{align}\n\\]\nThis shows that an LTI system is characterized by its impulse response."
  },
  {
    "objectID": "posts/signal-and-system/index.html#convolution-integral",
    "href": "posts/signal-and-system/index.html#convolution-integral",
    "title": "Signal and System a Primer",
    "section": "2.3 Convolution Integral",
    "text": "2.3 Convolution Integral\nThe below equation is also called convolution integral or superposition integral.\n\\[\ny(t) = \\int_{-\\infty}^{+\\infty} x(\\tau)  h(t-\\tau)  d\\tau\n\\]\nThe convolution of two signals x(t) and h(t) is usually written in terms of the operator *. That is, y(t) equals x(t) convolved with h(t).\n\\[\ny(t) = x(t) * h(t) = \\int_{-\\infty}^{+\\infty} x(\\tau)  h(t-\\tau)  d\\tau\n\\]\nWe can split the integral into two parts:\n\\[\ny(t) = x(t) * h(t) = \\int_{-\\infty}^{t_0} x(\\tau)  h(t-\\tau)  d\\tau + \\int_{t_0}^{+\\infty} x(\\tau)  h(t-\\tau)  d\\tau\n\\]\nThe 1st part is \\(y_{zir}\\), the 2nd part is \\(y_{zsr}\\).\nZIR: Zero Input Response. (natural response)\nZSR: Zero State Response. (the forced response)\n\\(t_0\\) is the initial time.\nThe convolution integral can be simplified if we assume that a system has two properties.\nFirst, if x(t) = 0 for t &lt; 0, then\n\\[\ny(t) = x(t) * h(t) = \\int_{-\\infty}^{+\\infty} x(\\tau) h(t-\\tau)  d\\tau = \\int_{0}^{+\\infty} x(\\tau) h(t-\\tau)  d\\tau\n\\]\nSecond, if we assume that the system is causal (that is y(t) does not depend on future signal of x(t) or h(t)), h(t) = 0 for t &lt; 0, the equation becomes,\n\\[\ny(t) = x(t) * h(t) = \\int_{-\\infty}^{+\\infty} x(\\tau) h(t-\\tau)  d\\tau = \\int_{0}^{t} x(\\tau) h(t-\\tau)  d\\tau\n\\]\nImportant properties of the convolution integral:\n\nThe order in which two functions are convolved is unmportant.\nWidth property. If the durations of x(t) and h(t) are \\(T_1\\) and \\(T_2\\), then the duration of \\(y(t) = x(t) * h(t)\\) is \\(T_1 + T_2\\). If the areas under x(t) and h(t) are \\(A_1\\) and \\(A_2\\), then the area under \\(y(t) = x(t) * h(t)\\) is \\(A_1A_2\\).\n\nThe convolution integral can be evaluated in 3 different ways:\n\nAnalytical method, which involves performing the integration by hand when x(t) and h(t) are specified analytically.\n\nGraphical method, which is appropriate when x(t) and h(t) are provided in graphical form.\n\nNumerical method, where we approximate x(t) and h(t) by numerical sequence and obtain y(t) by discrete convolution using a digital computer."
  },
  {
    "objectID": "posts/signal-and-system/index.html#graphical-convolution",
    "href": "posts/signal-and-system/index.html#graphical-convolution",
    "title": "Signal and System a Primer",
    "section": "2.4 Graphical convolution",
    "text": "2.4 Graphical convolution\nGraphical method of evaluating the convolution integral. This method usually involves 4 steps:\n\nFolding: Take the mirror image of \\(h(\\tau)\\) about the ordinate(vertical) axis\nShifting: Displace or shift \\(h(\\tau)\\) by t to obtain \\(h(t-\\tau)\\)\nMultiplication: Multiply \\(h(t-\\tau)\\) and \\(x(\\tau)\\) together\nIntegration: For a given t, integrate the product \\(h(t-\\tau)x(\\tau)\\) over \\(0 &lt; \\tau &lt; t\\) to get y(t) at t\n\nWe are going to use the below auxiliary functions.\n\nfunction step(t)\n    if t &gt;= 0  \n        return 1 \n    else \n        return 0 \n    end \nend \n\nfunction ramp(t)\n    return t*step(t)\nend \n\nramp (generic function with 1 method)\n\n\nObtain the convolution of the two signals in Figure 1\n\nusing Plots\nusing LaTeXStrings \n\nx(t) = step(t) \n\nh(t) = ramp(t+2) * step(-t) + 2*step(t)*step(2-t)\n\nxplot = plot(x,-2,2,title=\"x(t)\")\nhplot = plot(h,-2,2,title=\"h(t)\")\nplot(xplot,hplot,layout=(1,2), legend=false)\n\n\n\n\nFigure 1: graph convolution example\n\n\n\n\nDefinition of x(t) \\[\nx(t) = step(t)\n\\]\nDefinition of h(t) \\[\nh(t) = \\begin{cases}\n   2+t &\\text{-2 &lt; t &lt; 0} \\\\\n   1 &\\text{0 &lt; t &lt; 2}   \n\\end{cases}\n\\]\nIn this case, it is easy to fold x(t), the unit step function. Let\n\\[\ny(t) = x(t)*h(t) = \\int x(t-\\tau)h(\\tau)d\\tau\n\\]\nFirst, we fold x(t)\n\nx_fold(t) = x(-t)\n\nplot(x_fold, -2, 2, title=L\"x(- \\tau)\", legend=false)\n\n\n\n\nand shift it by t\n\nt = 1\n\nx_shift(tau) = x(t-tau)\n\nplot(x_shift, -3, 2, title=L\"x(t - \\tau)\", legend=false)\n\n\n\n\nFor \\(t &lt; -2\\), there is no overlap of the two signals, as shown in Figure 2 , Hence,\n\\[\ny(t) = x(t) * h(t) = 0, t&lt; -2\n\\]\n\nt = -2.5 \n\nplot(x_shift,-3,2,label=L\"x(t - \\tau)\")\nplot!(h,-3,2,label=L\"h(\\tau)\")\ntitle!( \"convolution x(t)*h(t), t &lt; -2\")\n\n\n\n\nFigure 2: t &lt; -2\n\n\n\n\nFor -2 &lt; t &lt; 0, the two signals overlap between -2 and t, as shown in figure Figure 3 , Hence,\n\\[\n\\begin{align}\ny(t) &= \\int_{-2}^{t} x(t-\\tau)h(\\tau)d\\tau \\\\\n&= \\int_{-2}^{t} (1)(2+\\tau) d\\tau \\\\\n&= 2\\tau + \\frac{\\tau^2}{2} \\biggr\\rvert_{-2}^{t} = 0.5 t^2 + 2t + 2, \\text{-2 &lt; t &lt; 0}\n\\end{align}\n\\]\n\nt = -1.5 \n\nplot(x_shift,-3,2,label=L\"x(t - \\tau)\")\nplot!(h,-3,2,label=L\"h(\\tau)\")\ntitle!( \"convolution x(t)*h(t), -2 &lt; t &lt; 0\")\n\n\n\n\nFigure 3: -2 &lt; t &lt; 0\n\n\n\n\nFor 0 &lt; t &lt; 2, the two signals overlap between -2 and t, as shown in figure Figure 4 , Hence,\n\\[\n\\begin{align}\ny(t) &= \\int_{-2}^{t} x(t-\\tau)h(\\tau)d\\tau \\\\\n&= \\int_{-2}^{0} (1)(2+\\tau) d\\tau + \\int_{0}^{t}(1)(2) d\\tau \\\\\n&= (2 \\tau + \\frac{\\tau^2}{2}) \\biggr\\rvert_{-2}^{0} + 2 \\tau \\biggr\\rvert_{0}^{t} \\\\\n&= 2+2t , \\text{0 &lt; t &lt; 2}\n\\end{align}\n\\]\n\nt = 1 \n\nplot(x_shift,-3,2,label=L\"x(t - \\tau)\")\nplot!(h,-3,3,label=L\"h(\\tau)\")\ntitle!( \"convolution x(t)*h(t), 0 &lt; t &lt; 2\")\n\n\n\n\nFigure 4: 0 &lt; t &lt; 2\n\n\n\n\nFor t &gt; 2, the two signals overlap between -2 and 2, as shown in figure Figure 5 , Hence,\n\\[\n\\begin{align}\ny(t) &= \\int_{-2}^{t} x(t-\\tau)h(\\tau)d\\tau \\\\\n&= \\int_{-2}^{0} (1)(2+\\tau) d\\tau + \\int_{0}^{2}(2)(2) d\\tau \\\\\n&= (2 \\tau + \\frac{\\tau^2}{2}) \\biggr\\rvert_{-2}^{0} + 2 \\tau \\biggr\\rvert_{0}^{2} \\\\\n&= 6 , \\text{ t &gt; 2}\n\\end{align}\n\\]\n\nt = 2.5\n\nplot(x_shift,-3,3,label=L\"x(t - \\tau)\")\nplot!(h,-3,3,label=L\"h(\\tau)\")\ntitle!( \"convolution x(t)*h(t), t &gt; 2\")\n\n\n\n\nFigure 5: t &gt; 2\n\n\n\n\nCombining the results, we obtain, see Figure 6\n\\[\ny(t) = \\begin{cases}\n   0.5t^2 + 2t + 2,  &\\text{-2 &lt; t &lt; 0} \\\\\n   2t+2,  &\\text{0 &lt; t &lt; 2} \\\\\n   6, &\\text{ t &gt; 2} \\\\\n   0, &\\text{otherwise}\n\\end{cases}\n\\]\n\ny(t) = begin \n   if (-2 &lt;= t) && (t &lt;= 0)\n      0.5*t*t + 2*t + 2 \n   elseif (0 &lt;= t) && (t &lt;= 2)\n      2*t + 2 \n   elseif t &gt; 2 \n      6 \n   else\n      0  \n   end    \nend \n\nplot(y,-4,4)\ntitle!( \"convolution x(t)*h(t), result\")\n\n\n\n\nFigure 6: convolution result"
  },
  {
    "objectID": "posts/signal-and-system/index.html#block-diagram-representation",
    "href": "posts/signal-and-system/index.html#block-diagram-representation",
    "title": "Signal and System a Primer",
    "section": "2.5 Block Diagram Representation",
    "text": "2.5 Block Diagram Representation\nThe commutative property of the convolution integral.\n\n\n\n\nflowchart LR \nsubgraph g1[1]\n    direction LR    \n    x[\"x(t)\" ]--&gt;h[\"h(t)\" ]--&gt;y[\"y(t)\"];\n    style x stroke-width:0px\n    style y stroke-width:0px\nend \n\nsubgraph g2[2]\n    direction LR \n    h1[\"h(t)\" ]--&gt;x1[\"x(t)\" ]--&gt;y1[\"y(t)\"];\n    style h1 stroke-width:0px\n    style y1 stroke-width:0px\nend \n\ng1-.-|equals|g2\n\n\n\n\n\nThe associative property of the convolution integral.\n\n\n\n\nflowchart LR \nsubgraph g1[1]\n    direction LR    \n    x[\"x(t)\" ]--&gt;h1[\"h1(t)\" ]--&gt;h2[\"h2(t)\" ]--&gt;y[\"y(t)\"];\n    style x stroke-width:0px\n    style y stroke-width:0px\nend \n\nsubgraph g2[2]\n    direction LR \n    xx[\"x(t)\" ]--&gt;convolution[\"h1(t)*h2(t)\" ]--&gt;yy[\"y(t)\"];\n    style xx stroke-width:0px\n    style yy stroke-width:0px\nend \n\ng1-.-|equals|g2\n\n\n\n\n\nThe distributive property of the convolution integral.\n\n\n\n\nflowchart LR \nsubgraph g1[1]\n    direction LR    \n    x[\"x(t)\"]--&gt;h1[\"h1(t)\"] & h2[\"h2(t)\"] \n    h1--&gt;y[\"y(t)\"] \n    h2--&gt;y \n    style x stroke-width:0px\n    style y stroke-width:0px\nend \n\nsubgraph g2[2]\n    direction LR \n    xx[\"x(t)\" ]--&gt;addition[\"h1(t)+h2(t)\" ]--&gt;yy[\"y(t)\"];\n    style xx stroke-width:0px\n    style yy stroke-width:0px\nend \n\ng1-.-|equals|g2"
  },
  {
    "objectID": "posts/signal-and-system/index.html#discrete-convolution",
    "href": "posts/signal-and-system/index.html#discrete-convolution",
    "title": "Signal and System a Primer",
    "section": "2.6 Discrete Convolution",
    "text": "2.6 Discrete Convolution\nUnit step sequence definition\n\\[\nu[n] = \\begin{cases}\n   0 \\ n &lt; 0 \\\\\n   1 \\ n \\ge 0\n\\end{cases}\n\\]\nUnit impulse sequence definition\n\\[\n\\delta(n) = \\begin{cases}\n    0 \\ n \\ne 0 \\\\\n    1 \\ n = 0\n\\end{cases}\n\\]\nAn alternative way of expressing any discrete signal x[n]. I.e. we can represent x[n] as a weighted sum of delayed impulses.\n\\[\nx[n] = \\sum_{k=-\\infty}^{\\infty} x[k] \\delta[n-k]\n\\]\nThe multiplication property of the impulse function is (The 2 equations hold because \\(\\delta[n] = 1\\) only if n is 0 )\n\\[\n\\begin{align}\n\\delta[n] x[n-k] &= x[-k] \\delta[n] \\\\\n\\delta[n-k] x[n] &= x[k] \\delta[n-k]\n\\end{align}\n\\]\nThe impulse response h[n] of of a discrete LTI system is the response of the system when the input is \\(\\delta[n]\\). I.e.\n\\[\nh[n] = T\\{\\delta[n]\\}\n\\]\nor\n\n\n\n\nflowchart LR \n      \n    delta[\"δ[n]\" ]--&gt;s[\"system T\" ]--&gt;h[\"h[n]\"];\n    style delta stroke-width:0px\n    style h stroke-width:0px\n\n\n\n\n\nThe convolution of the discrete input signal x[n] and impulse response h[n] is (* is the convolution symbol)\n\\[\ny[n] = x[n] * h[n]\n\\]\nIt is defined as\n\\[\ny[n] = \\sum_{k=-\\infty}^{\\infty} x[k] h[n-k]\n\\]\nThis is known as the convolution sum or superposition sum for the system response.\nAs in continuous time convolution, one of the signals is time-inverted, shifted and then multiplied by the other. By the change of variables \\(m=n-k\\), we have (m in the below equation, and k in the above equation are called dummy variables)\n\\[\ny[n] = \\sum_{m=-\\infty}^{\\infty} x[n-m] h[m]\n\\]\nThis shows the order of summation is immaterial; discrete convolution is commutative.\nProperties of convolution sum.\n\\[\n\\begin{align}\n& x[n]*h[n] = h[n]*x[n] \\quad \\text{commutative} \\\\\n& f[n]*[x[n]+y[n]] = f[n]*x[n] + f[n]*y[n] \\quad \\text{distributative} \\\\\n& f[n]*[x[n]*y[n]] = [f[n]*x[n]]*y[n] \\quad \\text{associative} \\\\\n& x[n-m]*h[n-k] = y[n-m-k] \\quad \\text{shifting} \\\\\n& x[n]*\\delta[n] = x[n]\n\\end{align}\n\\]\nIf both x[n] and h[n] are causal, that is, x[n] and h[n] are 0 for all $ n &lt; 0 $, the summation becomes\n\\[\ny[n] = \\sum_{m=0}^{n} x[n-m] h[m]\n\\]\nThe convolution of M-point sequence with a N-point sequence produces an (M+N-1)-point sequence.\nEvaluating the convolution sum requires the following steps:\n\nThe signal h[k] is time-reversed to get h[−k] and then shifted by n to form h[n − k] or h[−(k − n)], which should be regarded as a function of k with parameter n.\nFor a fixed value of n, multiply x[k] and h[n − k] for all values of k.\nThe product x[k]h[n − k] is summed over all k to produce a single value of y[n].\nRepeat steps 1–3 for various values of n to produce the entire output y[n].\n\nExample, find r[n], given that r[n] is the convolution of 2 unit step sequences, that is\n\\[\nr[n] = u[n] * u[n]\n\\]\nSolution:\n\\[\nr[n] = u[n] * u[n] = \\sum_{k=-\\infty}^{\\infty} u[k] u[n-k]\n\\]\nThe function u[k], u[-k], u[n-k] are shown in in@fig-discrete-convolution-ex . The convolution takes place when we multiply the sequences (a) with (c) and (d).\nFor \\(n&lt;0\\), the non-zero values of u[k] and u[n-k] do not overlap, so \\(u[k] u[n-k] = 0\\) for all values of k. This implies that \\(r[n] = 0\\) for \\(n &lt; 0\\).\nFor \\(n \\ge 0\\), he non-zero values of u[k] and u[n-k] overlap. This overlap begins with u[k] at k = 0 and ends with u[n-k] at k = n. Hence,\n\\[\nr[n] = \\sum_{k=0}^n u[k]u[n-k] = \\sum_{k=0}^n (1) = n + 1\n\\]\nTherefore (considering both \\(n&lt;0\\) and \\(n \\ge 0\\)), \\(r[n] = (n+1)u[n]\\). This is the unit ramp sequence and is shown in (e).\n\nusing Plots\n\nu(k)=begin\n    if k &gt;= 0 \n        1\n    else \n        0 \n    end \nend \n\nn = -3 \nxs = collect(-10:10)\ny_u_k = u.(xs) \ny_minus_u_k =  u.(xs*(-1)) \n\n#n &lt; 0 \ny_n_minus_k = u.((xs .- n)*(-1))\n\nu_k = plot(xs,y_u_k,seriestype=:sticks,markershape=:circle, ylimit=[0,2],legend=false,title=\"u(k) --- (a)\") \n\nu_minus_k = plot(xs,y_minus_u_k,seriestype=:sticks,markershape=:circle, ylimit=[0,2],legend=false,title=\"u(-k) --- (b)\") \n\nu_n_minus_k = plot(xs,y_n_minus_k,seriestype=:sticks,markershape=:circle, ylimit=[0,2],legend=false,title=\"u(n-k) n&lt;0 --- (c)\") \n\nn = 3 \n# n &gt; 0 \ny_n_minus_k = u.((xs .- n)*(-1))\nu_n_minus_k_n_gt_0 = plot(xs,y_n_minus_k,seriestype=:sticks,markershape=:circle, ylimit=[0,2],legend=false,title=\"u(n-k) n&gt;=0 --- (d)\") \n\nr(k) = u(k)*(k+1)\nr_sequence = r.(xs) \nr_n = plot(xs,r_sequence,seriestype=:sticks,markershape=:circle, ylimit=[0,12],legend=false,title=\"r(n) --- (e)\") \n\nplot(u_k,u_minus_k,u_n_minus_k,u_n_minus_k_n_gt_0,r_n,layout=(3,2))\n\n\n\n\nFigure 7: discrete convolution example"
  },
  {
    "objectID": "posts/signal-and-system/index.html#block-diagram-representation-of-continuous-signal-convolution-properties",
    "href": "posts/signal-and-system/index.html#block-diagram-representation-of-continuous-signal-convolution-properties",
    "title": "Signal and System a Primer",
    "section": "2.5 Block Diagram Representation of continuous signal convolution properties",
    "text": "2.5 Block Diagram Representation of continuous signal convolution properties\nThe commutative property of the convolution integral.\n\n\n\n\nflowchart LR \nsubgraph g1[1]\n    direction LR    \n    x[\"x(t)\" ]--&gt;h[\"h(t)\" ]--&gt;y[\"y(t)\"];\n    style x stroke-width:0px\n    style y stroke-width:0px\nend \n\nsubgraph g2[2]\n    direction LR \n    h1[\"h(t)\" ]--&gt;x1[\"x(t)\" ]--&gt;y1[\"y(t)\"];\n    style h1 stroke-width:0px\n    style y1 stroke-width:0px\nend \n\ng1-.-|equals|g2\n\n\n\n\n\nThe associative property of the convolution integral.\n\n\n\n\nflowchart LR \nsubgraph g1[1]\n    direction LR    \n    x[\"x(t)\" ]--&gt;h1[\"h1(t)\" ]--&gt;h2[\"h2(t)\" ]--&gt;y[\"y(t)\"];\n    style x stroke-width:0px\n    style y stroke-width:0px\nend \n\nsubgraph g2[2]\n    direction LR \n    xx[\"x(t)\" ]--&gt;convolution[\"h1(t)*h2(t)\" ]--&gt;yy[\"y(t)\"];\n    style xx stroke-width:0px\n    style yy stroke-width:0px\nend \n\ng1-.-|equals|g2\n\n\n\n\n\nThe distributive property of the convolution integral.\n\n\n\n\nflowchart LR \nsubgraph g1[1]\n    direction LR    \n    x[\"x(t)\"]--&gt;h1[\"h1(t)\"] & h2[\"h2(t)\"] \n    h1--&gt;y[\"y(t)\"] \n    h2--&gt;y \n    style x stroke-width:0px\n    style y stroke-width:0px\nend \n\nsubgraph g2[2]\n    direction LR \n    xx[\"x(t)\" ]--&gt;addition[\"h1(t)+h2(t)\" ]--&gt;yy[\"y(t)\"];\n    style xx stroke-width:0px\n    style yy stroke-width:0px\nend \n\ng1-.-|equals|g2"
  },
  {
    "objectID": "posts/signal-and-system/index.html#block-diagram-of-discrete-convolution-properties",
    "href": "posts/signal-and-system/index.html#block-diagram-of-discrete-convolution-properties",
    "title": "Signal and System a Primer",
    "section": "2.7 Block diagram of discrete convolution properties",
    "text": "2.7 Block diagram of discrete convolution properties\nThe commutative property\n\n\n\n\nflowchart LR \nsubgraph g1[1]\n    direction LR    \n    x[\"x[n]\" ]--&gt;h[\"h[n]\" ]--&gt;y[\"y[n]\"];\n    style x stroke-width:0px\n    style y stroke-width:0px\nend \n\nsubgraph g2[2]\n    direction LR \n    h1[\"h[n]\" ]--&gt;x1[\"x[n]\" ]--&gt;y1[\"y[n]\"];\n    style h1 stroke-width:0px\n    style y1 stroke-width:0px\nend \n\ng1-.-|equals|g2\n\n\n\n\n\nThe associative property\n\n\n\n\nflowchart LR \nsubgraph g1[1]\n    direction LR    \n    x[\"x[n]\" ]--&gt;h1[\"h1[n]\" ]--&gt;h2[\"h2[n]\" ]--&gt;y[\"y[n]\"];\n    style x stroke-width:0px\n    style y stroke-width:0px\nend \n\nsubgraph g2[2]\n    direction LR \n    xx[\"x[n]\" ]--&gt;convolution[\"h1[n]*h2[n]\" ]--&gt;yy[\"y[n]\"];\n    style xx stroke-width:0px\n    style yy stroke-width:0px\nend \n\ng1-.-|equals|g2\n\n\n\n\n\nThe distributive property\n\n\n\n\nflowchart LR \nsubgraph g1[1]\n    direction LR    \n    x[\"x[n]\"]--&gt;h1[\"h1[n]\"] & h2[\"h2[n]\"] \n    h1--&gt;y[\"y(t)\"] \n    h2--&gt;y \n    style x stroke-width:0px\n    style y stroke-width:0px\nend \n\nsubgraph g2[2]\n    direction LR \n    xx[\"x[n]\" ]--&gt;addition[\"h1[n]+h2[n]\" ]--&gt;yy[\"y[n]\"];\n    style xx stroke-width:0px\n    style yy stroke-width:0px\nend \n\ng1-.-|equals|g2"
  },
  {
    "objectID": "posts/signal-and-system/index.html#deconverlusion",
    "href": "posts/signal-and-system/index.html#deconverlusion",
    "title": "Signal and System a Primer",
    "section": "2.8 Deconverlusion",
    "text": "2.8 Deconverlusion"
  },
  {
    "objectID": "posts/signal-and-system/index.html#deconvolusion",
    "href": "posts/signal-and-system/index.html#deconvolusion",
    "title": "Signal and System a Primer",
    "section": "2.8 Deconvolusion",
    "text": "2.8 Deconvolusion"
  },
  {
    "objectID": "posts/signal-and-system/index.html#deconvolution",
    "href": "posts/signal-and-system/index.html#deconvolution",
    "title": "Signal and System a Primer",
    "section": "2.8 Deconvolution",
    "text": "2.8 Deconvolution"
  },
  {
    "objectID": "posts/arm-assembly/index.html#first-arm-assembly-program",
    "href": "posts/arm-assembly/index.html#first-arm-assembly-program",
    "title": "ARM汇编语言编程",
    "section": "01 - first arm assembly program",
    "text": "01 - first arm assembly program\nfirst.s\n.global main \n\nmain: \n    mov r0, #3 /* r0 is a register, #3 is an immediate value */\n    bx lr /*branch and exchange, link register*/"
  },
  {
    "objectID": "posts/arm-assembly/index.html#registers-and-basic-arithmetic",
    "href": "posts/arm-assembly/index.html#registers-and-basic-arithmetic",
    "title": "ARM汇编语言编程",
    "section": "02 - Registers and basic arithmetic",
    "text": "02 - Registers and basic arithmetic\nsum01.s\n/* \n    Registers and basic arithmetic \n    \n    r0 - r15, 32 bits integer registers in Raspberry PI; \n    \n    32 floating point registers; \n    \n    A program to add r1 and r2 and put the result to r0; \n    \n    A program to add r0 and r1 and put the result to r0; \n\n*/ \n\n.global main \n\nmain: \n    mov r1, #3\n    mov r2, #4 \n    add r0, r1, r2 \n    bx lr /* link register */\nsum02.s\n\n/* \n    Registers and basic arithmetic \n    \n    r0 - r15, 32 bits integer registers in Raspberry PI; \n    \n    32 floating point registers; \n    \n    A program to add r1 and r2 and put the result to r0; \n    \n    A program to add r0 and r1 and put the result to r0; \n\n*/ \n\n.global main \n\nmain: \n    mov r0, #4\n    mov r1, #5\n    add r0, r0, r1\n    bx lr /* link register */"
  },
  {
    "objectID": "posts/arm-assembly/index.html#memory-addresses.-load-and-store.",
    "href": "posts/arm-assembly/index.html#memory-addresses.-load-and-store.",
    "title": "ARM汇编语言编程",
    "section": "03 - Memory, addresses. Load and store.",
    "text": "03 - Memory, addresses. Load and store.\nload01.s\n/*\n    Memory, addresses. Load and store.\n    \n    Difference between x86 and ARM(Advanced RISC Machines)  \n    \n    ldr: load to register \n    str: store from register \n    \n    Address, Labels \n    \n    Code, Data \n    \n    .balign byte align \n    .word \n    \n    Sections: .text, .data \n    \n    load01.s & store01.s \n*/\n\n.data \n\n.balign 4 \nvar1: \n    .word 3 \n    \n.balign 4   \nvar2:\n    .word 6 \n\n.text \n.balign 4 \n.global main \nmain: \n    ldr r1, addr_var1\n    ldr r1,[r1]\n    \n    ldr r2, addr_var2\n    ldr r2,[r2]\n    \n    add r0,r1,r2 \n    bx lr \n    \n    \naddr_var1: \n    .word var1 \naddr_var2: \n    .word var2  \nstore01.s\n/*\n    Memory, addresses. Load and store.\n    \n    Difference between x86 and ARM(Advanced RISC Machines)  \n    \n    ldr: load to register \n    str: store from register \n    \n    Address, Labels \n    \n    Code, Data \n    \n    .balign byte align \n    .word \n    \n    Sections: .text, .data \n    \n    load01.s & store01.s \n*/\n\n.data \n\n.balign 4 \nvar1: \n    .word 0 \n    \n.balign 4   \nvar2:\n    .word 0  \n\n.text \n.balign 4 \n.global main \nmain: \n    mov r3, #6\n    \n    ldr r1, addr_var1\n    str r3, [r1]\n    \n    mov r3, #9\n    \n    ldr r1, addr_var2\n    str r3, [r1]\n\n    ldr r1, addr_var1\n    ldr r1,[r1]\n    \n    ldr r2, addr_var2\n    ldr r2,[r2]\n    \n    add r0,r1,r2 \n    bx lr \n    \n    \naddr_var1: \n    .word var1 \naddr_var2: \n    .word var2"
  },
  {
    "objectID": "posts/arm-assembly/index.html#gdb",
    "href": "posts/arm-assembly/index.html#gdb",
    "title": "ARM汇编语言编程",
    "section": "04 - GDB",
    "text": "04 - GDB\n# get help \nhelp \n\n# get help of a command \nhelp disassemble \n\nhelp breakpoints \n\nstart\n\nstepi \n\ninfo registers \n\n# continue to run to the next breakpoint or the end \ncontinue \n\n# print the addr of a \nprint &a \n\n# print the value of a with casting \nprint (int)a \n\n# examine 10 decimal values starting from the address &a \nx/10d &a\n\ndisassemble \n\n# disassemble instructions from 0x000103d0 to the addr with offset +40 bytes \ndisassemble 0x000103d0,+40 \n\n# set breakpoints at the address \nbreak *0x000103f0\n\n# query the current breakpoints \ni b \n\n# delete the 3rd breakpoint \ndelete 3"
  },
  {
    "objectID": "posts/arm-assembly/index.html#branches",
    "href": "posts/arm-assembly/index.html#branches",
    "title": "ARM汇编语言编程",
    "section": "05 - Branches",
    "text": "05 - Branches\nbranch01.s\n/*\nr0 - r15 \nr13: sp, stack pointer  \nr14: link register \nr15: pc, program counter, IP, instruction pointer \nb: branch \ncmp: compare \ncpsr: current progrm status register \nN (negative), Z (zero), C (carry) and V (overflow)\n*/\n\n.text \n.global main \nmain: \n    mov r0, #2\n    b end \n    mov r0, #3 \nend:\n    bx lr \ncompare00.s\n/*\ndemonstrate how subtract operation affects the Carry bit of cpsr \n*/\n.text \n.global main \nmain: \n    mov r1, #2 \n    mov r2, #1 \n    cmp r1, r2 \n    mov r0, #0 \n    bx lr \ncompare01.s\n/*\n*/\n.text \n.global main \nmain: \n    mov r1, #3 \n    mov r2, #2 \n    cmp r1, r2 \n    beq case_eq\ncase_neq: \n    mov r0, #6  \n    b end \ncase_eq: \n    mov r0, #5\nend: \n    bx lr \ncpsr_decode.py\ncpsr = 0x20000010\n#cpsr is an integer \ndef cpsr_decode(cpsr):\n    bit_names = {} \n    bit_names[\"n_bit\"] = 0x80_00_00_00 #negative\n    bit_names[\"z_bit\"] = 0x40_00_00_00 #zero \n    bit_names[\"c_bit\"] = 0x20_00_00_00 #carry \n    bit_names[\"v_bit\"] = 0x10_00_00_00 #overflow\n    \n    for name,bit in bit_names.items():\n        if cpsr & bit != 0:\n            print(name,\"is set\")\n        else:\n            print(name,\"is not set\")\n\ncpsr_decode(cpsr)"
  },
  {
    "objectID": "posts/arm-assembly/index.html#control-structures",
    "href": "posts/arm-assembly/index.html#control-structures",
    "title": "ARM汇编语言编程",
    "section": "06 - Control structures",
    "text": "06 - Control structures\nif01.s\n.text \n.global main \n/* check if the number in r1 is odd or even*/\nmain:\n    mov r1, #2022\n\nif:\n    tst r1, #1 /* cpsr: current program status register*/\n    bne else\nthen: /* r1 is even */\n    mov r0, #2\n    b end_if \nelse: /* r1 is odd */ \n    mov r0, #1\nend_if:\n    bx lr \nloop01.s\n.text \n.global main\n/* calculate the sum 1..22 */ \nmain: \n    mov r1, #0 /* store sum */ \n    mov r2, #1 /* counter */ \nloop: \n    cmp r2, #22 /* cpsr updated */ \n    bgt end_loop \n    add r1, r1, r2 \n    add r2, r2, #1 \n    b loop \nend_loop:\n    mov r0, r1 \n    bx lr"
  },
  {
    "objectID": "posts/arm-assembly/index.html#indexing-modes",
    "href": "posts/arm-assembly/index.html#indexing-modes",
    "title": "ARM汇编语言编程",
    "section": "07 - Indexing modes",
    "text": "07 - Indexing modes\nshift01.s\n/*\nARM assembler in Raspberry Pi\n\n07 Indexing modes: \nAllowed operands in instructions are collectively called indexing modes \n\n\nshifted operand \n\noperator/operand \n\nldr, str, bxx \n\nmov\n\nadd, sub, rsb, cmp, and, tst\n\nregister/immediate values \n\nSyntax of most of the ARM instructions:\ninstruction Rdest, Rsource1, source2\n\nsource2 is either a register or an immediate value\n\nWhen source2 is a register, we can combine it with a shift operation. \n\nLSL #n\nLSL Rsource3 \n\nLSR #n\nLSR Rsource3 \n\nASR #n\nASR Rsource3 \n\nROR #n \nROR Rsource3 \n\n#n can be 1..31. shift is an operation instead of an instruction. shift operation can be used to perform multiplication and division. \n*/\n\n.text \n.global main \nmain: \n    mov r0,#2\n    /*add r0, r0, r0, lsl #1*/\n    mov r0,r0,lsl #2\n    bx lr"
  },
  {
    "objectID": "posts/arm-assembly/index.html#reference",
    "href": "posts/arm-assembly/index.html#reference",
    "title": "ARM汇编语言编程",
    "section": "Reference",
    "text": "Reference\nARM assembler in Raspberry Pi"
  },
  {
    "objectID": "posts/arm-assembly/index.html#functions.-the-stack",
    "href": "posts/arm-assembly/index.html#functions.-the-stack",
    "title": "ARM汇编语言编程",
    "section": "10 Functions. The stack",
    "text": "10 Functions. The stack\n// stm -- store multiple, i -- increase, a -- after, d -- decrease, b -- before \nstmia, stmib, stmda, stmdb, ldmia, ldmib, ldmda, ldmdb \n\n// push is equivalent to stmdb, pop is equivalent to ldmia when operating on sp \npush, pop\n\n// multiplication instruction \nmul Rdest, Rsource1, Rsource2.\n\nDynamic activation\nOne of the benefits of functions is being able to call them more than once. A function may call itself.\nA function is dynamically activated each time it is called. The span of a dynamic activation goes from the point where the function is called until it returns. At a given time, more than one function is dynamically activated. The whole dynamic activation set of functions includes the current function and the dynamic activation set of the function that called it (the current function).\n//Example recursive function that calls itself \nint factorial(int n)\n{\n   if (n == 0)\n      return 1;\n   else\n      return n * factorial(n-1);\n}\nWell behaved functions(Refer to Chap9), a brief recall:\n\nOnly r0, r1, r2 and r3 can be freely modified.\nlr(r14) value at the entry of the function must be kept somewhere because we will need it to leave the function (to return to the caller).\nAll other registers r4 to r11 and sp(r13) can be modified but they must be restored to their original values upon leaving the function.\n\nNote: pc register is r15. TBD: What’s the function of r12 function? Why is it not mentioned here?\nwe need some way to keep at least the value of lr per each dynamic activation. And not only lr, if we wanted to use registers from r4 to r11 we also need to keep somehow per each dynamic activation, a global variable would not be enough either. This is where the stack comes into play.\n\n\nThe stack\nIn computing, a stack is a data structure (a way to organize data that provides some interesting properties). A stack typically has three operations: access the top of the stack, push onto the top, pop from the top. Dependening on the context you can only access the top of the stack, in our case we will be able to access more elements than just the top.\nBut, what is the stack? I already said in chaper 9 that the stack is a region of memory owned solely by the function. We can now reword this a bit better: the stack is a region of memory owned solely by the current dynamic activation. register sp stands for stack pointer. This register will contain the top of the stack. The region of memory owned by the dynamic activation is the extent of bytes contained between the current value of sp and the initial value that sp had at the beginning of the function. We will call that region the local memory of a function (more precisely, of a dynamic activation of it). We will put there whatever has to be saved at the beginning of a function and restored before leaving. We will also keep there the local variables of a function (dynamic activation).\nOur function also has to adhere to some rules when handling the stack.\n\nThe stack pointer (sp) is always 4 byte aligned. This is absolutely mandatory. However, due to the Procedure Call Standard for the ARM architecture (AAPCS), the stack pointer will have to be 8 byte aligned, otherwise funny things may happen when we call what the AAPCS calls as public interfaces (this is, code written by other people). (Note: It means we can persist in 4 byte aligned if the function we are written is only called by ourself, and we won’t call functions written by other persons; otherwise, we should persist in 8 byte algined.)\n\nThe value of sp when leaving the function should be the same value it had upon entering the function.\n\nIt is a convention how the stack, and thus the local memory, has its size defined. The stack can grow upwards or downwards. If it grows upwards it means that we have to increase the value of the sp register in order to enlarge the local memory. If it grows downwards we have to do the opposite, the value of the sp register must be subtracted as many bytes as the size of the local storage. In Linux ARM, the stack grows downwards, towards zero (although it never should reach zero). Addresses of local variables have very large values in the 32 bit range. They are usually close to \\(2^{32}\\).\nAnother convention when using the stack concerns whether the sp register contains the address of the top of the stack or some bytes above. In Linux ARM the sp register directly points to the top of the stack: in the memory addressed by sp there is useful information.\nExample snippets of keep lr register and restore lr register. (Note: We can use add and sub to operate sp, we may also use push and pop or stmxx and ldmxx instructions.)\nsub sp, sp, #8  /* sp ← sp - 8. This enlarges the stack by 8 bytes */\nstr lr, [sp]    /* *sp ← lr */\n... // Code of the function\nldr lr, [sp]    /* lr ← *sp */\nadd sp, sp, #8  /* sp ← sp + 8. /* This reduces the stack by 8 bytes\n                                effectively restoring the stack \n                                pointer to its original value */\nbx lr\nShortened snippets of keep lr and restore lr, making use of indexing modes.\nstr lr, [sp, #-8]!  /* preindex: sp ← sp - 8; *sp ← lr */\n... // Code of the function\nldr lr, [sp], #+8   /* postindex; lr ← *sp; sp ← sp + 8 */\nbx lr\n\n\nFirst approach to implement the factorial function\nIt uses the mul Rdest, Rsource1, Rsource2 instruction.\nThis instruction only computes the lower 32 bits. Because we are not going to use 64 bit values in this example, the maximum factorial we will be able to compute is 12! (13! is bigger than \\(2^{32}\\)).\nThis approach directly operates on the sp register.\n/* -- factorial01.s */\n.data\n\nmessage1: .asciz \"Type a number: \"\nformat:   .asciz \"%d\"\nmessage2: .asciz \"The factorial of %d is %d\\n\"\n\n.text\n\nfactorial:\n    str lr, [sp,#-4]!  /* Push lr onto the top of the stack */\n    str r0, [sp,#-4]!  /* Push r0 onto the top of the stack */\n                       /* Note that after that, sp is 8 byte aligned */\n    cmp r0, #0         /* compare r0 and 0 */\n    bne is_nonzero     /* if r0 != 0 then branch */\n    mov r0, #1         /* r0 ← 1. This is the return */\n    b end\nis_nonzero:\n                       /* Prepare the call to factorial(n-1) */\n    sub r0, r0, #1     /* r0 ← r0 - 1 */\n    bl factorial\n                       /* After the call r0 contains factorial(n-1) */\n                       /* Load r0 (that we kept in th stack) into r1 */\n    ldr r1, [sp]       /* r1 ← *sp */\n    mul r0, r0, r1     /* r0 ← r0 * r1 */\n    \nend:\n    add sp, sp, #+4    /* Discard the r0 we kept in the stack */\n    ldr lr, [sp], #+4  /* Pop the top of the stack and put it in lr */\n    bx lr              /* Leave factorial */\n\n.global main\nmain:\n    str lr, [sp,#-4]!            /* Push lr onto the top of the stack */\n    sub sp, sp, #4               /* Make room for one 4 byte integer in the stack */\n                                 /* In these 4 bytes we will keep the number */\n                                 /* entered by the user */\n                                 /* Note that after that the stack is 8-byte aligned */\n    ldr r0, address_of_message1  /* Set &message1 as the first parameter of printf */\n    bl printf                    /* Call printf */\n\n    ldr r0, address_of_format    /* Set &format as the first parameter of scanf */\n    mov r1, sp                   /* Set the top of the stack as the second parameter */\n                                 /* of scanf */\n    bl scanf                     /* Call scanf */\n\n    ldr r0, [sp]                 /* Load the integer read by scanf into r0 */\n                                 /* So we set it as the first parameter of factorial */\n    bl factorial                 /* Call factorial */\n\n    mov r2, r0                   /* Get the result of factorial and move it to r2 */\n                                 /* So we set it as the third parameter of printf */\n    ldr r1, [sp]                 /* Load the integer read by scanf into r1 */\n                                 /* So we set it as the second parameter of printf */\n    ldr r0, address_of_message2  /* Set &message2 as the first parameter of printf */\n    bl printf                    /* Call printf */\n\n\n    add sp, sp, #+4              /* Discard the integer read by scanf */\n    ldr lr, [sp], #+4            /* Pop the top of the stack and put it in lr */\n    bx lr                        /* Leave main */\n\naddress_of_message1: .word message1\naddress_of_message2: .word message2\naddress_of_format: .word format\n\n\nDo it better using ldm and stm\nNote that the number of instructions that we need to push and pop data to and from the stack grows linearly with respect to the number of data items. Since ARM was designed for embedded systems, ARM designers devised a way to reduce the number of instructions we need for the «bookkeeping» of the stack. These instructions are load multiple, ldm, and store multiple, stm.\nThese two instructions are rather powerful and allow in a single instruction perform a lot of things. Their syntax is shown as follows. Elements enclosed in curly braces { and } may be omitted from the syntax (the effect of the instruction will vary, though).\nldm addressing-mode Rbase{!}, register-set\nstm addressing-mode Rbase{!}, register-set\nWe will consider addressing-mode later. Rbase is the base address used to load to or store from the register-set. All 16 ARM registers may be specified in register-set (except pc in stm). A set of addresses is generated when executing these instructions. One address per register in the register-set. Then, each register, in ascending order, is paired with each of these addresses, also in ascending order. This way the lowest-numbered register gets the lowest memory address, and the highest-numbered register gets the highest memory address. Each pair register-address is then used to perform the memory operation: load or store. Specifying ! means that Rbase will be updated. The updated value depends on addressing-mode.\nNote that, if the registers are paired with addresses depending on their register number, it seems that they will always be loaded and stored in the same way. For instance a register-set containing r4, r5 and r6 will always store r4 in the lowest address generated by the instruction and r6 in the highest one(Note: Since it is a set, the order does not matter. r4, r5, r6 and r4, r6, r5 mean the same thing in a set). We can, though, specify what is considered the lowest address or the highest address. So, is Rbase actually the highest address or the lowest address of the multiple load/store? This is one of the two aspects that is controlled by addressing-mode. The second aspect relates to when the address of the memory operation changes between each memory operation.\nIf the value in Rbase is to be considered the the highest address it means that we should first decrease Rbase as many bytes as required by the number of registers in the register-set (this is 4 times the number of registers) to form the lowest address. Then we can load or store each register consecutively starting from that lowest address, always in ascending order of the register number. This addressing mode is called decreasing and is specified using a d. Conversely, if Rbase is to be considered the lowest address, then this is a bit easier as we can use its value as the lowest address already. We proceed as usual, loading or storing each register in ascending order of their register number. This addressing mode is called increasing and is specified using an i.\nAt each load or store, the address generated for the memory operation may be updated after or before the memory operation itself. We can specify this using a or b, respectively.\nIf we specify !, after the instruction, Rbase will have the highest address generated in the increasing mode and the lowest address generated in the decreasing mode. The final value of Rbase will include the final addition or subtraction if we use a mode that updates after (an a mode).\nSo we have four addressing modes, namely: ia, ib, da and db. These addressing modes are specified as suffixes of the stm and ldm instructions. So the full set of names is stmia, stmib, stmda, stmdb, ldmia, ldmib, ldmda, ldmdb. Now you may think that this is overly complicated, but we need not use all the eight modes. Only two of them are of interest to us now.\nWhen we push something onto the stack we actually decrease the stack pointer (because in Linux the stack grows downwards). More precisely, we first decrease the stack pointer as many bytes as needed before doing the actual store on that just computed stack pointer. So the appropiate addressing-mode when pushing onto the stack is stmdb. Conversely when popping from the stack we will use ldmia: we increment the stack pointer after we have performed the load.\n\n\nFactorial again using stm or push and ldm or pop\nBefore illustrating these two instructions, we will first slightly rewrite our factorial.\nIf you go back to the code of our factorial, there is a moment, when computing n * factorial(n-1), where the initial value of r0 is required. The value of n was in r0 at the beginning of the function, but r0 can be freely modified by called functions.\nIn our second version of factorial, we will keep a copy of the initial value of r0 into r4. But r4 is a register the value of which must be restored upon leaving a function. So we will keep the value of r4 at the entry of the function in the stack. At the end we will restore it back from the stack. This way we can use r4 without breaking the rules of well-behaved functions.\nfactorial:\n    str lr, [sp,#-4]!  /* Push lr onto the top of the stack */\n    str r4, [sp,#-4]!  /* Push r4 onto the top of the stack */\n                       /* The stack is now 8 byte aligned */\n    mov r4, r0         /* Keep a copy of the initial value of r0 in r4 */\n\n\n    cmp r0, #0         /* compare r0 and 0 */\n    bne is_nonzero     /* if r0 != 0 then branch */\n    mov r0, #1         /* r0 ← 1. This is the return */\n    b end\nis_nonzero:\n                       /* Prepare the call to factorial(n-1) */\n    sub r0, r0, #1     /* r0 ← r0 - 1 */\n    bl factorial\n                       /* After the call r0 contains factorial(n-1) */\n                       /* Load initial value of r0 (that we kept in r4) into r1 */\n    mov r1, r4         /* r1 ← r4 */\n    mul r0, r0, r1     /* r0 ← r0 * r1 */\n\nend:\n    ldr r4, [sp], #+4  /* Pop the top of the stack and put it in r4 */\n    ldr lr, [sp], #+4  /* Pop the top of the stack and put it in lr */\n    bx lr              /* Leave factorial */\nThe above program can be improved via stmdb and ldmia as below:\nfactorial:\n    stmdb sp!, {r4, lr} /* Push r4 and lr onto the stack */\n     \n                       /* The stack is now 8 byte aligned */\n    mov r4, r0         /* Keep a copy of the initial value of r0 in r4 */\n\n\n    cmp r0, #0         /* compare r0 and 0 */\n    bne is_nonzero     /* if r0 != 0 then branch */\n    mov r0, #1         /* r0 ← 1. This is the return */\n    b end\nis_nonzero:\n                       /* Prepare the call to factorial(n-1) */\n    sub r0, r0, #1     /* r0 ← r0 - 1 */\n    bl factorial\n                       /* After the call r0 contains factorial(n-1) */\n                       /* Load initial value of r0 (that we kept in r4) into r1 */\n    mov r1, r4         /* r1 ← r4 */\n    mul r0, r0, r1     /* r0 ← r0 * r1 */\n\nend:\n    ldmia sp!, {r4, lr}    /* Pop lr and r4 from the stack */\n    bx lr              /* Leave factorial */\nNote that the order of the registers in the set of registers is not relevant(the order of elements in a set does not matter), but the processor will handle them in ascending order, so we should write them in ascending order. GNU assembler will emit a warning otherwise. Since lr is actually r14 it must go after r4. This means that our code is 100% equivalent to the previous one since r4 will end in a lower address than lr: remember our stack grows toward lower addresses, thus r4 which is in the top of the stack in factorial has the lowest address.\nRemembering stmdb sp! and ldmia sp! may be a bit hard. Also, given that these two instructions will be relatively common when entering and leaving functions, GNU assembler provides two mnemonics push and pop for stmdb sp! and ldmia sp!, respectively. Note that these are not ARM instructions actually, just convenience names that are easier to remember.\nThe above program can be improved via push and pop as below:\nfactorial:\n    push {r4, lr} /* Push r4 and lr onto the stack */\n     \n                       /* The stack is now 8 byte aligned */\n    mov r4, r0         /* Keep a copy of the initial value of r0 in r4 */\n\n\n    cmp r0, #0         /* compare r0 and 0 */\n    bne is_nonzero     /* if r0 != 0 then branch */\n    mov r0, #1         /* r0 ← 1. This is the return */\n    b end\nis_nonzero:\n                       /* Prepare the call to factorial(n-1) */\n    sub r0, r0, #1     /* r0 ← r0 - 1 */\n    bl factorial\n                       /* After the call r0 contains factorial(n-1) */\n                       /* Load initial value of r0 (that we kept in r4) into r1 */\n    mov r1, r4         /* r1 ← r4 */\n    mul r0, r0, r1     /* r0 ← r0 * r1 */\n\nend:\n    pop {r4, lr}    /* Pop lr and r4 from the stack */\n    bx lr              /* Leave factorial */"
  },
  {
    "objectID": "posts/arm-assembly/index.html#predication",
    "href": "posts/arm-assembly/index.html#predication",
    "title": "ARM汇编语言编程",
    "section": "11 Predication",
    "text": "11 Predication\nPredication on wikipedia\nInstruction suffix\neq, neq, le, lt, ge, gt, al(always, can be omitted)"
  },
  {
    "objectID": "posts/arm-assembly/index.html#loops-and-the-status-register",
    "href": "posts/arm-assembly/index.html#loops-and-the-status-register",
    "title": "ARM汇编语言编程",
    "section": "12 loops and the status register",
    "text": "12 loops and the status register\nadds(add and update the cpsr)\nsubs\nbpl(branch if plus, branch if the negative flag is clear)\n\nOperating 64 bit numbers\nadcs(add with carry, update the cpsr)\nsbc(subtract with carry)\nmultiplication"
  },
  {
    "objectID": "posts/x86-64-assembly/index.html",
    "href": "posts/x86-64-assembly/index.html",
    "title": "x86-64汇编语言编程",
    "section": "",
    "text": "This is a note while studying x86-64 assembler."
  },
  {
    "objectID": "posts/x86-64-assembly/index.html#hello-world-program",
    "href": "posts/x86-64-assembly/index.html#hello-world-program",
    "title": "x86-64汇编语言编程",
    "section": "Hello world program",
    "text": "Hello world program\nThe program is copied from x86-64 Assembly on youtube, from Mike Shah\nIt refers to the linux syscall table\nIn intel format.\n/*first.s*/\n.intel_syntax noprefix\n.global _start \n.hello.str: \n    .ascii \"12345678\\n\" \n\n.text \n\n_start: \n    movq rbp, rsp \n    movq rax, 1  \n    movq rdi, 1  \n    leaq rsi, .hello.str  \n    movq rdx, 9  \n    syscall \n    \n    movq rax, 60  \n    movq rdi, 0  \n    syscall \n    \n    pop rbp \nTo build it.\nas -o first.o first.s \nld -o first first.o \nIn AT&T format.\n/*first.s*/\n\n.global _start \n.hello.str: \n    .ascii \"12345678\\n\" \n\n.text \n\n_start: \n    movq %rsp, %rbp \n    movq $1, %rax    \n    movq $1, %rdi   \n    leaq .hello.str, %rsi    \n    movq $9, %rdx  \n    syscall \n    \n    movq $60, %rax  \n    movq $0, %rdi   \n    syscall \n    \n    pop %rbp \nTo build it. The below 2 ways are both OK.\nas -o first.o first.s \nld -o first first.o \n\ngcc -c first.s -o first.o \nld -o first first.o"
  },
  {
    "objectID": "posts/x86-64-assembly/index.html#call",
    "href": "posts/x86-64-assembly/index.html#call",
    "title": "x86-64汇编语言编程",
    "section": "call",
    "text": "call\n/*first.s*/\n# there is also .bss segment for not initialized global data \n.data \n.hello.str: \n    .ascii \"12345678\\n\" \n\n.text \n\n_write_str: \n    movq %rsp, %rbp \n    movq $1, %rax    \n    movq $1, %rdi   \n    leaq .hello.str, %rsi    \n    movq $9, %rdx  \n    syscall \n    ret \n_exit:\n    movq $60, %rax  \n    movq $0, %rdi   \n    syscall \n    ret \n\n.global _start \n_start: \n    call _write_str \n    call _exit \n    pop %rbp"
  },
  {
    "objectID": "posts/x86-64-assembly/index.html#chap1-its-all-in-the-plan-understanding-what-computers-really-do",
    "href": "posts/x86-64-assembly/index.html#chap1-its-all-in-the-plan-understanding-what-computers-really-do",
    "title": "x86-64汇编语言编程",
    "section": "Chap1 It’s all in the Plan: Understanding What Computers Really Do",
    "text": "Chap1 It’s all in the Plan: Understanding What Computers Really Do\nA computer program is a list of steps and tests, nothing more.\nA test is the sort of either/or decision we make. - First, you take a look at sth that can go one of two way. - Then you do one of two things, depending on what you saw when you took a look."
  },
  {
    "objectID": "posts/x86-64-assembly/index.html#chap2-allien-bases-getting-your-arms-around-binary-and-hexadecimal",
    "href": "posts/x86-64-assembly/index.html#chap2-allien-bases-getting-your-arms-around-binary-and-hexadecimal",
    "title": "x86-64汇编语言编程",
    "section": "Chap2 Allien Bases: Getting Your Arms Around Binary and Hexadecimal",
    "text": "Chap2 Allien Bases: Getting Your Arms Around Binary and Hexadecimal\noctal\nhexadecimal\nbinary"
  },
  {
    "objectID": "posts/x86-64-assembly/index.html#chap3-lifting-the-hood-discovering-what-computers-actually-are",
    "href": "posts/x86-64-assembly/index.html#chap3-lifting-the-hood-discovering-what-computers-actually-are",
    "title": "x86-64汇编语言编程",
    "section": "Chap3 Lifting the Hood: Discovering What Computers Actually Are",
    "text": "Chap3 Lifting the Hood: Discovering What Computers Actually Are\nA bit is a single binary digit, either 1 or 0.\nA byte is eight bits.\nTwo bytes side by side are called a word.\nTwo words side by side are called a double word.\nA quad word consists of two double words.\nA group of four bits is called a nybble."
  },
  {
    "objectID": "posts/x86-64-assembly/index.html#chap4-location-registers-memory-addressing-and-knowing-where-things-are",
    "href": "posts/x86-64-assembly/index.html#chap4-location-registers-memory-addressing-and-knowing-where-things-are",
    "title": "x86-64汇编语言编程",
    "section": "Chap4 Location: Registers, Memory Addressing, and Knowing Where Things Are",
    "text": "Chap4 Location: Registers, Memory Addressing, and Knowing Where Things Are\nThe skill of assembly language consists of a deep comprehension of memory addressing. Everything else is details – and easy details, at that.\nThere are a fair number of different ways to address memory in the Intel/AMD CPU family. Each of these ways is called a Memory Model. There are 3 major memory models that you can use with the more recent members of the Intel family, and a number of minor variations on those three, especially the one in the middle.\nReal mode flat model.\nReal mode segmented model.\nProtected-mode flat model(32-bit and 64-bit).\nThe 8080 was an 8-bit CPU(its general-purpose registers have 8-bits), meaning that it processed 8 bits of information at a time. However, it had 16 address lines coming out of it(it will address 64KB).\nThe 8080 memory-addressing scheme was very simple. You put a 16-bit address out on the address lines, and you got back the 8-bit value that was stored at that address.\nThe 8086 comes after 8080. It is 16-bit CPU. It has 20 address lines.\nThe 8080 is used a lot. Intel wanted to make it easy for people to translate older software from the 8080 to 8086. One way to do this was to make sure that a 16-bit addressing system such as that of the 8080 still worked. Even though the 8086 could address 16 times as much memory as the 8080(16x64KB=1MB), Intel setup the 8086 so that a program could take some 64 KB segment within that megabyte of memory and run entirely inside it, just as though it were the smaller 8080 memory system. This was done by the use of segment registers.\nSpeaking of the 8086 and 8088, there are 4 segment registers(CS, DS, …).\nThis was very wise short-term thinking and catastrophically bad long-term thinking. Programs that needed more than 64KB of memory at a time had to use memory in 64KB chunks, switching between chunks by switching values into and out of segment registers.\nTo maintain backward compatibility with the ancient 8086 and 8088, newer CPUs were given the power to limit themselves to what the older chips could address and execute. When a Pentium-class or better CPU needs to run software written for the real-mode segmented model, it pulls a neat trick that, temporarily, make it become an 8086. This was called virtual-86 mode, and it provided excellent backward compatibility for DOS software.\nA segment may start every 16 bytes throughout the full megabyte of real memory.\nCS, DS, SS, ES, FS, GS: Segment registers. All segment registers are 16 bits in size, irrespective of the CPU. FS and GS exist only in the 386 and later Intel x86 32-bit CPUs.\nCS: Code Segment\nDS: Data Segment\nSS: Stack Segment\nES: Extra segment\nFS, GS: Clones of ES\nSegment registers become useless in application programming in X86-64. Operating systems use two of them for special purposes.\nDo Intel’s x86-64 CPUs have 64 address lines? No (48 or 52).\nIn the x86-64 world, CPUs have 14 general purpose 64-bit registers, plus SP and BP.\nThere are eight 16-bit general-purpose registers: AX, BX, CX, DX, BP, SI, DI, SP (8086, 8088, 80186 and 80286).\nEAX, EBX, ECX, EDX, EBP, ESI, EDI, ESP. (32 bitS)\nRAX, RBX, RCX, RDX, RBP, RSI, RDI, RSP. R8 to R15. (64 BITS)\nRAX(EAX(AX(AH,AL)))\nRBX(EBX(BX(BH,BL)))\nRCX(ECX(CX(CH,CL)))\nRDX(EDX(DX(DH,DL)))\nRSI(ESI(SI(SIL))) and so on for RDI, RSP.\nRIP, EIP, IP\nThe new x64 registers R8-R15 can be addressed as 64 bits, 32 bits, 16 bits, and 8 bits. However, the AH/AL scheme for the low 16 bits is a trick reserved for only RAX-RDX. The naming scheme for the R registers provides a mnemonic: D for double word, W for word, and B for byte. For example, if you want to deal with the lowest 8 bits of R8, you use the name R8B. Don’t make the beginner’s mistake of assuming that R8, R8D, R8W, and R8B are four separate and independent registers! A better metaphor is to think of the register names as country/state/county/city.\nIP register.\nWhile executing a program, the CPU uses IP to keep track of where it is in the current code segment. Instructions come in different sizes, ranging typically from 1 to 15 bytes. The CPU knows the size of each instruction it executes.\nIP is notable in being the only register that can neither be read nor written to directly.\nFlags register.\nRFLAGS, EFLAGS, FLAGS. When the flag’s value is 1, we say that the flag is set. When the flag’s value is 0, we say that the flag is cleared.\nMath Coprocessors and Their Registers (may be 128 bits or 256 bits)\nReal-Mode Flat Model\nReal-Mode Segmented Model\n32-bit Protected Mode Flat Model\n64-bit Long Mode"
  },
  {
    "objectID": "posts/x86-64-assembly/index.html#chap5-the-right-to-assemble-the-process-of-creating-assembly-language-programs",
    "href": "posts/x86-64-assembly/index.html#chap5-the-right-to-assemble-the-process-of-creating-assembly-language-programs",
    "title": "x86-64汇编语言编程",
    "section": "Chap5 The Right to Assemble: The Process of Creating Assembly Language Programs",
    "text": "Chap5 The Right to Assemble: The Process of Creating Assembly Language Programs\nText files: are files that can be opened and examined meaningfully in a text editor, like notepad.\nBinary files: are files containing values that do not display meaningfully as text.\nAssemblers: read your source code files and generate an object code file containing the machine instructions that the CPU understands plus any data you’ve defined in your source code.\nLinker: Object code files cannot themselves be run as programs. An additional step, called linking, is necessary to turn object code files into executable program files.\nSymbol table: To process several object modules into a single executable module, the linker must first build an index called a symbol table, with an entry for every named item in every object module it links, with information on what name (called a symbol) refers to what location within the module.\nExe: Once the symbol table is complete, the linker builds an image of how the executable program will be arranged in memory when the operating system loads it. This image is then to disk as the executable file. The most important thing about the image that the linker builds relates to addresses.\nHoles: Object modules are allowed to refer to symbols in other object modules. During assembly, these external references are left as holes to be filled later—naturally enough, because the module in which these external symbolsexist may not have been assembled or even written yet. As the linker builds animage of the eventual executable program file, it learns where all of the symbols are located within the image and thus can drop real addresses into all of the external reference holes.\nDebugging info: Debugging information is, in a sense, a step backward. Portions of the source code, which was all stripped out early in the assembly process, are put back into the object module by the assembler. These portions of the source code are mostly the names of data items and procedures, and they’re embedded in the object file to make it easier for the programmer (you!) to see the names of data items when you debug the program.\nRelocatability: Primordial microcomputers like 8080 systems running CP/M-80 had a simple memory architecture. Programs were written to be loaded and run at a specific physical memory address. For CP/M, this was 0100H. The programmer could assume that any program would start at 0100H and go up from there. Memory addresses of data items and procedures were actual physical addresses, and every time the program ran, its data items were loaded and referenced at precisely the same place in memory. This all changed with the arrival of the 8086, and 8086-specific operating systems such as CP/M-86 and PC DOS. Improvements in the Intel architecture introduced with the 8086 made it unnecessary for the program to be assembled for running at any specific physical memory address. This feature is called relocatability and is a necessary part of any modern operating system, especially when multiple programs may be running at once.\nThe author uses nasm. To compile an ASM file. Also SASM IDE for editing, building and debugging. SASM means SimpleAssembler.\nnasm -f elf64 -g -Fdwarf first.asm"
  },
  {
    "objectID": "posts/x86-64-assembly/index.html#misc",
    "href": "posts/x86-64-assembly/index.html#misc",
    "title": "x86-64汇编语言编程",
    "section": "misc",
    "text": "misc\nGCC(Gnu Compiler Collection) is a front end. It will call as and ld. The process can be viewed if we use -v argument of gcc.\nUsing -g argument will embed debug info in the object file. E.g. gcc -c first.s -o first.o -g. After that, we are able to use list in GDB to view the source code.\nBelow table lists the size of x86-64 memory/registers. Some is different from ARM. For example, in ARM, A .word means 32 bits.\n\n\n\nterm\nsize (bits)\n\n\n\n\nbyte\n8\n\n\nword\n16\n\n\ndword\n32\n\n\nqword\n64\n\n\n\nIn x86-64, use .long or .int to specify 64 bits integer. In ARM, use .word to specify 32 bits integer. Note, .word or .short may have different lengths in different machine. They are machine dependent.\nSTDIN file descriptor is 0. STDOUT file descriptor is 1. STDERR file descriptor is 2.\nThe labels in the assembly program begins with _, e.g. _start, is due to the convention of C compiler. It is the simple name mangaling. C++ has more complex name mangling."
  },
  {
    "objectID": "posts/x86-64-assembly/index.html#call-instruction-to-call-a-function",
    "href": "posts/x86-64-assembly/index.html#call-instruction-to-call-a-function",
    "title": "x86-64汇编语言编程",
    "section": "call instruction to call a function",
    "text": "call instruction to call a function\n/*first.s*/\n# there is also .bss segment for not initialized global data \n.data \n.hello.str: \n    .ascii \"12345678\\n\" \n\n.text \n\n_write_str: \n    movq %rsp, %rbp \n    movq $1, %rax    \n    movq $1, %rdi   \n    leaq .hello.str, %rsi    \n    movq $9, %rdx  \n    syscall \n    ret \n_exit:\n    movq $60, %rax  \n    movq $0, %rdi   \n    syscall \n    ret \n\n.global _start \n_start: \n    call _write_str \n    call _exit \n    pop %rbp"
  },
  {
    "objectID": "posts/x86-64-assembly/index.html#the-64-bit-x86-c-calling-convention",
    "href": "posts/x86-64-assembly/index.html#the-64-bit-x86-c-calling-convention",
    "title": "x86-64汇编语言编程",
    "section": "The 64 bit x86 C Calling Convention",
    "text": "The 64 bit x86 C Calling Convention\nThe section is copied from x86-64 call convention. It is for Linux. Microsoft windows does not follow the same convention. Refer to x64 calling convention, Microsoft.\npop, push, call, ret instructions.\nThe caller’s rules:\n\nBefore calling a subroutine, the caller should save the contents of certain registers that are designated caller-saved. The caller-saved registers are r10, r11, and any registers that parameters are put into. If you want the contents of these registers to be preserved across the subroutine call, push them onto the stack.\nTo pass parameters to the subroutine, we put up to six of them into registers (in order: rdi, rsi, rdx, rcx, r8, r9). If there are more than six parameters to the subroutine, then push the rest onto the stack in reverse order (i.e. last parameter first) – since the stack grows down, the first of the extra parameters (really the seventh parameter) parameter will be stored at the lowest address (this inversion of parameters was historically used to allow functions to be passed a variable number of parameters).\nTo call the subroutine, use the call instruction. This instruction places the return address on top of the parameters on the stack, and branches to the subroutine code.\nAfter the subroutine returns, (i.e. immediately following the call instruction) the caller must remove any additional parameters (beyond the six stored in registers) from stack. This restores the stack to its state before the call was performed.\nThe caller can expect to find the return value of the subroutine in the register RAX.\nThe caller restores the contents of caller-saved registers (r10, r11, and any in the parameter passing registers) by popping them off of the stack. The caller can assume that no other registers were modified by the subroutine.\n\nThe Callee’s Rules:\n\nAllocate local variables by using registers or making space on the stack. Recall, the stack grows down, so to make space on the top of the stack, the stack pointer should be decremented. The amount by which the stack pointer is decremented depends on the number of local variables needed. For example, if a local float and a local long (12 bytes total) were required, the stack pointer would need to be decremented by 12 to make space for these local variables: sub rsp, 12. As with parameters, local variables will be located at known offsets from the stack pointer.\nNext, the values of any registers that are designated callee-saved that will be used by the function must be saved. To save registers, push them onto the stack. The callee-saved registers are RBX, RBP, and R12 through R15 (RSP will also be preserved by the call convention, but need not be pushed on the stack during this step). After these three actions are performed, the actual operation of the subroutine may proceed. When the subroutine is ready to return, the call convention rules continue.\nWhen the function is done, the return value for the function should be placed in RAX if it is not already there.\nThe function must restore the old values of any callee-saved registers (RBX, RBP, and R12 through R15) that were modified. The register contents are restored by popping them from the stack. Note, the registers should be popped in the inverse order that they were pushed.\nNext, we deallocate local variables. The easiest way to do this is to add to RSP the same amount that was subtracted from it in step 1.\nFinally, we return to the caller by executing a ret instruction. This instruction will find and remove the appropriate return address from the stack.\n\nIf you look at the assembly generated by some compilers, you will see a few extra commands in there in the callee’s prologue:\npush rbp ; at the start of the callee \nmov rbp, rsp\n... \npop rbp ; just before the ending `ret` \nThis code is unnecessary, and is a hold-over from the 32-bit calling convention. You can tell the compiler to not include this code by invoking it with the -fomit-frame-pointer flag.\nIt might be noted that the callee’s rules fall cleanly into two halves that are basically mirror images of one another. The first half of the rules apply to the beginning of the function, and are therefor commonly said to define the prologue to the function. The latter half of the rules apply to the end of the function, and are thus commonly said to define the epilogue of the function."
  },
  {
    "objectID": "posts/x86-64-assembly/index.html#the-32-bit-x86-c-calling-convention",
    "href": "posts/x86-64-assembly/index.html#the-32-bit-x86-c-calling-convention",
    "title": "x86-64汇编语言编程",
    "section": "The 32 bit x86 C calling Convention",
    "text": "The 32 bit x86 C calling Convention\nThe section is copied from x86 32 bit call convention.\nThe Caller’s Rules\n\nBfore calling a subroutine, the caller should save the contents of certain registers that are designated caller-saved. The caller-saved registers are EAX, ECX, EDX. If you want the contents of these registers to be preserved across the subroutine call, push them onto the stack\nTo pass parameters to the subroutine, push them onto the stack before the call. The parameters should be pushed in inverted order (i.e. last parameter first) – since the stack grows down, the first parameter will be stored at the lowest address (this inversion of parameters was historically used to allow functions to be passed a variable number of parameters).\nTo call the subroutine, use the call instruction. This instruction places the return address on top of the parameters on the stack, and branches to the subroutine code.\nAfter the subroutine returns, (i.e. immediately following the call instruction) the caller must remove the parameters from stack. This restores the stack to its state before the call was performed.\nThe caller can expect to find the return value of the subroutine in the register EAX.\nThe caller restores the contents of caller-saved registers (EAX, ECX, EDX) by popping them off of the stack. The caller can assume that no other registers were modified by the subroutine.\n\nThe Callee’s Rules\n\nAt the beginning of the subroutine, the function should push the value of EBP onto the stack, and then copy the value of ESP into EBP using the following instructions:\n\npush ebp \nmov ebp, esp ;Intel style instead of AT&T style \nThe reason for this initial action is the maintenance of the base pointer, EBP. The base pointer is used by convention as a point of reference for finding parameters and local variables on the stack. Essentially, when any subroutine is executing, the base pointer is a “snapshot” of the stack pointer value from when the subroutine started executing. Parameters and local variables will always be located at known, constant offsets away from the base pointer value. We push the old base pointer value at the beginning of the subroutine so that we can later restore the appropriate base pointer value for the caller when the subroutine returns. Remember, the caller isn’t expecting the subroutine to change the value of the base pointer. We then move the stack pointer into EBP to obtain our point of reference for accessing parameters and local variables.\n\nNext, allocate local variables by making space on the stack. Recall, the stack grows down, so to make space on the top of the stack, the stack pointer should be decremented. The amount by which the stack pointer is decremented depends on the number of local variables needed. For example, if 3 local integers (4 bytes each) were required, the stack pointer would need to be decremented by 12 to make space for these local variables. I.e.:\n\nsub esp, 12 \nAs with parameters, local variables will be located at known offsets from the base pointer.\n\nNext, the values of any registers that are designated callee-saved that will be used by the function must be saved. To save registers, push them onto the stack. The callee-saved registers are EBX, EDI and ESI (ESP and EBP will also be preserved by the call convention, but need not be pushed on the stack during this step). After these three actions are performed, the actual operation of the subroutine may proceed. When the subroutine is ready to return, the call convention rules continue:\nWhen the function is done, the return value for the function should be placed in EAX if it is not already there.\nThe function must restore the old values of any callee-saved registers (EBX, EDI and ESI) that were modified. The register contents are restored by popping them from the stack. Note, the registers should be popped in the inverse order that they were pushed.\nNext, we deallocate local variables. The obvious way to do this might be to add the appropriate value to the stack pointer (since the space was allocated by subtracting the needed amount from the stack pointer). In practice, a less error-prone way to deallocate the variables is to move the value in the base pointer into the stack pointer, i.e.:\n\nmov esp, ebp \nThis trick works because the base pointer always contains the value that the stack pointer contained immediately prior to the allocation of the local variables.\n\nImmediately before returning, we must restore the caller’s base pointer value by popping EBP off the stack. Remember, the first thing we did on entry to the subroutine was to push the base pointer to save its old value.\nFinally, we return to the caller by executing a ret instruction. This instruction will find and remove the appropriate return address from the stack."
  },
  {
    "objectID": "posts/x86-64-assembly/index.html#hello-world-program-x86-64",
    "href": "posts/x86-64-assembly/index.html#hello-world-program-x86-64",
    "title": "x86-64汇编语言编程",
    "section": "Hello world program x86-64",
    "text": "Hello world program x86-64\nThe program is copied from x86-64 Assembly on youtube, from Mike Shah\nIt refers to the linux syscall table\nIn intel format.\n/*first.s*/\n.intel_syntax noprefix\n.global _start \n.hello.str: \n    .ascii \"12345678\\n\" \nstr_len: equ $-.hello.str ;didn't test if it works in GNU AS \n\n.text \n\n_start: \n    push rbp\n    movq rbp, rsp \n    \n    movq rax, 1  \n    movq rdi, 1  \n    leaq rsi, .hello.str  \n    movq rdx, str_len ;didn't test if it works in GNU AS \n    syscall \n    \n    movq rax, 60  \n    movq rdi, 0  \n    syscall \n    \n    pop rbp \nTo build it.\nas -o first.o first.s \nld -o first first.o \nIn AT&T format.\n/*first.s*/\n\n.global _start \n.hello.str: \n    .ascii \"12345678\\n\" \n\n.text \n\n_start: \n    movq %rsp, %rbp \n    movq $1, %rax    \n    movq $1, %rdi   \n    leaq .hello.str, %rsi    \n    movq $9, %rdx  \n    syscall \n    \n    movq $60, %rax  \n    movq $0, %rdi   \n    syscall \n    \n    pop %rbp \nTo build it. The below 2 ways are both OK.\nas -o first.o first.s \nld -o first first.o \n\ngcc -c first.s -o first.o \nld -o first first.o"
  },
  {
    "objectID": "posts/x86-64-assembly/index.html#hello-world-program-x86-32-bit",
    "href": "posts/x86-64-assembly/index.html#hello-world-program-x86-32-bit",
    "title": "x86-64汇编语言编程",
    "section": "Hello world program X86 32 bit",
    "text": "Hello world program X86 32 bit\nThe 32 bit hello world program and the 64 bit counterpart both use syscall to write to the screen and exit the program. But the 32 bit and 64 bit have different call conventions, and the syscall table are different in 32 bit and 64 bit too.\nRefer to 32 bit syscall table.\nIn 32 bit, the EXIT syscall is 1, while in 64 bit it is 60.\nIn 32 bit, the WRITE syscall is 4, while in 64 bit it is 1.\nIn 32 bit, the EAX, EBX, ECX, EDX, ESI, EDI in sequence are used to specify the SYSCALL code and arguments.\nIn 64 bit, the RAX, RDI, RSI, RDX, RCX, R8, R9 in sequence are used to specify the SYSCALL code and arguments.\nIn 32 bit, the syscall instruction is not available. It will report illegal instruction if we use it.\nRefer to stackoverflow on syscall and sysenter.\n\nsyscall is the default way of entering kernel mode on x86-64. This instruction is not available in 32 bit modes of operation on Intel processors.\nsysenter is an instruction most frequently used to invoke system calls in 32 bit modes of operation. It is similar to syscall, a bit more difficult to use though, but that is the kernel’s concern. int 0x80 is a legacy way to invoke a system call and should be avoided.\nThe preferred way to invoke a system call is to use vDSO(virtual dynamic shared object), a part of memory mapped in each process address space that allows to use system calls more efficiently (for example, by not entering kernel mode in some cases at all). vDSO also takes care of more difficult, in comparison to the legacy int 0x80 way, handling of syscall or sysenter instructions.\n\nNote: In 32 bit, it uses STACK to specify arguments when calling a function. In 64 bit, it uses the 6 registers to specify the first 6 arguments, and the stack to specify the remaining arguments.\nNote: int $0x80 and sysenter does not mean the same thing in 32 bit. Refer to the definitive guide to linux system calls.\nThe below program is proved OK in my 32 bit Ubuntu.\n.data\nhello: .ascii \"hello world\\n\"\n.bss\n.text\n\n.global _start\n    // output hello world to screen\n_start:\n    push %ebp  ;//preserve ebp\n    movl %esp, %ebp ;//put the current esp to ebp\n    movl $1, %ebx ;//put STDOUT file descriptor to %ebx\n    leal hello, %ecx  ;//put address of the str to %ecx\n    movl $12, %edx ;//put the length of the str to %edx\n    movl $4, %eax  ;//put the WRITE syscall number to eax\n    int $0x80\n\n    // exit the program\n    movl $0, %ebx ;//put the exit code to ebx\n    movl $1, %eax ;//put the EXIT syscall number to eax\n    int $0x80\n    pop %ebp"
  },
  {
    "objectID": "posts/x86-64-assembly/index.html#chap6-linux-and-the-tools-that-shape-the-way-you-work",
    "href": "posts/x86-64-assembly/index.html#chap6-linux-and-the-tools-that-shape-the-way-you-work",
    "title": "x86-64汇编语言编程",
    "section": "Chap6 Linux and the Tools That Shape the Way You Work",
    "text": "Chap6 Linux and the Tools That Shape the Way You Work\nSASM: Simple ASM\nMake"
  },
  {
    "objectID": "posts/x86-64-assembly/index.html#chap7-following-your-instructions-meeting-machine-instructions-up-close-and-personal",
    "href": "posts/x86-64-assembly/index.html#chap7-following-your-instructions-meeting-machine-instructions-up-close-and-personal",
    "title": "x86-64汇编语言编程",
    "section": "Chap7 Following your instructions: Meeting Machine Instructions Up Close and Personal",
    "text": "Chap7 Following your instructions: Meeting Machine Instructions Up Close and Personal\npage 175"
  }
]