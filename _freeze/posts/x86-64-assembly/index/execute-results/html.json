{
  "hash": "d7a8c94ca8952cdd861e0988642979b1",
  "result": {
    "markdown": "---\ntitle: x86-64汇编语言编程\nauthor: 秦米书\ndate: '2023-10-21'\ncategories:\n  - x86-64\n  - assembly\n  - linux\nimage: image.jpg\nformat:\n  html:\n    toc: true\n    toc-depth: 7\ncode-line-numbers: true\n---\n\nThis is a note while studying x86-64 assembler.\n\n# References \n\n[linux syscall table](https://filippo.io/linux-syscall-table/) \n\n[ascii table](https://www.asciitable.com/)\n\n[gnu assembler, or gas, or as](https://ftp.gnu.org/old-gnu/Manuals/gas-2.9.1/html_chapter/as_7.html)\n\n# Notes\n\nGCC(Gnu Compiler Collection) is a front end. It will call `as` and `ld`. The process can be viewed if we use `-v` argument of gcc. \n\nUsing `-g` argument will embed debug info in the object file. E.g. `gcc -c first.s -o first.o -g`. After that, we are able to use `list` in GDB to view the source code. \n\nBelow table lists the size of x86-64 memory/registers. Some is different from ARM. For example, in ARM, A `.word` means 32 bits. \n\n| term | size (bits) |\n|------|------|\n| byte     |  8    |\n| word     |  16    |\n| dword     | 32     |\n| qword     | 64     |\n\nIn x86-64, use `.long` or `.int` to specify 64 bits integer. In ARM, use `.word` to specify 32 bits integer. Note, `.word` or `.short` may have different lengths in different machine. They are machine dependent. \n\nSTDIN file descriptor is 0. STDOUT file descriptor is 1.  STDERR file descriptor is 2. \n\nThe labels in the assembly program begins with `_`, e.g. `_start`, is due to the convention of C compiler. It is the simple name mangaling. `C++` has more complex name mangling.  \n\n## Hello world program \n\nThe program is copied from [x86-64 Assembly on youtube, from Mike Shah](https://www.youtube.com/watch?v=3nYHV5zIQGA&list=PLvv0ScY6vfd9BSBznpARlKGziF1xrlU54&index=1)\n\nIt refers to the [linux syscall table](https://filippo.io/linux-syscall-table/)\n\nIn intel format. \n```ASM\n/*first.s*/\n.intel_syntax noprefix\n.global _start \n.hello.str: \n\t.ascii \"12345678\\n\" \n\n.text \n\n_start: \n\tmovq rbp, rsp \n\tmovq rax, 1  \n\tmovq rdi, 1  \n\tleaq rsi, .hello.str  \n\tmovq rdx, 9  \n\tsyscall \n\t\n\tmovq rax, 60  \n\tmovq rdi, 0  \n\tsyscall \n\t\n\tpop rbp \n```\n\nTo build it. \n\n```bash \nas -o first.o first.s \nld -o first first.o \n```\n\nIn AT&T format. \n```ASM \n/*first.s*/\n\n.global _start \n.hello.str: \n\t.ascii \"12345678\\n\" \n\n.text \n\n_start: \n\tmovq %rsp, %rbp \n\tmovq $1, %rax    \n\tmovq $1, %rdi   \n\tleaq .hello.str, %rsi    \n\tmovq $9, %rdx  \n\tsyscall \n\t\n\tmovq $60, %rax  \n\tmovq $0, %rdi   \n\tsyscall \n\t\n\tpop %rbp \n```\n\nTo build it. The below 2 ways are both OK. \n```bash\nas -o first.o first.s \nld -o first first.o \n\ngcc -c first.s -o first.o \nld -o first first.o \n```\n\n## call \n\n```ASM\n/*first.s*/\n# there is also .bss segment for not initialized global data \n.data \n.hello.str: \n\t.ascii \"12345678\\n\" \n\n.text \n\n_write_str: \n\tmovq %rsp, %rbp \n\tmovq $1, %rax    \n\tmovq $1, %rdi   \n\tleaq .hello.str, %rsi    \n\tmovq $9, %rdx  \n\tsyscall \n\tret \n_exit:\n\tmovq $60, %rax  \n\tmovq $0, %rdi   \n\tsyscall \n\tret \n\n.global _start \n_start: \n\tcall _write_str \n\tcall _exit \n\tpop %rbp \n```\n\n# Book X64 Assembly Language Step by Step \nNotes while I read the book. \n\n## Chap1 It's all in the Plan: Understanding What Computers Really Do \n\nA computer program is a list of steps and tests, nothing more. \n\nA test is the sort of either/or decision we make. \n- First, you take a look at sth that can go one of two way. \n- Then you do one of two things, depending on what you saw when you took a look. \n\n## Chap2 Allien Bases: Getting Your Arms Around Binary and Hexadecimal \n\noctal \n\nhexadecimal \n\nbinary \n\n## Chap3 Lifting the Hood: Discovering What Computers Actually Are \n\nA bit is a single binary digit, either 1 or 0. \n\nA byte is eight bits. \n\nTwo bytes side by side are called a word. \n\nTwo words side by side are called a double word. \n\nA quad word consists of two double words. \n\nA group of four bits is called a nybble. \n\n## Chap4 Location: Registers, Memory Addressing, and Knowing Where Things Are \n\nThe skill of assembly language consists of a deep comprehension of memory addressing. Everything else is details -- and easy details, at that. \n\nThere are a fair number of different ways to address memory in the Intel/AMD CPU family. Each of these ways is called a Memory Model. There are 3 major memory models that you can use with the more recent members of the Intel family, and a number of minor variations on those three, especially the one in the middle. \n\nReal mode flat model. \n\nReal mode segmented model. \n\nProtected-mode flat model(32-bit and 64-bit). \n\nThe 8080 was an 8-bit CPU(its general-purpose registers have 8-bits), meaning that it processed 8 bits of information at a time. However, it had 16 address lines coming out of it(it will address 64KB). \n\nThe 8080 memory-addressing scheme was very simple. You put a 16-bit address out on the address lines, and you got back the 8-bit value that was stored at that address. \n\nThe 8086 comes after 8080. It is 16-bit CPU. It has 20 address lines.\n\nThe 8080 is used a lot. Intel wanted to make it easy for people to translate older software from the 8080 to 8086. One way to do this was to make sure that a 16-bit addressing system such as that of the 8080 still worked.  Even though the 8086 could address 16 times as much memory as the 8080(16x64KB=1MB), Intel setup the 8086 so that a program could take some 64 KB segment within that megabyte of memory and run entirely inside it, just as though it were the smaller 8080 memory system. This was done by the use of segment registers. \n\nSpeaking of the 8086 and 8088, there are 4 segment registers(CS, DS, ...). \n\nThis was very wise short-term thinking and catastrophically bad long-term thinking. Programs that needed more than 64KB of memory at a time had to use memory in 64KB chunks, switching between chunks by switching values into and out of segment registers. \n\nTo maintain backward compatibility with the ancient 8086 and 8088, newer CPUs were given the power to limit themselves to what the older chips could address and execute. When a Pentium-class or better CPU needs to run software written for the real-mode segmented model, it pulls a neat trick that, temporarily, make it become an 8086. This was called virtual-86 mode, and it provided excellent backward compatibility for DOS software. \n\nA segment may start every 16 bytes throughout the full megabyte of real memory. \n\nCS, DS, SS, ES, FS, GS: Segment registers. All segment registers are 16 bits in size, irrespective of the CPU. FS and GS exist only in the 386 and later Intel x86 32-bit CPUs. \n\nCS: Code Segment \n\nDS: Data Segment \n\nSS: Stack Segment \n\nES: Extra segment \n\nFS, GS: Clones of ES \n\nSegment registers become useless in application programming in X86-64. Operating systems use two of them for special purposes. \n\nDo Intel's x86-64 CPUs have 64 address lines? No (48 or 52). \n\nIn the x86-64 world, CPUs have 14 general purpose 64-bit registers, plus SP and BP. \n\nThere are eight 16-bit general-purpose registers: AX, BX, CX, DX, BP, SI, DI, SP (8086, 8088, 80186 and 80286). \n\nEAX, EBX, ECX, EDX, EBP, ESI, EDI, ESP. (32 bitS)\n\nRAX, RBX, RCX, RDX, RBP, RSI, RDI, RSP. R8 to R15. (64 BITS)\n\nRAX(EAX(AX(AH,AL)))\n\nRBX(EBX(BX(BH,BL)))\n\nRCX(ECX(CX(CH,CL)))\n\nRDX(EDX(DX(DH,DL)))\n\nRSI(ESI(SI(SIL))) and so on for RDI, RSP. \n\nRIP, EIP, IP \n\nThe new x64 registers R8-R15 can be addressed as 64 bits, 32 bits, 16 bits, and 8 bits. However, the AH/AL scheme for the low 16 bits is a trick reserved for only RAX-RDX. The naming scheme for the R registers provides a mnemonic: D for double word, W for word, and B for byte. For example, if you want to deal with the lowest 8 bits of R8, you use the name R8B. Don’t make the beginner’s mistake of assuming that R8, R8D, R8W, and R8B are four separate and independent registers! A better metaphor is to think of the register names as country/state/county/city. \n\nIP register. \n\nWhile executing a program, the CPU uses IP to keep track of where it is in the current code segment. Instructions come in different sizes, ranging typically from 1 to 15 bytes. The CPU knows the size of each instruction it executes.\n\nIP is notable in being the only register that can neither be read nor written to directly.\n\nFlags register. \n\nRFLAGS, EFLAGS, FLAGS. When the flag’s value is 1, we say that the flag is set. When the flag’s value is 0, we say that the flag is cleared.\n\nMath Coprocessors and Their Registers (may be 128 bits or 256 bits)\n\nReal-Mode Flat Model \n\nReal-Mode Segmented Model \n\n32-bit Protected Mode Flat Model \n\n64-bit Long Mode \n\n## Chap5 The Right to Assemble: The Process of Creating Assembly Language Programs \npage 103 \n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}