{
  "hash": "e5872ed94b868f89179477328d1abf6a",
  "result": {
    "markdown": "---\ntitle: x86-64汇编语言编程\nauthor: 秦米书\ndate: '2023-10-21'\ncategories:\n  - x86-64\n  - assembly\n  - linux\nimage: image.jpg\nformat:\n  html:\n    toc: true\n    toc-depth: 7\ncode-line-numbers: true\n---\n\nThis is a note while studying x86-64 assembler.\n\n# References \n\n[linux syscall table](https://filippo.io/linux-syscall-table/) \n\n[ascii table](https://www.asciitable.com/)\n\n[gnu assembler, or gas, or as](https://ftp.gnu.org/old-gnu/Manuals/gas-2.9.1/html_chapter/as_7.html)\n\n# General Notes\n\n## misc \n\nGCC(Gnu Compiler Collection) is a front end. It will call `as` and `ld`. The process can be viewed if we use `-v` argument of gcc. \n\nUsing `-g` argument will embed debug info in the object file. E.g. `gcc -c first.s -o first.o -g`. After that, we are able to use `list` in GDB to view the source code. \n\nBelow table lists the size of x86-64 memory/registers. Some is different from ARM. For example, in ARM, A `.word` means 32 bits. \n\n| term | size (bits) |\n|------|------|\n| byte     |  8    |\n| word     |  16    |\n| dword     | 32     |\n| qword     | 64     |\n\nIn x86-64, use `.long` or `.int` to specify 64 bits integer. In ARM, use `.word` to specify 32 bits integer. Note, `.word` or `.short` may have different lengths in different machine. They are machine dependent. \n\nSTDIN file descriptor is 0. STDOUT file descriptor is 1.  STDERR file descriptor is 2. \n\nThe labels in the assembly program begins with `_`, e.g. `_start`, is due to the convention of C compiler. It is the simple name mangaling. `C++` has more complex name mangling.  \n\n## Hello world program x86-64, position indepent code\n\n```ASM \n//first.s \n//pay attention to the `lea msg(%rip)` instruction \n.data\nmsg:\n    .asciz \"Hello, world!\\n\"\n \n.extern printf\n.extern flush\n.text\n    .global main # entry point\nmain:\n    movq %rsp, %rbp ;#for correct debugging\n    andq $-16, %rsp\n    lea msg(%rip), %rdi ;position independent code \n    call printf\n    movq %rbp, %rsp\n    xorq %rax, %rax\n    ret\n``` \n\nto build it. \n\n```bash \ngcc -c -g -o first.o first.s \ngcc -o first first.o \n```\n\nRefer to https://reverseengineering.stackexchange.com/questions/18007/disassembly-shows-lea-with-rip \n\nUnlike 32bits modes instructions that were taken as absolute addresses (use 32-bit immediate offset addressing), the 64bits modes (a.k.a long-mode) are usually using 32-bit offset from the current RIP, not from 0x00000000 like before. That means that you don't have to know the absolute address of something you want to reference, you only need to know how far away it is from the currently executing instruction.\n\nThere are very few addressing modes which use a full 64bit absolute address. Most addressing modes are 32bit offsets relative to one of the 64bit registers (usually RIP).\n\n## Hello world program x86-64 \n\nThe program is copied from [x86-64 Assembly on youtube, from Mike Shah](https://www.youtube.com/watch?v=3nYHV5zIQGA&list=PLvv0ScY6vfd9BSBznpARlKGziF1xrlU54&index=1)\n\nIt refers to the [linux syscall table](https://filippo.io/linux-syscall-table/)\n\n[another linux syscall table](https://hackeradam.com/x86-64-linux-syscalls/)\n\nIn intel format. \n```ASM\n/*first.s*/\n.intel_syntax noprefix\n.global _start \n.hello.str: \n\t.ascii \"12345678\\n\" \nstr_len: equ $-.hello.str ;didn't test if it works in GNU AS \n\n.text \n\n_start: \n\tpush rbp\n\tmovq rbp, rsp \n\t\n\tmovq rax, 1  \n\tmovq rdi, 1  \n\tleaq rsi, .hello.str  \n\tmovq rdx, str_len ;didn't test if it works in GNU AS \n\tsyscall \n\t\n\tmovq rax, 60  \n\tmovq rdi, 0  \n\tsyscall \n\t\n\tpop rbp \n```\n\nTo build it. \n\n```bash \nas -o first.o first.s \nld -o first first.o \n```\n\nIn AT&T format. \n```ASM \n/*first.s*/\n\n.global _start \n.hello.str: \n\t.ascii \"12345678\\n\" \n\n.text \n\n_start: \n\tpush %rbp \n\tmovq %rsp, %rbp \n\tmovq $1, %rax    \n\tmovq $1, %rdi   \n\tleaq .hello.str, %rsi    \n\tmovq $9, %rdx  \n\tsyscall \n\t\n\tmovq $60, %rax  \n\tmovq $0, %rdi   \n\tsyscall \n\t\n\tpop %rbp \n```\n\nTo build it. The below 2 ways are both OK. \n```bash\nas -o first.o first.s \nld -o first first.o \n\ngcc -c first.s -o first.o \nld -o first first.o \n```\n\n## Hello world program X86 32 bit \n\nThe 32 bit hello world program and the 64 bit counterpart both use syscall to write to the screen and exit the program. But the 32 bit and 64 bit have different call conventions, and the syscall table are different in 32 bit and 64 bit too. \n\nRefer to [32 bit syscall table](https://syscalls32.paolostivanin.com/). \n\nRefer to [64 bit syscall table](https://hackeradam.com/x86-64-linux-syscalls/)\n\nIn 32 bit, the EXIT syscall is 1, while in 64 bit it is 60. \n\nIn 32 bit, the WRITE syscall is 4, while in 64 bit it is 1. \n\nIn 32 bit, the EAX, EBX, ECX, EDX, ESI, EDI in sequence are used to specify the SYSCALL code and arguments. \n\nIn 64 bit, the RAX, RDI, RSI, RDX, R10, R8, R9 in sequence are used to specify the SYSCALL code and arguments. [call convention](https://stackoverflow.com/questions/2535989/what-are-the-calling-conventions-for-unix-linux-system-calls-and-user-space-f)\n\nIn 32 bit, the `syscall` instruction is not available. It will report illegal instruction if we use it. \n\nRefer to [stackoverflow on syscall and sysenter](https://stackoverflow.com/questions/12806584/what-is-better-int-0x80-or-syscall-in-32-bit-code-on-linux). \n\n- syscall is the default way of entering kernel mode on x86-64. This instruction is not available in 32 bit modes of operation on Intel processors.\n- sysenter is an instruction most frequently used to invoke system calls in 32 bit modes of operation. It is similar to syscall, a bit more difficult to use though, but that is the kernel's concern.\nint 0x80 is a legacy way to invoke a system call and should be avoided.\n- The preferred way to invoke a system call is to use vDSO(virtual dynamic shared object), a part of memory mapped in each process address space that allows to use system calls more efficiently (for example, by not entering kernel mode in some cases at all). vDSO also takes care of more difficult, in comparison to the legacy int 0x80 way, handling of syscall or sysenter instructions.\n\nNote: In 32 bit, it uses STACK to specify arguments when calling a function. In 64 bit, it uses the 6 registers to specify the first 6 arguments, and the stack to specify the remaining arguments. \n\nNote: `int $0x80` and `sysenter` does not mean the same thing in 32 bit. Refer to [the definitive guide to linux system calls](https://blog.packagecloud.io/the-definitive-guide-to-linux-system-calls/). \n\nThe below program is proved OK in my 32 bit Ubuntu. \n\n```ASM\n.data\nhello: .ascii \"hello world\\n\"\n.bss\n.text\n\n.global _start\n    // output hello world to screen\n_start:\n    push %ebp  ;//preserve ebp\n    movl %esp, %ebp ;//put the current esp to ebp\n    movl $1, %ebx ;//put STDOUT file descriptor to %ebx\n    leal hello, %ecx  ;//put address of the str to %ecx\n    movl $12, %edx ;//put the length of the str to %edx\n    movl $4, %eax  ;//put the WRITE syscall number to eax\n    int $0x80\n\n    // exit the program\n    movl $0, %ebx ;//put the exit code to ebx\n    movl $1, %eax ;//put the EXIT syscall number to eax\n    int $0x80\n    pop %ebp\n``` \n\n## call instruction to call a function \n\n```ASM\n/*first.s*/\n# there is also .bss segment for not initialized global data \n.data \n.hello.str: \n\t.ascii \"12345678\\n\" \n\n.text \n\n_write_str: \n\tmovq %rsp, %rbp \n\tmovq $1, %rax    \n\tmovq $1, %rdi   \n\tleaq .hello.str, %rsi    \n\tmovq $9, %rdx  \n\tsyscall \n\tret \n_exit:\n\tmovq $60, %rax  \n\tmovq $0, %rdi   \n\tsyscall \n\tret \n\n.global _start \n_start: \n\tcall _write_str \n\tcall _exit \n\tpop %rbp \n```\n\n## The 64 bit x86 C Calling Convention \nThe section is copied from [x86-64 call convention](https://aaronbloomfield.github.io/pdr/book/x86-64bit-ccc-chapter.pdf). It is for Linux. Microsoft windows does not follow the same convention. Refer to [x64 calling convention, Microsoft](https://learn.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-170).  \n\npop, push, call, ret instructions. \n\nThe caller's rules: \n\n1. Before calling a subroutine, the caller should save the contents of certain registers that are designated\ncaller-saved. The caller-saved registers are r10, r11, and any registers that parameters are put into. If\nyou want the contents of these registers to be preserved across the subroutine call, push them onto\nthe stack.\n\n2. To pass parameters to the subroutine, we put up to six of them into registers (in order: rdi, rsi,\nrdx, rcx, r8, r9). If there are more than six parameters to the subroutine, then push the rest onto\nthe stack in reverse order (i.e. last parameter first) – since the stack grows down, the first of the\nextra parameters (really the seventh parameter) parameter will be stored at the lowest address (this\ninversion of parameters was historically used to allow functions to be passed a variable number of\nparameters).\n\n3. To call the subroutine, use the `call` instruction. This instruction places the return address on top of\nthe parameters on the stack, and branches to the subroutine code.\n\n4. After the subroutine returns, (i.e. immediately following the call instruction) the caller must remove\nany additional parameters (beyond the six stored in registers) from stack. This restores the stack to\nits state before the call was performed.\n\n5. The caller can expect to find the return value of the subroutine in the register RAX.\n\n6. The caller restores the contents of caller-saved registers (r10, r11, and any in the parameter passing\nregisters) by popping them off of the stack. The caller can assume that no other registers were\nmodified by the subroutine.\n\nThe Callee's Rules: \n\n1. Allocate local variables by using registers or making space on the stack. Recall, the stack grows\ndown, so to make space on the top of the stack, the stack pointer should be decremented. The\namount by which the stack pointer is decremented depends on the number of local variables needed.\nFor example, if a local float and a local long (12 bytes total) were required, the stack pointer\nwould need to be decremented by 12 to make space for these local variables: `sub rsp, 12`.  As with parameters, local variables will be located at known offsets from the stack pointer.\n\n2. Next, the values of any registers that are designated callee-saved that will be used by the function\nmust be saved. To save registers, push them onto the stack. The callee-saved registers are RBX, RBP,\nand R12 through R15 (RSP will also be preserved by the call convention, but need not be pushed on\nthe stack during this step). After these three actions are performed, the actual operation of the subroutine may proceed. When\nthe subroutine is ready to return, the call convention rules continue. \n\n3. When the function is done, the return value for the function should be placed in RAX if it is not\nalready there. \n\n4. The function must restore the old values of any callee-saved registers (RBX, RBP, and R12 through\nR15) that were modified. The register contents are restored by popping them from the stack. Note,\nthe registers should be popped in the inverse order that they were pushed.\n\n5. Next, we deallocate local variables. The easiest way to do this is to add to RSP the same amount\nthat was subtracted from it in step 1. \n\n6. Finally, we return to the caller by executing a ret instruction. This instruction will find and remove\nthe appropriate return address from the stack.\n\nIf you look at the assembly generated by some compilers, you will see a few extra commands in there\nin the callee’s prologue:\n\n```ASM\npush rbp ; at the start of the callee \nmov rbp, rsp\n... \npop rbp ; just before the ending `ret` \n```\n\nThis code is unnecessary, and is a hold-over from the 32-bit calling convention. You can tell the compiler to not include this code by invoking it with the `-fomit-frame-pointer` flag.\n\nIt might be noted that the callee’s rules fall cleanly into two halves that are basically mirror images of\none another. The first half of the rules apply to the beginning of the function, and are therefor commonly\nsaid to define the prologue to the function. The latter half of the rules apply to the end of the function, and\nare thus commonly said to define the epilogue of the function.\n\n## The 32 bit x86 C calling Convention \nThe section is copied from [x86 32 bit call convention](https://aaronbloomfield.github.io/pdr/book/x86-32bit-ccc-chapter.pdf). \n\nThe Caller's Rules \n\n1. Bfore calling a subroutine, the caller should save the contents of certain registers that are designated caller-saved. The caller-saved registers are EAX, ECX, EDX. If you want the contents of these\nregisters to be preserved across the subroutine call, push them onto the stack\n\n2.  To pass parameters to the subroutine, push them onto the stack before the call. The parameters\nshould be pushed in inverted order (i.e. last parameter first) – since the stack grows down, the first\nparameter will be stored at the lowest address (this inversion of parameters was historically used to\nallow functions to be passed a variable number of parameters). \n\n3. To call the subroutine, use the call instruction. This instruction places the return address on top of\nthe parameters on the stack, and branches to the subroutine code.\n\n4. After the subroutine returns, (i.e. immediately following the call instruction) the caller must remove\nthe parameters from stack. This restores the stack to its state before the call was performed.\n\n5. The caller can expect to find the return value of the subroutine in the register EAX.\n\n6.  The caller restores the contents of caller-saved registers (EAX, ECX, EDX) by popping them off of\nthe stack. The caller can assume that no other registers were modified by the subroutine. \n\nThe Callee's Rules \n\n1. At the beginning of the subroutine, the function should push the value of EBP onto the stack, and\nthen copy the value of ESP into EBP using the following instructions:\n\n```ASM\npush ebp \nmov ebp, esp ;Intel style instead of AT&T style \n```\n\nThe reason for this initial action is the maintenance of the base pointer, EBP. The base pointer is\nused by convention as a point of reference for finding parameters and local variables on the stack.\nEssentially, when any subroutine is executing, the base pointer is a “snapshot” of the stack pointer\nvalue from when the subroutine started executing. Parameters and local variables will always be\nlocated at known, constant offsets away from the base pointer value. We push the old base pointer\nvalue at the beginning of the subroutine so that we can later restore the appropriate base pointer\nvalue for the caller when the subroutine returns. Remember, the caller isn’t expecting the subroutine\nto change the value of the base pointer. We then move the stack pointer into EBP to obtain our point\nof reference for accessing parameters and local variables. \n\n2.  Next, allocate local variables by making space on the stack. Recall, the stack grows down, so to\nmake space on the top of the stack, the stack pointer should be decremented. The amount by which\nthe stack pointer is decremented depends on the number of local variables needed. For example, if\n3 local integers (4 bytes each) were required, the stack pointer would need to be decremented by 12\nto make space for these local variables. I.e.: \n\n```ASM\nsub esp, 12 \n``` \n\nAs with parameters, local variables will be located at known offsets from the base pointer.\n\n3. Next, the values of any registers that are designated callee-saved that will be used by the function\nmust be saved. To save registers, push them onto the stack. The callee-saved registers are EBX, EDI\nand ESI (ESP and EBP will also be preserved by the call convention, but need not be pushed on the\nstack during this step).\nAfter these three actions are performed, the actual operation of the subroutine may proceed. When\nthe subroutine is ready to return, the call convention rules continue:\n\n4. When the function is done, the return value for the function should be placed in EAX if it is not\nalready there.\n\n5. The function must restore the old values of any callee-saved registers (EBX, EDI and ESI) that were\nmodified. The register contents are restored by popping them from the stack. Note, the registers\nshould be popped in the inverse order that they were pushed. \n\n6. Next, we deallocate local variables. The obvious way to do this might be to add the appropriate\nvalue to the stack pointer (since the space was allocated by subtracting the needed amount from the\nstack pointer). In practice, a less error-prone way to deallocate the variables is to move the value in\nthe base pointer into the stack pointer, i.e.:\n\n```ASM\nmov esp, ebp \n```\n\nThis trick works because the base pointer always contains the value that the stack pointer contained\nimmediately prior to the allocation of the local variables.\n\n7. Immediately before returning, we must restore the caller’s base pointer value by popping EBP off\nthe stack. Remember, the first thing we did on entry to the subroutine was to push the base pointer\nto save its old value.\n\n8. Finally, we return to the caller by executing a ret instruction. This instruction will find and remove\nthe appropriate return address from the stack.\n\n## General purpose registers in X86-64 \n\n```default \nrax eax ax al\nrbx ebx bx bl\nrcx ecx cx cl\nrdx edx dx dl\nrsi esi si sil\nrdi edi di dil\nrbp ebp bp bpl\nrsp esp sp spl\nr8 r8d r8w r8b\nr9 r9d r9w r9b\nr10 r10d r10w r10b\nr11 r11d r11w r11b\nr12 r12d r12w r12b\nr13 r13d r13w r13b\nr14 r14d r14w r14b\nr15 r15d r15w r15b\n``` \n\n## AT&T Syntax \n\nRefer to [AT&T assembly syntax](https://stackoverflow.com/questions/9223756/what-does-an-asterisk-before-an-address-mean-in-x86-64-att-assembly)\n\nIt's AT&T assembly syntax:\n\n- source comes before destination\n- mnemonic suffixes indicate the size of the operands (q for quad, etc.)\n- registers are prefixed with % and immediate values with $\n- effective addresses are in the form DISP(BASE, INDEX SCALE) (DISP + BASE + INDEX * SCALE)\n- Indirect jump/call operands indicated with * (as opposed to direct).\n\n##  A comparison of GAS and NASM\n\nRefer to [Linux assemblers: A comparison of GAS and NASM](http://web.archive.org/web/20090215122116/http://www.ibm.com/developerworks/library/l-gas-nasm.html)\n\n# Book Programming from the Ground Up by Jonathan Bartlett (Author)\nProgramming from the Ground Up uses Linux assembly language to teach new programmers the most important concepts in programming. \n\n# Book Professional Assembly Language by Richard Blum (Good)\n \nIt is said that it uses the AT&T syntax. And uses the GNU AS assembler. But seems it is for 32 bit X86. After knowing the differences of call conventions between x86-64 and x86-32, it does not matter. Refer to [install a 32-bit ubuntu in a 64-bit host via virtual box](https://askubuntu.com/questions/344976/can-i-install-32-bit-ubuntu-in-a-64-bit-host-using-virtualbox)\n\nUse vagrant to install a 32 bit of ubuntu in virtul box. \n\n```default \n//put the Vagrantfile in a folder and 'run vagrant up'. \n//run 'vagrant ssh' to login to the VM. It is a terminal interface without GUI. \n//default user and passwd is vagrant/vagrant. \n//A folder /vagrant is mounted to refer to the folder in the host machine where the Vagrantfile locates. \n// run `sudo apt install gdb` to install gdb for debugging   \nVagrant.configure(\"2\") do |config|\n  config.vm.box = \"reelio/trusty32\"\n  config.vm.box_version = \"0.0.1\"\nend\n```\n\nRead to the chapter Moving Data \n\n# Book Beginning x64 Assembly Programming by Jo Van Hoey\nIt includes introductions on asm on both Linux and Windows. It also include some advanced instructions for example AVX, SSE, etc. \n\n# Book X64 Assembly Language Step by Step \nNotes while I read the book. \n\n## Chap1 It's all in the Plan: Understanding What Computers Really Do \n\nA computer program is a list of steps and tests, nothing more. \n\nA test is the sort of either/or decision we make. \n- First, you take a look at sth that can go one of two way. \n- Then you do one of two things, depending on what you saw when you took a look. \n\n## Chap2 Allien Bases: Getting Your Arms Around Binary and Hexadecimal \n\noctal \n\nhexadecimal \n\nbinary \n\n## Chap3 Lifting the Hood: Discovering What Computers Actually Are \n\nA bit is a single binary digit, either 1 or 0. \n\nA byte is eight bits. \n\nTwo bytes side by side are called a word. \n\nTwo words side by side are called a double word. \n\nA quad word consists of two double words. \n\nA group of four bits is called a nybble. \n\n## Chap4 Location: Registers, Memory Addressing, and Knowing Where Things Are \n\nThe skill of assembly language consists of a deep comprehension of memory addressing. Everything else is details -- and easy details, at that. \n\nThere are a fair number of different ways to address memory in the Intel/AMD CPU family. Each of these ways is called a Memory Model. There are 3 major memory models that you can use with the more recent members of the Intel family, and a number of minor variations on those three, especially the one in the middle. \n\nReal mode flat model. \n\nReal mode segmented model. \n\nProtected-mode flat model(32-bit and 64-bit). \n\nThe 8080 was an 8-bit CPU(its general-purpose registers have 8-bits), meaning that it processed 8 bits of information at a time. However, it had 16 address lines coming out of it(it will address 64KB). \n\nThe 8080 memory-addressing scheme was very simple. You put a 16-bit address out on the address lines, and you got back the 8-bit value that was stored at that address. \n\nThe 8086 comes after 8080. It is 16-bit CPU. It has 20 address lines.\n\nThe 8080 is used a lot. Intel wanted to make it easy for people to translate older software from the 8080 to 8086. One way to do this was to make sure that a 16-bit addressing system such as that of the 8080 still worked.  Even though the 8086 could address 16 times as much memory as the 8080(16x64KB=1MB), Intel setup the 8086 so that a program could take some 64 KB segment within that megabyte of memory and run entirely inside it, just as though it were the smaller 8080 memory system. This was done by the use of segment registers. \n\nSpeaking of the 8086 and 8088, there are 4 segment registers(CS, DS, ...). \n\nThis was very wise short-term thinking and catastrophically bad long-term thinking. Programs that needed more than 64KB of memory at a time had to use memory in 64KB chunks, switching between chunks by switching values into and out of segment registers. \n\nTo maintain backward compatibility with the ancient 8086 and 8088, newer CPUs were given the power to limit themselves to what the older chips could address and execute. When a Pentium-class or better CPU needs to run software written for the real-mode segmented model, it pulls a neat trick that, temporarily, make it become an 8086. This was called virtual-86 mode, and it provided excellent backward compatibility for DOS software. \n\nA segment may start every 16 bytes throughout the full megabyte of real memory. \n\nCS, DS, SS, ES, FS, GS: Segment registers. All segment registers are 16 bits in size, irrespective of the CPU. FS and GS exist only in the 386 and later Intel x86 32-bit CPUs. \n\nCS: Code Segment \n\nDS: Data Segment \n\nSS: Stack Segment \n\nES: Extra segment \n\nFS, GS: Clones of ES \n\nSegment registers become useless in application programming in X86-64. Operating systems use two of them for special purposes. \n\nDo Intel's x86-64 CPUs have 64 address lines? No (48 or 52). \n\nIn the x86-64 world, CPUs have 14 general purpose 64-bit registers, plus SP and BP. \n\nThere are eight 16-bit general-purpose registers: AX, BX, CX, DX, BP, SI, DI, SP (8086, 8088, 80186 and 80286). \n\nEAX, EBX, ECX, EDX, EBP, ESI, EDI, ESP. (32 bitS)\n\nRAX, RBX, RCX, RDX, RBP, RSI, RDI, RSP. R8 to R15. (64 BITS)\n\nRAX(EAX(AX(AH,AL)))\n\nRBX(EBX(BX(BH,BL)))\n\nRCX(ECX(CX(CH,CL)))\n\nRDX(EDX(DX(DH,DL)))\n\nRSI(ESI(SI(SIL))) and so on for RDI, RSP. \n\nRIP, EIP, IP \n\nThe new x64 registers R8-R15 can be addressed as 64 bits, 32 bits, 16 bits, and 8 bits. However, the AH/AL scheme for the low 16 bits is a trick reserved for only RAX-RDX. The naming scheme for the R registers provides a mnemonic: D for double word, W for word, and B for byte. For example, if you want to deal with the lowest 8 bits of R8, you use the name R8B. Don’t make the beginner’s mistake of assuming that R8, R8D, R8W, and R8B are four separate and independent registers! A better metaphor is to think of the register names as country/state/county/city. \n\nIP register. \n\nWhile executing a program, the CPU uses IP to keep track of where it is in the current code segment. Instructions come in different sizes, ranging typically from 1 to 15 bytes. The CPU knows the size of each instruction it executes.\n\nIP is notable in being the only register that can neither be read nor written to directly.\n\nFlags register. \n\nRFLAGS, EFLAGS, FLAGS. When the flag’s value is 1, we say that the flag is set. When the flag’s value is 0, we say that the flag is cleared.\n\nMath Coprocessors and Their Registers (may be 128 bits or 256 bits)\n\nReal-Mode Flat Model \n\nReal-Mode Segmented Model \n\n32-bit Protected Mode Flat Model \n\n64-bit Long Mode \n\n## Chap5 The Right to Assemble: The Process of Creating Assembly Language Programs \n\nText files: are files that can be opened and examined meaningfully in a text editor, like notepad. \n\nBinary files: are files containing values that do not display meaningfully as text. \n\nAssemblers: read your source code files and generate an object code file containing the machine instructions that the CPU understands plus any data you've defined in your source code. \n\nLinker: Object code files cannot themselves be run as programs. An additional step, called linking, is necessary to turn object code files into executable program files.\n\nSymbol table: To process several object modules into a single executable module, the linker must first build an index called a symbol table, with an entry for every named item in every object module it links, with information on what name (called a symbol) refers to what location within the module. \n\nExe: Once the symbol table is complete, the linker builds an image of how the executable program will be arranged in memory when the operating system loads it. This image is then to disk as the executable file. The most important thing about the image that the linker builds relates to addresses.\n\nHoles: Object modules are allowed to refer to symbols in other object modules. During assembly, these external references are left as holes to be filled later—naturally enough, because the module in which these external symbolsexist may not have been assembled or even written yet. As the linker builds animage of the eventual executable program file, it learns where all of the symbols are located within the image and thus can drop real addresses into all of the external reference holes.\n\nDebugging info: Debugging information is, in a sense, a step backward. Portions of the source code, which was all stripped out early in the assembly process, are put back into the object module by the assembler. These portions of the source code are mostly the names of data items and procedures, and they’re embedded in the object file to make it easier for the programmer (you!) to see the names of data items when you debug the program.\n\nRelocatability: Primordial microcomputers like 8080 systems running CP/M-80 had a simple memory architecture. Programs were written to be loaded and run at a specific physical memory address. For CP/M, this was 0100H. The programmer could assume that any program would start at 0100H and go up from there. Memory addresses of data items and procedures were actual physical addresses, and every time the program ran, its data items were loaded and referenced at precisely the same place in memory.\nThis all changed with the arrival of the 8086, and 8086-specific operating systems such as CP/M-86 and PC DOS. Improvements in the Intel architecture introduced with the 8086 made it unnecessary for the program to be assembled for running at any specific physical memory address. This feature is called relocatability and is a necessary part of any modern operating system, especially when multiple programs may be running at once. \n\nThe author uses `nasm`. To compile an ASM file. Also `SASM` IDE for editing, building and debugging. `SASM` means SimpleAssembler.\n\n```BASH\nnasm -f elf64 -g -Fdwarf first.asm \n``` \n\n## Chap6 Linux and the Tools That Shape the Way You Work \n\nSASM: Simple ASM \n\nMake \n\n## Chap7 Following your instructions: Meeting Machine Instructions Up Close and Personal \n\ninstructions: xchg, inc, dec, jnz, jmp, neg, movsx, mul, div, imul, idiv      \n\nImmediate data is built right into its own machine instruction. Register data is stored in one of the CPU's collection of internal registers. In contrast, memory data is stored somewhere in the silver of system memory \"owned\" by a program, at a 64-bit memory address. \n\nOnly one of an instruction's two operands may specify a memory location. You can't move a memory value directly to another memory value. This is an inherent limitation of Intel CPUs of all generations. \n\nTo specify that we want the data at the memory location contained in a register rather than the data in the register itself, we use square brackets around the name of the register. \n\n```asm \nmov rax, [rbx]\n\nmov rax, [rbx + 16]\n\nmov rax, [rbx + rcx]\n\nmov rax, [rbx + rcx + 11]\n\n``` \n\nWhatever is inside the brackets is called the effective address of a data item in memory. At the current evolution of the Intel hardware, 2 registers may be added together to form the effective address, but not three or more. \n\nWhere the size issue gets tricky is when you write data in a register out to memory. NASM does not \"remember\" the size of variables, like higher-level languages do. It knows where EatMsg starts in memory, and that's it. You have to tell NASM how many bytes of data to move. This is done by a size specifier. \n\n```asm \nmov byte [EatMsg], 'G'\n```\n\nHere we tell NASM that we want to move only a single byte out to memory by using the BYTE size specifier. Other size specifiers include WORD, DWORD, QWORD. \n\nOnly 18 bits of the RFlags register are actually flags. The rest are reserved for later use in future generations of Intel CPUs. Even among the defined flags, only a few are commonplace, and fewer still are useful when you're just learning your way around. Some are used only inside system software like operating systems and are not available at all in userspace programs. \n\nOF: Overflow flag. is set when the result of an arithmetic operation\non a signed integer quantity becomes too large to fit in the operand it\noriginally occupied. OF is generally used as the “carry flag” in signed\narithmetic.\n\nDF: The\nDirection flag is an oddball among the flags in that it tells the\nCPU something that you want it to know, rather than the other way around.\nIt dictates the direction that activity moves (up-memory\nor down-memory)\nduring the execution of string instructions. When DF is set, string instructions\nproceed from high memory toward low memory. When DF is cleared,\nstring instructions proceed from low memory toward high memory.\n\nIF: The\nInterrupt Enable flag is a two-way\nflag. The CPU sets it under\ncertain conditions, and you can set it yourself using the STI and CLI\ninstructions—though\nyou probably won’t; see below. When IF is set,\ninterrupts are enabled and may occur when requested. When IF is cleared,\ninterrupts are ignored by the CPU. Ordinary programs could set and clear\nthis flag with impunity in Real Mode, back in the DOS era. Under Linux\n(whether 32-bit\nor 64-bit)\nIF is reserved for the use of the operating system\nand sometimes its drivers. If you try to use the STI and CLI instructions\nwithin one of your programs, Linux will hand you a general protection\nfault, and your program will be terminated. Consider IF off-limits\nfor\nuserspace programming like we’re discussing in this book.\n\nTF: When set, the Trap flag allows debuggers to manage single-stepping,\nby forcing the CPU to execute only a single instruction before calling an\ninterrupt routine. This is not an especially useful flag for ordinary programming,\nand I won’t have anything more to say about it in this book.\n\nSF: The Sign flag becomes set when the result of an operation forces the\noperand to become negative. By negative, we mean only that the highest-order\nbit in the operand (the sign bit) becomes 1 during a signed arithmetic\noperation. Any operation that leaves the sign of the result positive will\nclear SF\n\nZF: The Zero flag becomes set when the results of an operation become\nzero. If the destination operand instead becomes some nonzero value, ZF\nis cleared. You’ll be using this one a lot for conditional jumps.\n\nAF: The Auxiliary Carry flag. used only for BCD arithmetic. These instructions are considered obsolete and are not present in x64.\n\nPF: The Parity flag PF indicates whether the number of set (1) bits in the low-order\nbyte of a result is even or odd. For example, if the result is 0F2H, PF will\nbe cleared because 0F2H (11110010) contains an odd number of 1 bits.\n\n\nCF: The Carry flag is used in unsigned arithmetic operations. If the result\nof an arithmetic or shift operation “carries out” a bit from the operand,\nCF becomes set. Otherwise, if nothing is carried out, CF is cleared. \n\nThe highest bit in the most significant byte of a signed value is the sign bit. If the sign bit is a 1-bit, the number is negative. \n\nmovsx: move with sign extension \n\n```asm \nxor rax, rax \nmov ax, -42 \nmovsx rbx, ax ;rbx will become -42 in two's complement \n```\n\n`mul` instruction has implicit operand. Immediate values cannot be used as operands for `mul`. MUL very helpfully sets the Carry flag CF when the value of the product overflows the low-order register.\n\n\n|explicit operand|implicit operand   |implicit product   |\n|---|---|---|\n|mul r/m8|AL   |AX   |\n|mul r/m16|AX   |DX:AX   |\n|mul r/m32|EAX   |EDX:EAX   |\n|mul r/m64|RAX   |RDX:RAX   |\n\n|explicit operand|implicit operand   |quotient   |remainder|\n|---|---|---|---|\n|div r/m8|AX   |AL   |AH|\n|div r/m16|DX:AX   |AX   |DX|\n|div r/m32|EDX:EAX    |EAX  |EDX|\n|div r/m64|RDX:RAX   |RAX   |RDX|\n\nNote: r/m8 means 8bits register or memory \n\n```asm \nmov eax,447\nmov ebx,1739\nmul ebx\n```\n\n## Chap8 Creating programs that work \n\nOrdinary user-space programs written in NASM for Linux are divided into 3 sections. The order in which these sections fall in your program really isn't important, but by convention the .data section comes first, followed by the .bss section and then the .text section. \n\n.data section contains data definitions of initialized data items. \n\n.bss Block/Buffer Start Symbol. Contains data items not having values before the program begins running. \n\nData items in the .data section add to the size of your executable file. Data items in the .bss section do not. A buffer that takes up 16,1000 bytes can be defined in .bss and add almost nothing( about 50 bytes for the desctiption) to the executable file size. This is possible because of the way the Linux loader brings the programs into memory. When you build your executable file, the Linux linker adds info to the file describing all the symbols you've defined, including symbols naming data items. The loader knows which data items do not have initial values, and it allocates space in momory for them when it brings the executable in from disk. Data items with initial values are read in along with their values. \n\nThe actual machine instructions that make up your program go into the .text section. The .text section contains symbols called labels that identify locations in the program code for jumps and calls. All global labels must be declared in the .text section, or the labels cannot be \"seen\" outside your program. \n\nRefer to [compiler,linker,assembler,loader](https://www.baeldung.com/cs/compiler-linker-assembler-loader) \n\nLinux Compiler: A compiler is a specialized system tool that translates a program written in a specific programming language into the assembly language code. \n\nLinux Assembler: The assembler translates our assembly code to the machine code and then stores the result in an object file. Moving further, the assembler gives a memory location to each object and instruction in our code. The memory location can be physical as well as virtual. A virtual location is an offset that is relative to the base address of the first instruction.\n\nLinux Linker: The linker combines all external programs (such as libraries and other shared components) with our program to create a final executable.\n\nLinux Loader: The loader is a specialized operating system module. It loads the final executable code into memory. \n\nLabels must begin with a letter or else with an underscore, period, or question mark. Theese last three have special meanings to the assembler, so don't use them until you know how NASM interprets them. \n\nLabels must be followed by a colon when they are defined. \n\nLabels are case sensitive. \n\nPUSH: pushes a 16-bit or 64-bit register or memory value that is specified by you in your source code. Note that you can't push an 8-bit nor a 32-bit value onto the stack! You'll get an error if you try. \n\nPUSHFQ: pushes the full 64-bit RFlags register onto the stack. The Q means quadword. \n\nAny of the 16-bit and 64-bit general-purpose registers may be pushed individually onto the stack. You can't push AL or BH or any other of the 8-bit registers. 16bit and 64bit immediate data can be pushed onto the stack. User-space Linux programs cannot push the segment registers onto the stack under any circumstance. With x64, segment registers belong to the OS and are unavailable to user-space programs. As odd as it might seem, 32-bit values (including all 32-bit registers) may not be pushed onto the stack. \n\nPOP\n\n```asm \npopfq ; pop 8bytes from the stack into RFlags \npop rcx \npop bx \npop [rbx] \n``` \n\nPUSHA, PUSHAD, POPA, POPAD are gone in x64, though they are available in x86-32. These instructions were used to push or pop all of the general-purpose registers at once. They are removed likely due to that there are a lot more general-purpose registers in x64. \n\nABI: Application Binary Interface. It defines a collection of fundamental callable functions, generally supplied by the operating system, as is done in Linux. This definition describes how to pass parameters to the many kernel service functions. An ABI also defines how linkers link compiled or assembled modules into a single executable binary program. \n\nRDI, RSI, RDX, R10,R8,R9 specifies a system call's parameters. RAX is dedicated to the numeric code specifying the system call to be made. \n\nThe SYSCALL instruction itself makes use of RAX, RCX, and R11 internally. After the SYSCALL returns, you can't assume that RAX, RCX or R11 will have the same values they did before the SYSCALL. \n\nHow to reserve bytes in .bss section in NASM. How to do it in gas? \n```asm \n;nasm assembly \nsection .bss\nBuff resb 1\n```\n\n```asm\n;gas assembly \n.bss \n.lcomm buff1, 10 ;reserve length bytes for a local common denoted by symbol. Symbol is not declared global, so normally it is not visible to ld. \n.comm buff2, 10 ;declares common symbol named symbol. \n```\n\njb and ja are for unsigned number, and jg and jl are for signed number \n\njb: jump if below \n\nja: jump if above \n\njg: jump if greater \n\njl: jump if lesser \n\n```asm \n# upper.s\n# a program to convert user inputted char from lower case to upper case\n.data\n\n.bss\n.lcomm char,1 #local common buffer, with the name `char`, 1 byte size\n\n.text\n.global _start\n\n_start:\n    push %rbp\n    mov %rsp, %rbp\n\n    #read a char\n    mov $0, %rax\n    mov $0, %rdi\n    lea char, %rsi\n    mov $1, %rdx\n    syscall\n\n    lea char, %rax #put the addr of char to %rax\n    movb (%rax),%bl #put the byte value pointed by %rax to %rbx\n    cmp $0x61, %bl #subtract 0x61 from %bl and without changing %rbx\n    jb do_not_change #jump if below. Note the diff between Intel and AT&T syntax\n    cmp $0x7a, %bl\n    ja do_not_change\n    # convert the char to upper case\n    sub $0x20, %bl\n    movb %bl, (%rax) #put the byte value in %bl to memory pointed by %rax\ndo_not_change:\n\n    #write a char\n    mov $1, %rax\n    mov $1, %rdi\n    lea char, %rsi\n    mov $1, %rdx\n    syscall\n\n    #exit the program\n    mov $60, %rax #syscall number\n    mov $42, %rdi #exit code\n    syscall\n\n    pop %rbp\n```\n\nUse the commands below to build the above program. \n\n```bash \nas -g -o upper.o upper.s\nld -o upper upper.o\n```\n\nIn the above program, we should pay attention to the below facts. \n\n- The way to declare buffer in .bss segment via `.lcomm` or `.comm` \n- When using the `lea`, there is not `$` prefix in front of the label. When using the `mov`, there is `$` prefix. \n- To refer to memory, put the memory address between parentheses `movl\t0x20(%ebx),%eax` or `movl (%ebx),%eax`\n- When using the sub and cmp instructions, pay attention to the differences between AT&T syntax and Intel syntax. \n- The AT&T syntax mnenomics have a suffix, movb, movw, movl, movq. \n\n```asm\nmovb %bl, %al \nmovw %bx, %ax \nmovl %ebx, %eax \nmovq %rbx, %rax \n```\n\n## Chap9 Bits, Flags, Branches, and Tables, Easing Into Mainstream Assembly Coding \n\nInstructions: SHL, SHR, ROL, ROR, RCL, RCR, AND, OR, XOR, NOT, JC, JNC, STC, CLC, JMP, JZ, JNZ, CMP, TEST, BT, JA, JAE, JB, JBE, JE, JNE, JG, JGE, JL, JLE, JNBE, JNLE, XLAT     \n\nBits in assembly language are numbered, starting from 0. The least significant bit is the one with the least value in the binary number system. When you count bits, start with the bits on the right-hand end, and number them leftward from 0. \n\nNote: CS, DS, SS, ES segment registers are not GP(general purpose) registers. \n\nIn x64, the shift instructions require ether a immediate value from 0-255 or CL(CL instead of CX, ECX, RCX). \n\nShifting by 0 is pointless but allowed. \n\nYou cannot shift more positions than the destination register has. In 64-bit long mode, you cannot shift more than 63 counts. Attempting to do so won't trigger an error. It just won't work. CPU masks the count value to the 6 lowest bits before the instruction is executed. \n\nIn 32-bit protected mode, CPU masks the count values to the 5 lowest bits. \n\nShifting a bit off the left end of a binary value doesn't exactly send that bit into cosmic nothingness. A bit shifted out of the left end of a binary value is bumped into a temporary bucket for bits called the CF(Carry Flag). We can test the state of the CF with a branching instruction(JC, JNC). \n\nJC: Jump if Carry \n\nJNC: Jump if Not Carry \n\nJZ: Jump if Zero \n\nJNZ: Jump if not Zero \n\nJMP: Jump \n\nIf you shift a bit into the CF, and then immediately execute another shift operation, the bit bumped into the CF earlier will be bumped off the end of the world into cosmic nothingness.  \n\nIf a bit's destiny is not to be lost in cosmic nothingness, you need to use the rotate instructions RCL(Rotate Carry Left), RCR(Rotate Carry Right), ROL(Rotate Left) and ROR(Rotate Right). A bit bumped off one end of the operand reappears at the opposite end of the operand. \n\nSTC: Set Carry bit \n\nCLC: Clear Carry bit \n\nCF, Carry Flag\n\nZF, Zero Flag \n\nSF, Sign Flag \n\nDF, Direction Flag \n\nOF, Overflow Flag \n\nBT, Bit Test, it copies the specific bit in the first operand into the CF. \n\n```asm \n;intel syntax \n;check the 4th bits of rax, counting from 0 \nbt rax,4\njnc quit ; jump if the 4th bit is not 1 \n```\n\nX86-64 long mode memory addressing. \n\n```asm \n;BASE can be any GP register \n;INDEX can be any GP register \n;SCALE can be 1,2,4,8\n;DISP(displacement) can be any 32bit constant\nBASE + (INDEX * SCALE) + DISP\n;example in intel syntax \n[rsi + rbp*4 + 9]\n;example in AT&T syntax \njmpq *0x402680(%rbp,%rax,8) \n```\n\nLEA has a off-label purpose: doing fast math without shifts, adds or MUL. \n\n```asm \n;intex syntax \n;multiply rdx by 3 \nlea rdx,[rdx*2+rdx]\n```\n\n## Chap10 Dividing and Conquering: Using procedures and macros to battle program complexity \npage 299  \n\n# end \n\npage 251 Chap9  \n\nideas: \n\nhow to use `.equ . - MSGBEGIN` to define the message length, to be used in sys call. \n\nhow to zero a register. \n\nRecursive function call after loop. \n\nUse MUL and SHIFT operations for multiplication. \n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}